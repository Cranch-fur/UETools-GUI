#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeadByDaylight

#include "Basic.hpp"

#include "NetworkUtilities_structs.hpp"
#include "Customization_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "SocialParty_structs.hpp"
#include "AIModule_structs.hpp"
#include "Engine_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDAudio_structs.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "SlateCore_structs.hpp"
#include "RewardUtilities_structs.hpp"
#include "StatSystem_structs.hpp"
#include "InputCore_structs.hpp"
#include "PlatformsProviders_structs.hpp"
#include "DBDUIViewInterfaces_structs.hpp"
#include "OnlineMessagesUtilities_structs.hpp"


namespace SDK
{

// Enum DeadByDaylight.EEndGameReason
// NumValues: 0x0008
enum class EEndGameReason : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	KillerLeft                               = 2,
	PlayerLeftDuringLoading                  = 3,
	KillerLeftEarly                          = 4,
	InvalidPlayerRoles                       = 5,
	LoadingTimeout                           = 6,
	EEndGameReason_MAX                       = 7,
};

// Enum DeadByDaylight.ETileSpawnPointType
// NumValues: 0x000A
enum class ETileSpawnPointType : uint8
{
	Unspecified                              = 0,
	Survivor                                 = 1,
	SurvivorItem                             = 2,
	Killer                                   = 3,
	KillerItem                               = 4,
	InteractableObject                       = 5,
	BasementObject                           = 6,
	FinisherMori                             = 7,
	Count                                    = 8,
	ETileSpawnPointType_MAX                  = 9,
};

// Enum DeadByDaylight.EServerUseNetAsyncLoading
// NumValues: 0x0004
enum class EServerUseNetAsyncLoading : uint8
{
	NotSet                                   = 0,
	Yes                                      = 1,
	No                                       = 2,
	EServerUseNetAsyncLoading_MAX            = 3,
};

// Enum DeadByDaylight.EIntroState
// NumValues: 0x0006
enum class EIntroState : uint8
{
	WaitingToStart                           = 0,
	RotationStarted                          = 1,
	RotationCompleted                        = 2,
	PanInStarted                             = 3,
	PanInCompleted                           = 4,
	EIntroState_MAX                          = 5,
};

// Enum DeadByDaylight.EDBDScoreTypes
// NumValues: 0x00EF
enum class EDBDScoreTypes : uint8
{
	DBDCamperScore_SurviveHealthy            = 0,
	DBDCamperScore_SurviveWounded            = 1,
	DBDCamperScore_SurviveKO                 = 2,
	DBDCamperScore_UnlockHatch               = 3,
	DBDCamperScore_EscapeThroughHatch        = 4,
	DBDCamperScore_AllEscapeThroughHatch     = 5,
	DBDCamperScore_EscapeCarry               = 6,
	DBDCamperScore_SurviveStreakSmall        = 7,
	DBDCamperScore_SurviveStreakBig          = 8,
	DBDCamperScore_DamageStateChanged        = 9,
	DBDCamperScore_NearFriendInNeed          = 10,
	DBDCamperScore_NearFriendInNeed_PostExit = 11,
	DBDCamperScore_FoundCamper               = 12,
	DBDCamperScore_CoopObjectives            = 13,
	DBDCamperScore_OpenDoorPercent           = 14,
	DBDCamperScore_OpenDoor                  = 15,
	DBDCamperScore_GeneratorPercent          = 16,
	DBDCamperScore_GeneratorSkillCheckSuccess = 17,
	DBDCamperScore_GeneratorSkillCheckBonus  = 18,
	DBDCamperScore_SearchablePercent         = 19,
	DBDCamperScore_SearchCompleteFinalContributionPercent = 20,
	DBDCamperScore_AddItemToMap              = 21,
	DBDCamperScore_FixGenerator              = 22,
	DBDCamperScore_FixSpecialMapGenerator    = 23,
	DBDCamperScore_LastSurvivorFixGenerator  = 24,
	DBDCamperScore_RepairDamagedGenerator    = 25,
	DBDCamperScore_PowerExitGates            = 26,
	DBDCamperScore_CoopAltruism              = 27,
	DBDCamperScore_HealPercent               = 28,
	DBDCamperScore_HealPercent_PostExit      = 29,
	DBDCamperScore_HealFromDying             = 30,
	DBDCamperScore_HealFromDying_PostExit    = 31,
	DBDCamperScore_HealFromInjured           = 32,
	DBDCamperScore_HealFromInjured_PostExit  = 33,
	DBDCamperScore_HealSkillCheckSuccess     = 34,
	DBDCamperScore_HealSkillCheckBonus       = 35,
	DBDCamperScore_HealSelfPercent           = 36,
	DBDCamperScore_HealSelfSkillCheckSuccess = 37,
	DBDCamperScore_HealSelfSkillCheckBonus   = 38,
	DBDCamperScore_HitAfterHookSave          = 39,
	DBDCamperScore_HitNearFriendInNeed       = 40,
	DBDCamperScore_HitNearUnhookedFriendInNeed = 41,
	DBDCamperScore_SabotageHook              = 42,
	DBDCamperScore_SabotageHookSkillCheckSuccess = 43,
	DBDCamperScore_SabotageHookSkillCheckBonus = 44,
	DBDCamperScore_EscapeFromHook            = 45,
	DBDCamperScore_HookStrugglePerSecond     = 46,
	DBDCamperScore_SaveFromHook              = 47,
	DBDCamperScore_SaveFromHook_PostExit     = 48,
	DBDCamperScore_WasUnhooked               = 49,
	DBDCamperScore_SabotageBearTrap          = 50,
	DBDCamperScore_SabotageBearTrapSkillCheckSuccess = 51,
	DBDCamperScore_SabotageBearTrapSkillCheckBonus = 52,
	DBDCamperScore_DisableBearTrap           = 53,
	DBDCamperScore_SaveFromBearTrap          = 54,
	DBDCamperScore_SaveFromBearTrap_PostExit = 55,
	DBDCamperScore_EscapeBearTrap            = 56,
	DBDCamperScore_BasementChillingPerSecond = 57,
	DBDCamperScore_CoopBoldness              = 58,
	DBDCamperScore_SlasherStun               = 59,
	DBDCamperScore_SlasherStunCarrying       = 60,
	DBDCamperScore_SlasherBlind              = 61,
	DBDCamperScore_SlasherBurnInvisibility   = 62,
	DBDCamperScore_ChasePerSecond            = 63,
	DBDCamperScore_ChaseEscape               = 64,
	DBDCamperScore_ChaseSteal                = 65,
	DBDCamperScore_ChaseBlind                = 66,
	DBDCamperScore_VaultInChase              = 67,
	DBDCamperScore_NoiseDistraction          = 68,
	DBDCamperScore_SprintingNearSlasherPerSecond = 69,
	DBDCamperScore_UnhideNearSlasher         = 70,
	DBDCamperScore_EscapeWhileChased         = 71,
	DBDCamperScore_DestroyPhantomTrap        = 72,
	DBDCamperScore_NewItem                   = 73,
	DBDCamperScore_StartMatchWithUltraRareItem = 74,
	DBDCamperScore_ItemFrom                  = 75,
	DBDCamperScore_ExposerAdded              = 76,
	DBDSlasherScore_Destroy                  = 77,
	DBDSlasherScore_Kill                     = 78,
	DBDSlasherScore_BleedOut                 = 79,
	DBDSlasherScore_BleedOutPercent          = 80,
	DBDSlasherScore_AttackSuccess            = 81,
	DBDSlasherScore_AttackDeviousness        = 82,
	DBDSlasherScore_InterruptGenerator       = 83,
	DBDSlasherScore_InterruptWindow          = 84,
	DBDSlasherScore_InterruptHide            = 85,
	DBDSlasherScore_InterruptExit            = 86,
	DBDSlasherScore_InterruptUnhook          = 87,
	DBDSlasherScore_InterruptChest           = 88,
	DBDSlasherScore_InterruptOpenHatch       = 89,
	DBDSlasherScore_InterruptExitHatch       = 90,
	DBDSlasherScore_FindHiding               = 91,
	DBDSlasherScore_PlaceTrap                = 92,
	DBDSlasherScore_Trap                     = 93,
	DBDSlasherScore_TrapPickup               = 94,
	DBDSlasherScore_Hook                     = 95,
	DBDSlasherScore_SacrificePercent         = 96,
	DBDSlasherScore_SacrificeSuccess         = 97,
	DBDSlasherScore_SacrificedCount          = 98,
	DBDSlasherScore_NoEscape                 = 99,
	DBDSlasherScore_ChaseStart               = 100,
	DBDSlasherScore_ChasePerSecond           = 101,
	DBDSlasherScore_CloakStalkPerSecond      = 102,
	DBDSlasherScore_UncloakInView            = 103,
	DBDSlasherScore_UncloakAttack            = 104,
	DBDSlasherScore_EvadeInvisBurn           = 105,
	DBDSlasherScore_EvadeBlind               = 106,
	DBDSlasherScore_CamperDisconnect         = 107,
	DBDSlasherScore_HitCamperWithChainsaw    = 108,
	DBDSlasherScore_RunningWithChainsaw      = 109,
	DBDSlasherScore_ChainBlinkAttack         = 110,
	DBDSlasherScore_ChainBlinkInterrupt      = 111,
	DBDSlasherScore_ChainBlinkInterruptAfter3 = 112,
	DBDSlasherScore_ChainBlinkStartChase     = 113,
	DBDSlasherScore_StalkpointGained         = 114,
	DBDSlasherScore_StalkerTierIncrement     = 115,
	DBDSlasherScore_StalkerTierFirstTime     = 116,
	DBDSlasherScore_StalkerKillAllCampers    = 117,
	DBDSlasherScore_PhantomTrapSet           = 118,
	DBDSlasherScore_PhantomTrapTrigger       = 119,
	DBDSlasherScore_PhantomTrapTriggerAttack = 120,
	DBDSlasherScore_PhantomTrapTeleportAttack = 121,
	DBDSlasherScore_PhantomTrapTeleportAttackAllCampers = 122,
	DBDSlasherScore_ThrillOfTheHunt          = 123,
	DBDPlayerScore_BloodwebLevelUp           = 124,
	DBDPlayerScore_BloodwebPrestigeLevelUp   = 125,
	DBDPlayerScore_BloodwebPrestige3LevelUp  = 126,
	DBDPlayerScore_AwardPips                 = 127,
	DBDPlayerScore_AddBloodpoints            = 128,
	DBDPlayerScore_BloodpointsOneCategory    = 129,
	DBDPlayerScore_MaxBloodpointsAllCategories = 130,
	DBDPlayerScore_AddNewPerk                = 131,
	DBDPlayerScore_PerkLevelUp               = 132,
	DBDPlayerScore_BurnOfferingUltraRare     = 133,
	DBDPlayerScore_StartGame                 = 134,
	DBDPlayerScore_UnlockRanking             = 135,
	DBDPlayerScore_FinishWithPerks           = 136,
	DBDCamperScore_CheatObjectives           = 137,
	DBDCamperScore_CheatSurvival             = 138,
	DBDCamperScore_CheatAltruism             = 139,
	DBDCamperScore_CheatBoldness             = 140,
	DBDSlasherScore_CheatSacrifice           = 141,
	DBDSlasherScore_CheatBrutality           = 142,
	DBDSlasherScore_CheatDeviousness         = 143,
	DBDSlasherScore_CheatHunter              = 144,
	DBDCamperScore_CleanseDullTotem          = 145,
	DBDCamperScore_CleanseHexTotem           = 146,
	DBDPlayerScore_BalancedLanding           = 147,
	DBDPlayerScore_Lithe                     = 148,
	DBDSlasherScore_DamageGenerator          = 149,
	DBDSlasherScore_Vault                    = 150,
	DBDCamperScore_StartInjuredBleedout      = 151,
	DBDCamperScore_FullRecovery              = 152,
	DBDCamperScore_FirstTimeDying            = 153,
	DBDCamperScore_SecondTimeDying           = 154,
	DBDCamperScore_FirecrackerDisturbance    = 155,
	DBDCamperScore_GeneratorSkillCheckRuinBonus = 156,
	DBDCamperScore_SlasherBurnBlink          = 157,
	DBDCamperScore_DieSacrificed             = 158,
	DBDCamperScore_DieBleedOut               = 159,
	DBDCamperScore_DieKill                   = 160,
	DBDPlayerScore_EndGame                   = 161,
	DBDPlayerScore_EnterParadise             = 162,
	DBDSlasherScore_CamperHookedFirstTime    = 163,
	DBDSlasherScore_CamperEnterHookStrugglePhase = 164,
	DBDSlasherScore_ElectroShockSurvivor     = 165,
	DBDSlasherScore_BringAllSurvivorsToMadnessTier3 = 166,
	DBDSlasherScore_BringSurvivorUpOneMadnessTier = 167,
	DBDSlasherScore_HitSurvivorAfterElectroShock = 168,
	DBDSlasherScore_PickupCamper             = 169,
	DBDSlasherScore_Blink                    = 170,
	DBDSlasherScore_TeleportToPhantomTrap    = 171,
	DBDSlasherScore_HatchetThrow             = 172,
	DBDSlasherScore_HatchetHit               = 173,
	DBDSlasherScore_HatchetSkillShotHit      = 174,
	DBDSlasherScore_HatchetFarHit            = 175,
	DBDCamperScore_QuickVault                = 176,
	DBDCamperScore_QuickCloset               = 177,
	DBDCamperScore_StartGeneratorRepair      = 178,
	DBDCamperScore_StartCleansingTotem       = 179,
	DBDCamperScore_FirstRepairSkillCheck     = 180,
	DBDSlasherScore_CamperDisconnectedBeforeMatchStart = 181,
	DBDSlasherScore_CamperDisconnectedDuringMatch = 182,
	DBDCamperScore_NearFriendInNeed_GeneratorsComplete = 183,
	DBDCamperScore_HealPercent_GeneratorsComplete = 184,
	DBDCamperScore_HealFromDying_GeneratorsComplete = 185,
	DBDCamperScore_SaveFromHook_GeneratorsComplete = 186,
	DBDCamperScore_SaveFromBearTrap_GeneratorsComplete = 187,
	DBDCamperScore_SnapOutOfIt               = 188,
	DBDSlasherScore_HookInBasement           = 189,
	DBDSlasherScore_LFChainsawHit            = 190,
	DBDCamperScore_PalletDrop                = 191,
	DBDCamperScore_Vault                     = 192,
	DBDSlasherScore_StartChaseWithChainsawAttack = 193,
	DBDSlasherScore_MissedAttackInChase      = 194,
	DBDCamperScore_DodgeAndVault             = 195,
	DBDCamperScore_BeginQuickVault           = 196,
	DBDSlasherScore_StartChainsawAttack      = 197,
	DBDCamperScore_WakeUpBySkillCheck        = 198,
	DBDCamperScore_FallAsleep                = 199,
	DBDCamperScore_WakeUpSelf                = 200,
	DBDCamperScore_WakeUpOther               = 201,
	DBDSlasherScore_RecentlyAsleepAttack     = 202,
	DBDSlasherScore_SurvivorPartyOnBasementHooks = 203,
	DBDCamperScore_LootBasementChest         = 204,
	DBDPlayerScore_OpenMysteryBox            = 205,
	DBDGameEvent_SurvivorDowned              = 206,
	DBDGameEvent_SurvivorDied                = 207,
	DBDGameEvent_KillerCloak                 = 208,
	DBDSlasherScore_SetReverseBearTrap       = 209,
	DBDSlasherScore_AbductionDash            = 210,
	DBDSlasherScore_DashHitSuccess           = 211,
	DBDSlasherScore_KillWithReverseBearTrap  = 212,
	DBDCamperScore_SearchRBTKey              = 213,
	DBDCamperScore_EscapeRBT                 = 214,
	DBDGameEvent_ReplacedGoodSkillCheckAsGreat = 215,
	DBDCamperScore_RemoveReverseBearTrapSkillCheckSuccess = 216,
	DBDCamperScore_RemoveReverseBearTrapSkillCheckBonus = 217,
	DBDSlasherScore_DamageGeneratorWhileHooked = 218,
	DBDGameEvent_SurvivorDamaged             = 219,
	DBDGameEvent_SurvivorHealed              = 220,
	DBDGameEvent_Interruption                = 221,
	DBDGameEvent_SurvivorFailedHealSkillcheck = 222,
	DBDGameEvent_HookedSurvivorSacrificeBegin = 223,
	DBDGameEvent_AcquireEventKillerCoin      = 224,
	DBDGameEvent_AcquireEventSurvivorCoin    = 225,
	DBDCamperScore_EventGeneratorFixed       = 226,
	DBDSlasherScore_HookedOnEventHook        = 227,
	DBDGameEvent_GeneratorProgress           = 228,
	DBDSlasherScore_DownSmokedCamper         = 229,
	DBDSlasherScore_HitSmokedCamper          = 230,
	DBDSlasherScore_SurvivorEnterGasCloud    = 231,
	DBDSlasherScore_BombDirectHit            = 232,
	DBDSlasherScore_ThrowBomb                = 233,
	DBDGameEvent_CoopAction                  = 234,
	DBDSlasherScore_StartActivePhaseWalk     = 235,
	DBDScore_Count                           = 236,
	Count                                    = 237,
	EDBDScoreTypes_MAX                       = 238,
};

// Enum DeadByDaylight.ECustomizationCategory
// NumValues: 0x000A
enum class ECustomizationCategory : uint8
{
	None                                     = 0,
	SurvivorHead                             = 1,
	SurvivorTorso                            = 2,
	SurvivorLegs                             = 3,
	KillerHead                               = 4,
	KillerBody                               = 5,
	KillerWeapon                             = 6,
	Outfits                                  = 7,
	Charm                                    = 8,
	ECustomizationCategory_MAX               = 9,
};

// Enum DeadByDaylight.EOfferingCategory
// NumValues: 0x000A
enum class EOfferingCategory : uint8
{
	None                                     = 0,
	Bloodpoints                              = 1,
	Mapmods                                  = 2,
	Realms                                   = 3,
	Shrouds                                  = 4,
	Wards                                    = 5,
	CharacterXP                              = 6,
	Luck                                     = 7,
	Moris                                    = 8,
	EOfferingCategory_MAX                    = 9,
};

// Enum DeadByDaylight.EPerkCategory
// NumValues: 0x0010
enum class EPerkCategory : uint8
{
	None                                     = 0,
	Navigation                               = 1,
	Perception                               = 2,
	Safeguard                                = 3,
	Concealment                              = 4,
	Strategy                                 = 5,
	Support                                  = 6,
	Adaptation                               = 7,
	Chasing                                  = 8,
	Tracking                                 = 9,
	Cruelty                                  = 10,
	Trickery                                 = 11,
	Obstruction                              = 12,
	Hinderance                               = 13,
	Enhancement                              = 14,
	EPerkCategory_MAX                        = 15,
};

// Enum DeadByDaylight.ETeachableStatus
// NumValues: 0x0005
enum class ETeachableStatus : uint8
{
	Unknown                                  = 0,
	Locked                                   = 1,
	AvailableInShrine                        = 2,
	Checked                                  = 3,
	ETeachableStatus_MAX                     = 4,
};

// Enum DeadByDaylight.EEmblemQuality
// NumValues: 0x0007
enum class EEmblemQuality : uint8
{
	None                                     = 0,
	Bronze                                   = 1,
	Silver                                   = 2,
	Gold                                     = 3,
	Iridescent                               = 4,
	Count                                    = 5,
	EEmblemQuality_MAX                       = 6,
};

// Enum DeadByDaylight.ECamperDamageState
// NumValues: 0x0005
enum class ECamperDamageState : uint8
{
	VE_Healthy                               = 0,
	VE_Injured                               = 1,
	VE_KO                                    = 2,
	VE_Dead                                  = 3,
	VE_MAX                                   = 4,
};

// Enum DeadByDaylight.EHealthType
// NumValues: 0x0006
enum class EHealthType : uint8
{
	Alive                                    = 0,
	Sacrificed                               = 1,
	Killed                                   = 2,
	BledOut                                  = 3,
	Left_Game                                = 4,
	EHealthType_MAX                          = 5,
};

// Enum DeadByDaylight.ECamperImmobilizeState
// NumValues: 0x0007
enum class ECamperImmobilizeState : uint8
{
	VE_None                                  = 0,
	VE_Hooked                                = 1,
	VE_Trapped                               = 2,
	VE_Hiding                                = 3,
	VE_Dead                                  = 4,
	VE_InDeathBed                            = 5,
	VE_MAX                                   = 6,
};

// Enum DeadByDaylight.EAttackZoneSet
// NumValues: 0x0003
enum class EAttackZoneSet : uint8
{
	VE_OriginalZones                         = 0,
	VE_WedgeZones                            = 1,
	VE_MAX                                   = 2,
};

// Enum DeadByDaylight.ESlasherGuidedAction
// NumValues: 0x0005
enum class ESlasherGuidedAction : uint8
{
	VE_None                                  = 0,
	VE_Hooking                               = 1,
	VE_PickingUp                             = 2,
	VE_PuttingDown                           = 3,
	VE_MAX                                   = 4,
};

// Enum DeadByDaylight.EOfferingAnimState
// NumValues: 0x000A
enum class EOfferingAnimState : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Init                                     = 2,
	Reveal                                   = 3,
	ShowInteraction                          = 4,
	Burned                                   = 5,
	Returned                                 = 6,
	Cancel                                   = 7,
	Hidden                                   = 8,
	EOfferingAnimState_MAX                   = 9,
};

// Enum DeadByDaylight.EGeneratorTrapType
// NumValues: 0x0004
enum class EGeneratorTrapType : uint8
{
	None                                     = 0,
	BlastMine                                = 1,
	Wiretap                                  = 2,
	EGeneratorTrapType_MAX                   = 3,
};

// Enum DeadByDaylight.EInteractionComparisonPriority
// NumValues: 0x0004
enum class EInteractionComparisonPriority : uint8
{
	Lower                                    = 0,
	Equal                                    = 1,
	Higher                                   = 2,
	EInteractionComparisonPriority_MAX       = 3,
};

// Enum DeadByDaylight.EInteractionOwnership
// NumValues: 0x0004
enum class EInteractionOwnership : uint8
{
	AnyCanUse                                = 0,
	OnlyOwnerCanUse                          = 1,
	OwnerCannotUse                           = 2,
	EInteractionOwnership_MAX                = 3,
};

// Enum DeadByDaylight.ESnapBackPositionType
// NumValues: 0x0003
enum class ESnapBackPositionType : uint8
{
	SnapBackToInitialPosition                = 0,
	SnapBackToOffsetPositionFromSnap         = 1,
	ESnapBackPositionType_MAX                = 2,
};

// Enum DeadByDaylight.ESnapBackType
// NumValues: 0x0006
enum class ESnapBackType : uint8
{
	None                                     = 0,
	Always                                   = 1,
	OnInteractionCancelledOnly               = 2,
	OnInteractionEndOnly                     = 3,
	OnSurvivorDownedOnly                     = 4,
	ESnapBackType_MAX                        = 5,
};

// Enum DeadByDaylight.ETotemState
// NumValues: 0x0005
enum class ETotemState : uint8
{
	Cleansed                                 = 0,
	Dull                                     = 1,
	Hex                                      = 2,
	Boon                                     = 3,
	ETotemState_MAX                          = 4,
};

// Enum DeadByDaylight.ETutorialStep
// NumValues: 0x0007
enum class ETutorialStep : uint8
{
	Survivor_NotStarted                      = 0,
	Survivor_CompleteGenerator               = 1,
	Survivor_EvadeKiller                     = 2,
	Survivor_OnHook                          = 3,
	Done                                     = 4,
	Invalid                                  = 5,
	ETutorialStep_MAX                        = 6,
};

// Enum DeadByDaylight.EInventoryType
// NumValues: 0x0003
enum class EInventoryType : uint8
{
	Main                                     = 0,
	Backpack                                 = 1,
	EInventoryType_MAX                       = 2,
};

// Enum DeadByDaylight.EAttachToSocketNameEnum
// NumValues: 0x0007
enum class EAttachToSocketNameEnum : uint8
{
	ManualAttachment                         = 0,
	HandItemSocket                           = 1,
	Weapon_SocketLT                          = 2,
	Weapon_SocketRT                          = 3,
	LanternCollectableSocket                 = 4,
	Tentacle_SocketLT                        = 5,
	EAttachToSocketNameEnum_MAX              = 6,
};

// Enum DeadByDaylight.ECollectableState
// NumValues: 0x0006
enum class ECollectableState : uint8
{
	OnGround                                 = 0,
	Stored                                   = 1,
	Equipped                                 = 2,
	ToBeDropped                              = 3,
	InSearchable                             = 4,
	ECollectableState_MAX                    = 5,
};

// Enum DeadByDaylight.ECollectableCategory
// NumValues: 0x0003
enum class ECollectableCategory : uint8
{
	Common                                   = 0,
	Rare                                     = 1,
	ECollectableCategory_MAX                 = 2,
};

// Enum DeadByDaylight.EItemHandPosition
// NumValues: 0x0009
enum class EItemHandPosition : uint8
{
	None                                     = 0,
	HandleItem                               = 1,
	AimItem                                  = 2,
	SmallItem                                = 3,
	FirecrackerItem                          = 4,
	VaccineItem                              = 5,
	FragileObjectItem                        = 6,
	SprayBottleItem                          = 7,
	EItemHandPosition_MAX                    = 8,
};

// Enum DeadByDaylight.EAtlantaItemProgressionBarEnum
// NumValues: 0x0003
enum class EAtlantaItemProgressionBarEnum : uint8
{
	PrimaryBar                               = 0,
	SecondaryBar                             = 1,
	EAtlantaItemProgressionBarEnum_MAX       = 2,
};

// Enum DeadByDaylight.ELanternState
// NumValues: 0x0005
enum class ELanternState : uint8
{
	Collectable                              = 0,
	Collected                                = 1,
	Destroyed                                = 2,
	Destroyable                              = 3,
	ELanternState_MAX                        = 4,
};

// Enum DeadByDaylight.EHitValidatorConfigName
// NumValues: 0x0008
enum class EHitValidatorConfigName : uint8
{
	Default                                  = 0,
	Hatchet                                  = 1,
	Bomb                                     = 2,
	Harpoon                                  = 3,
	Oni                                      = 4,
	Whip                                     = 5,
	DefaultProjectile                        = 6,
	EHitValidatorConfigName_MAX              = 7,
};

// Enum DeadByDaylight.EMovementCurveType
// NumValues: 0x0003
enum class EMovementCurveType : uint8
{
	AdditiveSpeedCurve                       = 0,
	MultiplicativeSpeedCurve                 = 1,
	EMovementCurveType_MAX                   = 2,
};

// Enum DeadByDaylight.EAudioCustomizationCategory
// NumValues: 0x0009
enum class EAudioCustomizationCategory : uint8
{
	AudioCharacterName                       = 0,
	AudioCharacterSubName                    = 1,
	AudioCharacterHead                       = 2,
	AudioCharacterClothes                    = 3,
	AudioCharacterShoes                      = 4,
	AudioCharacterWeapon                     = 5,
	AudioCharacterAmbiance                   = 6,
	AudioCharacterState                      = 7,
	EAudioCustomizationCategory_MAX          = 8,
};

// Enum DeadByDaylight.EActionButtonState
// NumValues: 0x0005
enum class EActionButtonState : uint8
{
	Normal                                   = 0,
	Toggled                                  = 1,
	Disabled                                 = 2,
	Hidden                                   = 3,
	EActionButtonState_MAX                   = 4,
};

// Enum DeadByDaylight.EKnowledgeSharingType
// NumValues: 0x0005
enum class EKnowledgeSharingType : uint8
{
	Possessor                                = 0,
	Survivors                                = 1,
	Killers                                  = 2,
	All                                      = 3,
	EKnowledgeSharingType_MAX                = 4,
};

// Enum DeadByDaylight.EGameplayElementType
// NumValues: 0x0012
enum class EGameplayElementType : uint8
{
	Generic                                  = 0,
	MeatLocker_Small                         = 1,
	TileLights                               = 2,
	MeatLocker_Big                           = 3,
	Searchable                               = 4,
	EdgeObjects                              = 5,
	LivingWorldObjects                       = 6,
	Hatch                                    = 7,
	Bookshelves                              = 8,
	Totems                                   = 9,
	QuadrantSpawn                            = 10,
	EdgeObjectsBlocker                       = 11,
	BreakableWalls                           = 12,
	Escape                                   = 13,
	ThemeSpawner                             = 14,
	Basement_Attachments                     = 15,
	Count                                    = 16,
	EGameplayElementType_MAX                 = 17,
};

// Enum DeadByDaylight.EAIHideInLockerState
// NumValues: 0x0004
enum class EAIHideInLockerState : uint8
{
	WalkToLocker                             = 0,
	GetIntoLocker                            = 1,
	HidingInLocker                           = 2,
	EAIHideInLockerState_MAX                 = 3,
};

// Enum DeadByDaylight.EAIRepairGeneratorState
// NumValues: 0x0006
enum class EAIRepairGeneratorState : uint8
{
	FindAvailableGeneratorPosition           = 0,
	WalkToGenerator                          = 1,
	RotateTowardsGenerator                   = 2,
	BeginGeneratorRepairs                    = 3,
	RepairingGenerator                       = 4,
	EAIRepairGeneratorState_MAX              = 5,
};

// Enum DeadByDaylight.EOwnershipBehaviour
// NumValues: 0x0003
enum class EOwnershipBehaviour : uint8
{
	Personal                                 = 0,
	Shared                                   = 1,
	EOwnershipBehaviour_MAX                  = 2,
};

// Enum DeadByDaylight.EStackingBehaviours
// NumValues: 0x0003
enum class EStackingBehaviours : uint8
{
	Stackable                                = 0,
	Override                                 = 1,
	EStackingBehaviours_MAX                  = 2,
};

// Enum DeadByDaylight.EAdditiveBehaviour
// NumValues: 0x0003
enum class EAdditiveBehaviour : uint8
{
	AddValues                                = 0,
	MaxValue                                 = 1,
	EAdditiveBehaviour_MAX                   = 2,
};

// Enum DeadByDaylight.EContextualType
// NumValues: 0x000E
enum class EContextualType : uint8
{
	None                                     = 0,
	RedGlyph                                 = 1,
	BlueGlyph                                = 2,
	YellowGlyph                              = 3,
	PurpleGlyph                              = 4,
	IceBlueGlyph                             = 5,
	GreenGlyph                               = 6,
	OrangeGlyph                              = 7,
	PinkGlyph                                = 8,
	GlyphUpperBound                          = 9,
	ToxinPlantHalloween2020                  = 10,
	PumpkinHalloween2021                     = 11,
	CoreMemoryPortal                         = 12,
	EContextualType_MAX                      = 13,
};

// Enum DeadByDaylight.EArchiveStoryType
// NumValues: 0x0005
enum class EArchiveStoryType : uint8
{
	NotSet                                   = 0,
	CurrentStory                             = 1,
	PastStory                                = 2,
	EventStory                               = 3,
	EArchiveStoryType_MAX                    = 4,
};

// Enum DeadByDaylight.EArm
// NumValues: 0x0003
enum class EArm : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	EArm_MAX                                 = 2,
};

// Enum DeadByDaylight.EAtlantaControlTypeSetting
// NumValues: 0x0003
enum class EAtlantaControlTypeSetting : uint8
{
	CameraFullScreen                         = 0,
	SnapOnJoystick                           = 1,
	EAtlantaControlTypeSetting_MAX           = 2,
};

// Enum DeadByDaylight.EDeepLinkUid
// NumValues: 0x0013
enum class EDeepLinkUid : uint8
{
	NONE                                     = 0,
	StorefrontSpecialOffers                  = 1,
	StorefrontFeatured                       = 2,
	StorefrontPremium                        = 3,
	StorefrontSubscription                   = 4,
	Calendar                                 = 5,
	RitualsStarter                           = 6,
	RitualsDaily                             = 7,
	RitualsWeekly                            = 8,
	MenuCharactersSurvivors                  = 9,
	MenuCharactersKillers                    = 10,
	MenuCustomizations                       = 11,
	MenuEvents                               = 12,
	MenuFriends                              = 13,
	Loadout                                  = 14,
	BloodmarketSurvivors                     = 15,
	BloodmarketKillers                       = 16,
	External                                 = 17,
	EDeepLinkUid_MAX                         = 18,
};

// Enum DeadByDaylight.EAtlantaDisplayStandPosition
// NumValues: 0x0003
enum class EAtlantaDisplayStandPosition : uint8
{
	Forefront                                = 0,
	Background                               = 1,
	EAtlantaDisplayStandPosition_MAX         = 2,
};

// Enum DeadByDaylight.EEventsType
// NumValues: 0x0007
enum class EEventsType : uint8
{
	Generic                                  = 0,
	Calendar                                 = 1,
	BonusACEvent                             = 2,
	FirstPremiumPurchase                     = 3,
	MonthlyPass                              = 4,
	Count                                    = 5,
	EEventsType_MAX                          = 6,
};

// Enum DeadByDaylight.EFreeTicketButtonState
// NumValues: 0x0005
enum class EFreeTicketButtonState : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	InEffect                                 = 2,
	None                                     = 3,
	EFreeTicketButtonState_MAX               = 4,
};

// Enum DeadByDaylight.EQuitGameReason
// NumValues: 0x0006
enum class EQuitGameReason : uint8
{
	None                                     = 0,
	Logout                                   = 1,
	Suspend                                  = 2,
	Shutdown                                 = 3,
	Count                                    = 4,
	EQuitGameReason_MAX                      = 5,
};

// Enum DeadByDaylight.EFrameRateLimitButtonSetting
// NumValues: 0x0003
enum class EFrameRateLimitButtonSetting : uint8
{
	ThirtyFPS                                = 0,
	SixtyFPS                                 = 1,
	EFrameRateLimitButtonSetting_MAX         = 2,
};

// Enum DeadByDaylight.EKillerSoundComparisonType
// NumValues: 0x0004
enum class EKillerSoundComparisonType : uint8
{
	Equal                                    = 0,
	IsGreaterThan                            = 1,
	IsLesserThan                             = 2,
	EKillerSoundComparisonType_MAX           = 3,
};

// Enum DeadByDaylight.EMobileLoginAuthContext
// NumValues: 0x0004
enum class EMobileLoginAuthContext : uint8
{
	Splash                                   = 0,
	OverlayMenu                              = 1,
	ResumeFromSuspend                        = 2,
	EMobileLoginAuthContext_MAX              = 3,
};

// Enum DeadByDaylight.EAtlantaRewardType
// NumValues: 0x000D
enum class EAtlantaRewardType : uint8
{
	Item                                     = 0,
	AddOn                                    = 1,
	Offering                                 = 2,
	BloodPoints                              = 3,
	IridescentShards                         = 4,
	AuricCells                               = 5,
	Customization                            = 6,
	FreeTicket                               = 7,
	MysteryBox                               = 8,
	Character                                = 9,
	DuplicatesRefundKey                      = 10,
	Count                                    = 11,
	EAtlantaRewardType_MAX                   = 12,
};

// Enum DeadByDaylight.EAtlantaRitualRewardUIType
// NumValues: 0x000A
enum class EAtlantaRitualRewardUIType : uint8
{
	Item                                     = 0,
	AddOn                                    = 1,
	Offering                                 = 2,
	BloodPoints                              = 3,
	IridescentShards                         = 4,
	AuricCells                               = 5,
	Customization                            = 6,
	CustoTicket                              = 7,
	MysteryBox                               = 8,
	EAtlantaRitualRewardUIType_MAX           = 9,
};

// Enum DeadByDaylight.EAltantaRitualUIType
// NumValues: 0x0004
enum class EAltantaRitualUIType : uint8
{
	Single                                   = 0,
	Master                                   = 1,
	Special                                  = 2,
	EAltantaRitualUIType_MAX                 = 3,
};

// Enum DeadByDaylight.EAttackEventType
// NumValues: 0x0006
enum class EAttackEventType : uint8
{
	VE_None                                  = 0,
	VE_BasicAttackAttempt                    = 1,
	VE_BasicAttackHit                        = 2,
	VE_SpecialAttackAttempt                  = 3,
	VE_SpecialAttackHit                      = 4,
	VE_MAX                                   = 5,
};

// Enum DeadByDaylight.EBPBonusType
// NumValues: 0x0005
enum class EBPBonusType : uint8
{
	None                                     = 0,
	Event                                    = 1,
	Offerings                                = 2,
	Others                                   = 3,
	EBPBonusType_MAX                         = 4,
};

// Enum DeadByDaylight.EBloodchestType
// NumValues: 0x0005
enum class EBloodchestType : uint8
{
	None                                     = 0,
	Chest                                    = 1,
	SuperChests                              = 2,
	EntityBox                                = 3,
	EBloodchestType_MAX                      = 4,
};

// Enum DeadByDaylight.EBloodwebFillingMethod
// NumValues: 0x0003
enum class EBloodwebFillingMethod : uint8
{
	RestrictionsBasedOnData                  = 0,
	FillAll                                  = 1,
	EBloodwebFillingMethod_MAX               = 2,
};

// Enum DeadByDaylight.EBloodMarketRefreshMethod
// NumValues: 0x0003
enum class EBloodMarketRefreshMethod : uint8
{
	Automatic                                = 0,
	Manual                                   = 1,
	EBloodMarketRefreshMethod_MAX            = 2,
};

// Enum DeadByDaylight.EBloodwebDefinitionContentType
// NumValues: 0x0006
enum class EBloodwebDefinitionContentType : uint8
{
	Empty                                    = 0,
	Nodes                                    = 1,
	Paths                                    = 2,
	NodesAndPaths                            = 3,
	NodesNoPath                              = 1,
	EBloodwebDefinitionContentType_MAX       = 4,
};

// Enum DeadByDaylight.EBloodwebDistributionType
// NumValues: 0x0003
enum class EBloodwebDistributionType : uint8
{
	PerWeb                                   = 0,
	PerRing                                  = 1,
	EBloodwebDistributionType_MAX            = 2,
};

// Enum DeadByDaylight.EBloodwebDataSource
// NumValues: 0x0003
enum class EBloodwebDataSource : uint8
{
	ByLevel                                  = 0,
	ByRing                                   = 1,
	EBloodwebDataSource_MAX                  = 2,
};

// Enum DeadByDaylight.EBloodwebSaveReason
// NumValues: 0x0005
enum class EBloodwebSaveReason : uint8
{
	PayToRefresh                             = 0,
	PrestigeUp                               = 1,
	ShouldRebuild                            = 2,
	Cheat                                    = 3,
	EBloodwebSaveReason_MAX                  = 4,
};

// Enum DeadByDaylight.EBloodwebNodeGateTypes
// NumValues: 0x0004
enum class EBloodwebNodeGateTypes : uint8
{
	RequiredRank                             = 0,
	RequiredItem                             = 1,
	Count                                    = 2,
	EBloodwebNodeGateTypes_MAX               = 3,
};

// Enum DeadByDaylight.EBloodwebNodeContentType
// NumValues: 0x0011
enum class EBloodwebNodeContentType : uint8
{
	Empty                                    = 0,
	Perks                                    = 1,
	PerkBuffs_Do_Not_Use_Deprecated          = 2,
	Offerings                                = 3,
	Items                                    = 4,
	AddOn                                    = 5,
	Chests                                   = 6,
	PerksPacks                               = 7,
	IridiscentShards                         = 8,
	AuricCells                               = 9,
	SuperChests                              = 10,
	CosmeticItems                            = 11,
	Bloodpoints                              = 12,
	FreeTicket                               = 13,
	EntityBox                                = 14,
	Count                                    = 15,
	EBloodwebNodeContentType_MAX             = 16,
};

// Enum DeadByDaylight.EBloodwebNodeState
// NumValues: 0x0007
enum class EBloodwebNodeState : uint8
{
	Inactive                                 = 0,
	Available                                = 1,
	Locked_Do_Not_Use_Deprecated             = 2,
	Collected                                = 3,
	Consumed                                 = 4,
	Count                                    = 5,
	EBloodwebNodeState_MAX                   = 6,
};

// Enum DeadByDaylight.EBloodwebRing
// NumValues: 0x0008
enum class EBloodwebRing : uint8
{
	CenterRing                               = 0,
	InnerRing                                = 1,
	MiddleRing                               = 2,
	OuterRing                                = 3,
	EntityRing                               = 4,
	RingCount                                = 5,
	Count                                    = 6,
	EBloodwebRing_MAX                        = 7,
};

// Enum DeadByDaylight.EBreakableState
// NumValues: 0x0003
enum class EBreakableState : uint8
{
	Unbroken                                 = 0,
	Broken                                   = 1,
	EBreakableState_MAX                      = 2,
};

// Enum DeadByDaylight.ECameraOffsetState
// NumValues: 0x0006
enum class ECameraOffsetState : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Crouching                                = 2,
	Crawling                                 = 3,
	Carried                                  = 4,
	ECameraOffsetState_MAX                   = 5,
};

// Enum DeadByDaylight.ECameraFadeState
// NumValues: 0x0005
enum class ECameraFadeState : uint8
{
	FadedIn                                  = 0,
	FadingOut                                = 1,
	FadedOut                                 = 2,
	FadingIn                                 = 3,
	ECameraFadeState_MAX                     = 4,
};

// Enum DeadByDaylight.EManualZoomType
// NumValues: 0x0004
enum class EManualZoomType : uint8
{
	None                                     = 0,
	TargetZoomValue                          = 1,
	CurveFloatProgression                    = 2,
	EManualZoomType_MAX                      = 3,
};

// Enum DeadByDaylight.EDBDCameraSocketID
// NumValues: 0x0007
enum class EDBDCameraSocketID : uint8
{
	VE_None                                  = 0,
	VE_Default                               = 1,
	VE_Killcam                               = 2,
	VE_Reaction                              = 3,
	VE_Struggle                              = 4,
	VE_Sacrifice                             = 5,
	VE_MAX                                   = 6,
};

// Enum DeadByDaylight.EEscapeType
// NumValues: 0x0004
enum class EEscapeType : uint8
{
	Escape_ExitGate                          = 0,
	Escape_Hatch                             = 1,
	Escape_KillerDisconnect                  = 2,
	Escape_MAX                               = 3,
};

// Enum DeadByDaylight.ECDNPatchCompleteStatus
// NumValues: 0x0016
enum class ECDNPatchCompleteStatus : uint8
{
	Success                                  = 0,
	NotEnoughDiskSpace                       = 1,
	PatchInstallDownloadError                = 2,
	PatchInstallFileConstructionFail         = 3,
	PatchInstallMoveFileToInstallFail        = 4,
	PatchInstallBuildVerifyFail              = 5,
	PatchInstallApplicationClosing           = 6,
	PatchInstallApplicationError             = 7,
	PatchInstallUserCanceled                 = 8,
	PatchInstallPrerequisiteError            = 9,
	PatchInstallInitializationError          = 10,
	PatchInstallPathLengthExceeded           = 11,
	PatchInstallOutOfDiskSpace               = 12,
	PatchInstallUnknownError                 = 13,
	FailureToMountContent                    = 14,
	InstalledContentNotFound                 = 15,
	InvalidPendingContent                    = 16,
	CantFindContentToDownload                = 17,
	NoPatchForCurrentPlatformAndVersion      = 18,
	FailureToRetrieveContent                 = 19,
	CancelledByUser                          = 20,
	ECDNPatchCompleteStatus_MAX              = 21,
};

// Enum DeadByDaylight.ECharacterToolItemType
// NumValues: 0x0005
enum class ECharacterToolItemType : uint8
{
	None                                     = 0,
	Outfit                                   = 1,
	OutfitPiece                              = 2,
	Charm                                    = 3,
	ECharacterToolItemType_MAX               = 4,
};

// Enum DeadByDaylight.EChargeableInteractionBarType
// NumValues: 0x0003
enum class EChargeableInteractionBarType : uint8
{
	VE_Normal                                = 0,
	VE_ProgressPips                          = 1,
	VE_MAX                                   = 2,
};

// Enum DeadByDaylight.ECharmCategory
// NumValues: 0x000B
enum class ECharmCategory : uint8
{
	None                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Big                                      = 3,
	Short                                    = 4,
	Wide                                     = 5,
	Chibi                                    = 6,
	Square                                   = 7,
	Tablet                                   = 8,
	Perk                                     = 9,
	ECharmCategory_MAX                       = 10,
};

// Enum DeadByDaylight.EContext
// NumValues: 0x0039
enum class EContext : uint8
{
	None                                     = 0,
	ArchiveIntro                             = 1,
	ArchiveMenu                              = 2,
	ArchivePastStories                       = 3,
	ArchiveRewards                           = 4,
	ArchiveStory                             = 5,
	ArchiveCompendium                        = 6,
	ArchiveRift                              = 7,
	ArchiveTome                              = 8,
	BloodWeb                                 = 9,
	Character                                = 10,
	Consent                                  = 11,
	Credits                                  = 12,
	Customization                            = 13,
	GameFlowOff                              = 14,
	Hud                                      = 15,
	Inbox                                    = 16,
	LightSensitivity                         = 17,
	Loading                                  = 18,
	Loadout                                  = 19,
	Lobby                                    = 20,
	LobbyOff                                 = 21,
	MainMenu                                 = 22,
	Onboarding                               = 23,
	RoleSelection                            = 24,
	SpecialEventLoading                      = 25,
	Spectate                                 = 26,
	Splash                                   = 27,
	Store                                    = 28,
	Tally                                    = 29,
	Tutorial                                 = 30,
	ArchivePassPurchasePopup                 = 31,
	ArchiveTierPurchasePopup                 = 32,
	CrowdChoiceTugOfWarPopup                 = 33,
	DailyRewardsPopup                        = 34,
	EventEntryPopup                          = 35,
	FearMarketPopup                          = 36,
	FriendSearchPopup                        = 37,
	GenericPopup                             = 38,
	GenericTextInputPopup                    = 39,
	NewContentPopup                          = 40,
	ProcessingPopup                          = 41,
	ReportPlayerPopup                        = 42,
	SeasonEndPopup                           = 43,
	SeasonEndRankRewardsPopup                = 44,
	UnlockPersonalPerksPopup                 = 45,
	LoadoutMenuPopup                         = 46,
	UMGArchivePassPurchasePopup              = 47,
	UMGArchiveTierPurchasePopup              = 48,
	UMGDailyRitualsPopup                     = 49,
	UMGEventEntryPopup                       = 50,
	UMGFearMarketPopup                       = 51,
	UMGGenericPopup                          = 52,
	UMGGenericTextInputPopup                 = 53,
	UMGUnlockPersonalPerksPopup              = 54,
	Count                                    = 55,
	EContext_MAX                             = 56,
};

// Enum DeadByDaylight.EItemDomain
// NumValues: 0x0004
enum class EItemDomain : uint8
{
	Store                                    = 0,
	Local                                    = 1,
	Any                                      = 2,
	EItemDomain_MAX                          = 3,
};

// Enum DeadByDaylight.EOwnership
// NumValues: 0x0004
enum class EOwnership : uint8
{
	Owned                                    = 0,
	NotOwned                                 = 1,
	Any                                      = 2,
	EOwnership_MAX                           = 3,
};

// Enum DeadByDaylight.EHudEditorDragAxisOption
// NumValues: 0x0004
enum class EHudEditorDragAxisOption : uint8
{
	PositiveSide                             = 0,
	NegativeSide                             = 1,
	BothSide                                 = 2,
	EHudEditorDragAxisOption_MAX             = 3,
};

// Enum DeadByDaylight.EUMGDailyRewardWidgetState
// NumValues: 0x0009
enum class EUMGDailyRewardWidgetState : uint8
{
	Unknown                                  = 0,
	Locked                                   = 1,
	ReadyToCollect                           = 2,
	NewlyCollected                           = 3,
	Collected                                = 4,
	MysteryLocked                            = 5,
	MysteryReadyToDiscover                   = 6,
	MysteryNewlyDiscovered                   = 7,
	EUMGDailyRewardWidgetState_MAX           = 8,
};

// Enum DeadByDaylight.DBDScalabilityLevel
// NumValues: 0x0006
enum class EDBDScalabilityLevel : uint8
{
	LOW                                      = 0,
	MEDIUM                                   = 1,
	HIGH                                     = 2,
	EPIC                                     = 3,
	ULTRA                                    = 4,
	DBDScalabilityLevel_MAX                  = 5,
};

// Enum DeadByDaylight.EAIDodgeType
// NumValues: 0x0004
enum class EAIDodgeType : uint8
{
	FORWARD_SIDE_STEP                        = 0,
	SIDE_STEP                                = 1,
	BACKWARD_SIDE_STEP                       = 2,
	EAIDodgeType_MAX                         = 3,
};

// Enum DeadByDaylight.EInLockerSkillsContext
// NumValues: 0x0004
enum class EInLockerSkillsContext : uint8
{
	None                                     = 0,
	Goal                                     = 1,
	OutOfTerrorRadius                        = 2,
	EInLockerSkillsContext_MAX               = 3,
};

// Enum DeadByDaylight.EPawnInputPressTypes
// NumValues: 0x0012
enum class EPawnInputPressTypes : uint8
{
	None                                     = 0,
	FastInteract                             = 1,
	Interact                                 = 2,
	Struggle                                 = 3,
	Slash                                    = 4,
	Attack                                   = 5,
	Action                                   = 6,
	SecondaryAction                          = 7,
	UseItem                                  = 8,
	DropItem                                 = 9,
	Gesture01                                = 10,
	Gesture02                                = 11,
	Gesture03                                = 12,
	Gesture04                                = 13,
	Run                                      = 14,
	RunningFastInteraction                   = 15,
	CancelMinigame                           = 16,
	EPawnInputPressTypes_MAX                 = 17,
};

// Enum DeadByDaylight.EAIDifficultyLevel
// NumValues: 0x0009
enum class EAIDifficultyLevel : uint8
{
	VeryEasy                                 = 0,
	Easy                                     = 1,
	Medium                                   = 2,
	Hard                                     = 3,
	Suggested                                = 4,
	Random                                   = 5,
	None                                     = 6,
	Max                                      = 6,
	EAIDifficultyLevel_MAX                   = 7,
};

// Enum DeadByDaylight.ECharacterMovementTypes
// NumValues: 0x0004
enum class ECharacterMovementTypes : uint8
{
	Normal                                   = 0,
	Run                                      = 1,
	Crouch                                   = 2,
	ECharacterMovementTypes_MAX              = 3,
};

// Enum DeadByDaylight.EAITerrorLevel
// NumValues: 0x0008
enum class EAITerrorLevel : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Min                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	VeryHigh                                 = 4,
	Max                                      = 4,
	EAITerrorLevel_MAX                       = 5,
};

// Enum DeadByDaylight.ECamperGuidedAction
// NumValues: 0x0013
enum class ECamperGuidedAction : uint8
{
	VE_None                                  = 0,
	VE_PrepBeingKilled                       = 1,
	VE_BeingKilled                           = 2,
	VE_PrepGuidedAction                      = 3,
	VE_BeingHelpedOffHookFront               = 4,
	VE_BeingHelpedOffHookBack                = 5,
	VE_BeingPickedUp                         = 6,
	VE_BeingPutDown                          = 7,
	VE_BeingCarried                          = 8,
	VE_BeingPutOnHook                        = 9,
	VE_BeingHealed                           = 10,
	VE_BeingPulledFromCloset                 = 11,
	VE_BeingHelpedFromTrap                   = 12,
	VE_AttachReverseBearTrap                 = 13,
	VE_BeingMended                           = 14,
	VE_BeingInjectedWithSerum                = 15,
	VE_CarriedByK29Rush                      = 16,
	VE_BeingCleansedOfK29Infection           = 17,
	VE_MAX                                   = 18,
};

// Enum DeadByDaylight.ECustomMovementMode
// NumValues: 0x0003
enum class ECustomMovementMode : uint8
{
	CUSTOM_MOVE_None                         = 0,
	CUSTOM_MOVE_Snapping                     = 1,
	CUSTOM_MOVE_MAX                          = 2,
};

// Enum DeadByDaylight.EDangerTraverseState
// NumValues: 0x0006
enum class EDangerTraverseState : uint8
{
	SAFE                                     = 0,
	WAIT                                     = 1,
	TRAVERSE_CROUCH                          = 2,
	TRAVERSE_RUN                             = 3,
	UNDODGEABLE                              = 4,
	EDangerTraverseState_MAX                 = 5,
};

// Enum DeadByDaylight.EDiceRollType
// NumValues: 0x0007
enum class EDiceRollType : uint8
{
	VE_EscapeHook                            = 0,
	VE_EscapeTrap                            = 1,
	VE_TrapInflictsDying                     = 2,
	VE_TriggerSkillCheck                     = 3,
	VE_TriggerFootNoise                      = 4,
	VE_TriggerCrowAlert                      = 5,
	VE_MAX                                   = 6,
};

// Enum DeadByDaylight.EEmblemProgressionType
// NumValues: 0x002A
enum class EEmblemProgressionType : uint8
{
	SurvivorLightbringerStartingValue        = 0,
	SurvivorLightbringerGeneratorRepair      = 1,
	SurvivorLightbringerTotemCleanse         = 2,
	SurvivorLightbringerKillerDiversion      = 3,
	SurvivorLightbringerExitGameOpen         = 4,
	SurvivorUnbrokenTimeAlive                = 5,
	SurvivorBenevolentStartingValue          = 6,
	SurvivorBenevolentHealing                = 7,
	SurvivorBenevolentHooked                 = 8,
	SurvivorBenevolentUnhook                 = 9,
	SurvivorBenevolentPerformUnhook          = 10,
	SurvivorBenevolentSaveFromKiller         = 11,
	SurvivorBenevolentUnsafeUnhook           = 12,
	SurvivorBenevolentHitWhileCarrying       = 13,
	SurvivorEvaderStartingValue              = 14,
	SurvivorEvaderSneaking                   = 15,
	SurvivorEvaderChaseWon                   = 16,
	SurvivorEvaderChaseLost                  = 17,
	SurvivorEvaderPalletStun                 = 18,
	KillerGatekeeperStartingValue            = 19,
	KillerGatekeeperGeneratorDefense         = 20,
	KillerGatekeeperGatesClosed              = 21,
	KillerDevoutStartingValue                = 22,
	KillerDevoutSacrifice                    = 23,
	KillerDevoutDisconnect                   = 24,
	KillerDevoutMoris                        = 25,
	KillerDevoutAllSurvivorsHooked           = 26,
	KillerDevoutHooksBonus                   = 27,
	KillerMaliciousStartingValue             = 28,
	KillerMaliciousInjuries                  = 29,
	KillerMaliciousHookStages                = 30,
	KillerMaliciousInjuriesHealed            = 31,
	KillerMaliciousEscapeGrasp               = 32,
	KillerMaliciousDisconnect                = 33,
	KillerChaserStartingValue                = 34,
	KillerChaserSurvivorFound                = 35,
	KillerChaserSurvivorLost                 = 36,
	KillerChaserHit                          = 37,
	KillerChaserChaseWon                     = 38,
	KillerChaserProximityToHookPenalty       = 39,
	Invalid                                  = 40,
	EEmblemProgressionType_MAX               = 41,
};

// Enum DeadByDaylight.EEmblemEvaluation
// NumValues: 0x0003
enum class EEmblemEvaluation : uint8
{
	Authority                                = 0,
	Local                                    = 1,
	EEmblemEvaluation_MAX                    = 2,
};

// Enum DeadByDaylight.EErrorCodes
// NumValues: 0x002C
enum class EErrorCodes : uint16
{
	None                                     = 0,
	SavefileDeserializationFailure           = 100,
	SavefileDecryptionFailure                = 101,
	SavefileEmpty                            = 102,
	SavefileBadPlayerId                      = 103,
	SavefileEmptyPlayerUID                   = 104,
	SavefileInvalidUniqueNetID               = 105,
	SavefileInvalidPlayerState               = 106,
	SavefileBackendError                     = 107,
	KrakenRankError                          = 108,
	KrakenRatingsError                       = 109,
	SavefileKrakenPlayerForbidden            = 110,
	SyncCachedCurrencyError                  = 111,
	CurrencyTransactionError                 = 112,
	StateDownloadFailed                      = 113,
	StatcacheDecryptionFailed                = 114,
	SavefilePlayerLoadUIDMismatch            = 115,
	SavefilePlayerStateUIDMismatch           = 116,
	CharacterMigrationGetError               = 130,
	CharacterMigrationGetError_BadProfile    = 131,
	SavefileEncryptionFailure                = 200,
	SaveFailedInvalidData                    = 201,
	SaveFailedInvalidJSON                    = 202,
	SaveFailedDecodeDataString               = 203,
	SaveFailedCompressDataString             = 204,
	SaveFailedEncryptString                  = 205,
	StatcacheEncryptionFailed                = 206,
	SaveFailedCloudErrorTimeout              = 300,
	JsonToPersistenDataFailed                = 301,
	SaveFailedCloudErrorAfterRetries         = 302,
	StateUploadFailed                        = 303,
	GetPlayerLevelRequestError               = 400,
	EarnPlayerXpRequestError                 = 401,
	EarnPlayerXpParamError                   = 402,
	EndOfMatchError                          = 403,
	OnboardingFailGet                        = 410,
	OnboardingFailUpdate                     = 411,
	OnboardingFailRequest                    = 412,
	MatchCancelledPlayerLeftDuringLoading    = 500,
	MatchCancelledInvalidPlayerRoles         = 501,
	MatchCancelledLoadingTimeout             = 502,
	PakValidationFailed                      = 600,
	KrakenSdkMismatch                        = 601,
	EErrorCodes_MAX                          = 602,
};

// Enum DeadByDaylight.EGameIntroSteps
// NumValues: 0x0004
enum class EGameIntroSteps : uint8
{
	Idling                                   = 0,
	PlayingIntro                             = 1,
	LoopingCamView                           = 2,
	EGameIntroSteps_MAX                      = 3,
};

// Enum DeadByDaylight.EDisconnectErrors
// NumValues: 0x0017
enum class EDisconnectErrors : uint8
{
	None                                     = 0,
	SteamAuthFailure                         = 1,
	SteamAuthFailureKickedFromServer         = 2,
	EACServerValidationFailure               = 3,
	EACValidationFailureKickedFromServer     = 4,
	EACClientNotRunning                      = 5,
	EACClientIntegrityViolation              = 6,
	PlayerRemovedOnSuspend                   = 7,
	LostConnectionToHost                     = 8,
	LostConnectionToProfileService           = 9,
	MirrorsUnscheduledSessionDestruction     = 10,
	SessionKilledByMirrors                   = 11,
	UnableToSaveProfileAfterRetries          = 12,
	UnableToGetPlayerLevel                   = 13,
	UnableToEarnPlayerXp                     = 14,
	UnableToUpdatePips                       = 15,
	UnableToUpdateRatings                    = 16,
	ClientProviderAuthenticationFailed       = 17,
	UnableToSyncCachedCurrency               = 18,
	OwnershipValidationFailure               = 19,
	UnableToUpdateEndOfMatchInfo             = 20,
	TravelFailure                            = 21,
	EDisconnectErrors_MAX                    = 22,
};

// Enum DeadByDaylight.ELevelLoadingSteps
// NumValues: 0x000F
enum class ELevelLoadingSteps : uint8
{
	Invalid                                  = 0,
	WaitingForProceduralLevelBuilder         = 1,
	WaitingForPlayersToBeSpawned             = 2,
	WaitingForAIPawnToBeSpawned              = 3,
	WaitingForAssetPreloader                 = 4,
	WaitingForLoadoutAndTheme                = 5,
	WaitingForPIAToBeSpawnedAndInitialized   = 6,
	WaitingForNavmeshComputationToStart      = 7,
	WaitingForNavmeshComputationToFinish     = 8,
	SetGameLoadedAndReadyToPlay              = 9,
	WaitingForIntroToBeDone                  = 10,
	LoadingCompleted                         = 11,
	FirstLoadingStep                         = 1,
	Count                                    = 11,
	ELevelLoadingSteps_MAX                   = 12,
};

// Enum DeadByDaylight.ELoadProgress
// NumValues: 0x003D
enum class ELoadProgress : uint8
{
	NotStarted                               = 0,
	Init                                     = 1,
	SetupPIE                                 = 2,
	ArtificialDelay                          = 3,
	DisconnectingPresencePlugin              = 4,
	ValidateOnlineSubsystem                  = 5,
	CheckingPlatformService                  = 6,
	PreMirrorsLogin                          = 7,
	ConnectingToMirrors                      = 8,
	StartEAC                                 = 9,
	LoadingAuthInfo                          = 10,
	LoadingBackendConfigs                    = 11,
	SetupRichPresence                        = 12,
	LoadingBackendTunables                   = 13,
	ApplyingCDNPatch                         = 14,
	AquiringExternalAuthentication           = 15,
	LoadingPlayerIndependentShopData         = 16,
	LicenseCache                             = 17,
	LoadingEvents                            = 18,
	LoadingInventory                         = 19,
	LoadingCinematics                        = 20,
	SyncingOwnedCharacters                   = 21,
	LoadingProfile                           = 22,
	LoadingMirrorCurrencies                  = 23,
	LoadingWallet                            = 24,
	LoadingConsent                           = 25,
	LoadingGameConfigs                       = 26,
	LoadingCharacterXPTables                 = 27,
	CheckingPendingTransactions              = 28,
	LoadingContentSchedule                   = 29,
	LoadingNews                              = 30,
	SendingAnalytics                         = 31,
	LoadingDailyRituals                      = 32,
	CalculatingLatencies                     = 33,
	ValidateData                             = 34,
	ValidatingClientVersion                  = 35,
	CheckingNeedForCurrencyMigration         = 36,
	MigratingCurrenciesToMirror              = 37,
	SyncingFriendsList                       = 38,
	Complete                                 = 39,
	Locating                                 = 40,
	InitializingRTMConnection                = 41,
	LoadingStreamVideoData                   = 42,
	CollectingFreeCatalogItems               = 43,
	DownloadDynamicContent                   = 44,
	CheckingMobilePendingTransactions        = 45,
	LoadMarketingBanners                     = 46,
	LoadingSubscriptionStatus                = 47,
	RequestingTrackingAuthorization          = 48,
	LoadingExperimentalFeatures              = 49,
	LoadingMatchIncentives                   = 50,
	LoadingLoadoutPresets                    = 51,
	LoadingBackendCharacterData              = 52,
	LoadingPrestige                          = 53,
	UpdatingOwnedContent                     = 54,
	LoadingShrine                            = 55,
	LoadingReportFeedback                    = 56,
	LoadingGameConfigsDS                     = 57,
	LoadingCatalog                           = 58,
	LoadingS3PrestigeData                    = 59,
	ELoadProgress_MAX                        = 60,
};

// Enum DeadByDaylight.EProceduralDebugMode
// NumValues: 0x0006
enum class EProceduralDebugMode : uint8
{
	None                                     = 0,
	NoMap                                    = 1,
	TilesSmall                               = 2,
	TilesBig                                 = 3,
	Count                                    = 4,
	EProceduralDebugMode_MAX                 = 5,
};

// Enum DeadByDaylight.EAIEvadeLoopSides
// NumValues: 0x0004
enum class EAIEvadeLoopSides : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Count                                    = 2,
	EAIEvadeLoopSides_MAX                    = 3,
};

// Enum DeadByDaylight.EAuthoritativeMovementFlag
// NumValues: 0x000A
enum class EAuthoritativeMovementFlag : uint8
{
	INTERACTION                              = 0,
	SLASHED                                  = 1,
	CHEAT                                    = 2,
	DROPPED                                  = 3,
	NOPUSH                                   = 4,
	INTERACTIONNOPUSH                        = 5,
	DREAMWORLD_NOSLASHERCOLLISION            = 6,
	NOPUSHFORCED                             = 7,
	COUNT                                    = 8,
	EAuthoritativeMovementFlag_MAX           = 9,
};

// Enum DeadByDaylight.EPlayerMovementDirection
// NumValues: 0x0005
enum class EPlayerMovementDirection : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Forward                                  = 2,
	Backward                                 = 3,
	EPlayerMovementDirection_MAX             = 4,
};

// Enum DeadByDaylight.ECharacterStance
// NumValues: 0x0004
enum class ECharacterStance : uint8
{
	VE_Stand                                 = 0,
	VE_Crouch                                = 1,
	VE_Crawl                                 = 2,
	VE_MAX                                   = 3,
};

// Enum DeadByDaylight.EPlayerGameplayEventType
// NumValues: 0x0004
enum class EPlayerGameplayEventType : uint8
{
	VE_UnhookedOther                         = 0,
	VE_UntrappedOther                        = 1,
	VE_HealedOther                           = 2,
	VE_MAX                                   = 3,
};

// Enum DeadByDaylight.EVisibleMenuActorType
// NumValues: 0x0005
enum class EVisibleMenuActorType : uint8
{
	None                                     = 0,
	Pawn                                     = 1,
	Hook                                     = 2,
	Charm                                    = 3,
	EVisibleMenuActorType_MAX                = 4,
};

// Enum DeadByDaylight.EKillerImmobilizedState
// NumValues: 0x0003
enum class EKillerImmobilizedState : uint8
{
	VE_None                                  = 0,
	VE_HidingInLocker                        = 1,
	VE_MAX                                   = 2,
};

// Enum DeadByDaylight.EToastInputType
// NumValues: 0x0004
enum class EToastInputType : uint8
{
	Toast_Accept                             = 0,
	Toast_Reject                             = 1,
	Toast_Close                              = 2,
	Toast_MAX                                = 3,
};

// Enum DeadByDaylight.EShadowSystem
// NumValues: 0x0003
enum class EShadowSystem : uint8
{
	CascadedShadowMap                        = 0,
	AdaptiveShadowMap                        = 1,
	EShadowSystem_MAX                        = 2,
};

// Enum DeadByDaylight.EDisplayStandActorType
// NumValues: 0x0005
enum class EDisplayStandActorType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Hook                                     = 2,
	Charm                                    = 3,
	EDisplayStandActorType_MAX               = 4,
};

// Enum DeadByDaylight.EDoctorAbilityPhase
// NumValues: 0x0004
enum class EDoctorAbilityPhase : uint8
{
	VE_Charging                              = 0,
	VE_Firing                                = 1,
	VE_None                                  = 2,
	VE_MAX                                   = 3,
};

// Enum DeadByDaylight.EDoctorAbilityType
// NumValues: 0x0004
enum class EDoctorAbilityType : uint8
{
	VE_ShockTherapy                          = 0,
	VE_StaticBlast                           = 1,
	VE_None                                  = 2,
	VE_MAX                                   = 3,
};

// Enum DeadByDaylight.EEndGameScenarioTrigger
// NumValues: 0x0005
enum class EEndGameScenarioTrigger : uint8
{
	ClosedHatch                              = 0,
	OpenedGate                               = 1,
	CheatUsed                                = 2,
	NotActivated                             = 3,
	EEndGameScenarioTrigger_MAX              = 4,
};

// Enum DeadByDaylight.EEnergyTypeEnum
// NumValues: 0x0004
enum class EEnergyTypeEnum : uint8
{
	EInvalid                                 = 0,
	EBattery                                 = 1,
	EHealth                                  = 2,
	EEnergyTypeEnum_MAX                      = 3,
};

// Enum DeadByDaylight.EErrorEventType
// NumValues: 0x0008
enum class EErrorEventType : uint8
{
	FailedToCalculateRankProgress            = 0,
	FailedToEarnPlayerXp                     = 1,
	FailedToGrandBloodPoints                 = 2,
	FailedToSyncWalletChanges                = 3,
	InvalidLobbyId                           = 4,
	InvalidGameState                         = 5,
	InvalidSessionId                         = 6,
	EErrorEventType_MAX                      = 7,
};

// Enum DeadByDaylight.EEscapeDoorActivationMode
// NumValues: 0x0003
enum class EEscapeDoorActivationMode : uint8
{
	Standard                                 = 0,
	Tutorial                                 = 1,
	EEscapeDoorActivationMode_MAX            = 2,
};

// Enum DeadByDaylight.EConditionSubject
// NumValues: 0x0003
enum class EConditionSubject : uint8
{
	Instigator                               = 0,
	Target                                   = 1,
	EConditionSubject_MAX                    = 2,
};

// Enum DeadByDaylight.EEventItemContentType
// NumValues: 0x000C
enum class EEventItemContentType : uint8
{
	None                                     = 0,
	Cells                                    = 1,
	Character                                = 2,
	Customization                            = 3,
	NameChangeCard                           = 4,
	FreeTicket                               = 5,
	OtherCurrency                            = 6,
	Item                                     = 7,
	Addon                                    = 8,
	Offering                                 = 9,
	Count                                    = 10,
	EEventItemContentType_MAX                = 11,
};

// Enum DeadByDaylight.EFeaturedStoreContentType
// NumValues: 0x0006
enum class EFeaturedStoreContentType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Customization                            = 2,
	Outfit                                   = 3,
	Count                                    = 4,
	EFeaturedStoreContentType_MAX            = 5,
};

// Enum DeadByDaylight.ELoadoutType
// NumValues: 0x0004
enum class ELoadoutType : uint8
{
	Item                                     = 0,
	Perk                                     = 1,
	Offering                                 = 2,
	ELoadoutType_MAX                         = 3,
};

// Enum DeadByDaylight.FlickeringLightType
// NumValues: 0x0004
enum class EFlickeringLightType : uint32
{
	Point                                    = 0,
	Rect                                     = 1,
	Spot                                     = 2,
	FlickeringLightType_MAX                  = 3,
};

// Enum DeadByDaylight.EFriendUIRichPresence
// NumValues: 0x0007
enum class EFriendUIRichPresence : uint8
{
	Undefined                                = 0,
	InMenus                                  = 1,
	InLobby                                  = 2,
	InMatch                                  = 3,
	Connected                                = 4,
	Closing                                  = 5,
	EFriendUIRichPresence_MAX                = 6,
};

// Enum DeadByDaylight.EFriendUIStatus
// NumValues: 0x0008
enum class EFriendUIStatus : uint8
{
	Offline                                  = 0,
	Online                                   = 1,
	PlayingDBD                               = 2,
	PendingSentRequest                       = 3,
	PendingReceivedRequest                   = 4,
	NotFriend                                = 5,
	Self                                     = 6,
	EFriendUIStatus_MAX                      = 7,
};

// Enum DeadByDaylight.EFlowTransitionType
// NumValues: 0x0008
enum class EFlowTransitionType : uint8
{
	Tally                                    = 0,
	OnlineLobby                              = 1,
	PartyLobby                               = 2,
	OfflineLobby                             = 3,
	Splash                                   = 4,
	RoleSelection                            = 5,
	None                                     = 6,
	EFlowTransitionType_MAX                  = 7,
};

// Enum DeadByDaylight.EUIFlowEvent
// NumValues: 0x000D
enum class EUIFlowEvent : uint8
{
	None                                     = 0,
	AtlantaRoleSelectionScreenReady          = 1,
	AtlantaNavigationScreenReady             = 2,
	InGameHudReady                           = 3,
	LoadingScreenReady                       = 4,
	OfflineLobbyScreenReady                  = 5,
	OnlineLobbyScreenReady                   = 6,
	RoleSelectionScreenReady                 = 7,
	SplashScreenReady                        = 8,
	TallyScreenReady                         = 9,
	PartyLobbyScreenReady                    = 10,
	StoreScreenReady                         = 11,
	EUIFlowEvent_MAX                         = 12,
};

// Enum DeadByDaylight.EWorldFlowEvent
// NumValues: 0x000B
enum class EWorldFlowEvent : uint8
{
	None                                     = 0,
	GameLevelLoaded                          = 1,
	LoadingGameLevel                         = 2,
	LoadingOfflineParadise                   = 3,
	LoadingOnlineLobbyLevel                  = 4,
	OfflineLobbyMapLoaded                    = 5,
	OfflineParadiseLoaded                    = 6,
	OnlineLobbyMapLoaded                     = 7,
	StartScreenMapLoaded                     = 8,
	LoadingSplashScreen                      = 9,
	EWorldFlowEvent_MAX                      = 10,
};

// Enum DeadByDaylight.EGameFlowStep
// NumValues: 0x000A
enum class EGameFlowStep : uint8
{
	None                                     = 0,
	InGame                                   = 1,
	OfflineLobby                             = 2,
	OfflineTally                             = 3,
	OnlineLobby                              = 4,
	SplashScreen                             = 5,
	PartyLobby                               = 6,
	Store                                    = 7,
	RoleSelection                            = 8,
	EGameFlowStep_MAX                        = 9,
};

// Enum DeadByDaylight.EGameplayModifierSource
// NumValues: 0x0008
enum class EGameplayModifierSource : uint8
{
	VE_Perk                                  = 0,
	VE_StatusEffect                          = 1,
	VE_Item                                  = 2,
	VE_ItemAddon                             = 3,
	VE_All                                   = 4,
	VE_PerkOrStatusEffect                    = 5,
	VE_PerkStatusOrAddon                     = 6,
	VE_MAX                                   = 7,
};

// Enum DeadByDaylight.EGateType
// NumValues: 0x0003
enum class EGateType : uint8
{
	VE_AndGate                               = 0,
	VE_TimerGate                             = 1,
	VE_MAX                                   = 2,
};

// Enum DeadByDaylight.ETrapRemovedReason
// NumValues: 0x0006
enum class ETrapRemovedReason : uint8
{
	KillerInteraction                        = 0,
	LifetimeExpired                          = 1,
	EndPlay                                  = 2,
	GeneratorRepaired                        = 3,
	OwnerLeft                                = 4,
	ETrapRemovedReason_MAX                   = 5,
};

// Enum DeadByDaylight.EGestureID
// NumValues: 0x0003
enum class EGestureID : uint8
{
	POINT                                    = 0,
	COME                                     = 1,
	EGestureID_MAX                           = 2,
};

// Enum DeadByDaylight.EHatchState
// NumValues: 0x0005
enum class EHatchState : uint8
{
	Hidden                                   = 0,
	DefaultClose                             = 1,
	Opened                                   = 2,
	ForcedClose                              = 3,
	EHatchState_MAX                          = 4,
};

// Enum DeadByDaylight.EHintCategory
// NumValues: 0x0004
enum class EHintCategory : uint8
{
	Lore                                     = 0,
	Survivor                                 = 1,
	Killer                                   = 2,
	EHintCategory_MAX                        = 3,
};

// Enum DeadByDaylight.EHookType
// NumValues: 0x0004
enum class EHookType : uint8
{
	Hook                                     = 0,
	DeathBed                                 = 1,
	None                                     = 2,
	EHookType_MAX                            = 3,
};

// Enum DeadByDaylight.EProgressModifier
// NumValues: 0x0004
enum class EProgressModifier : uint8
{
	Default                                  = 0,
	Buff                                     = 1,
	Debuff                                   = 2,
	EProgressModifier_MAX                    = 3,
};

// Enum DeadByDaylight.EKeyBindingsType
// NumValues: 0x0026
enum class EKeyBindingsType : uint64
{
	None                                     = 18446744073709551615,
	Run                                      = 0,
	Crouch                                   = 1,
	UseItem                                  = 2,
	DropItemSurvivor                         = 3,
	PickUpItem                               = 4,
	ActionSurvivor                           = 5,
	SecondaryActionSurvivor                  = 6,
	AbilitySurvivor                          = 7,
	AbilityTwoSurvivor                       = 8,
	Gesture1                                 = 9,
	Gesture2                                 = 10,
	WiggleRightSkillCheck                    = 11,
	WiggleLeftSkillCheck                     = 12,
	Attack                                   = 13,
	Power                                    = 14,
	SecondaryPower                           = 15,
	DropSurvivor                             = 16,
	PickUp                                   = 17,
	Aim                                      = 18,
	ForwardSurvivor                          = 19,
	BackSurvivor                             = 20,
	LeftSurvivor                             = 21,
	RightSurvivor                            = 22,
	CameraUpSurvivor                         = 23,
	CameraDownSurvivor                       = 24,
	CameraLeftSurvivor                       = 25,
	CameraRightSurvivor                      = 26,
	ForwardKiller                            = 27,
	BackKiller                               = 28,
	LeftKiller                               = 29,
	RightKiller                              = 30,
	AimKiller                                = 31,
	CameraUpKiller                           = 32,
	CameraDownKiller                         = 33,
	CameraLeftKiller                         = 34,
	CameraRightKiller                        = 35,
	EKeyBindingsType_MAX                     = 36,
};

// Enum DeadByDaylight.EKeyBindingsCategories
// NumValues: 0x0006
enum class EKeyBindingsCategories : uint64
{
	None                                     = 18446744073709551615,
	Movement                                 = 0,
	Interactions                             = 1,
	Camera                                   = 2,
	Gestures                                 = 3,
	EKeyBindingsCategories_MAX               = 4,
};

// Enum DeadByDaylight.EKillerTutorialEndGameType
// NumValues: 0x0003
enum class EKillerTutorialEndGameType : uint8
{
	DeathByHook                              = 0,
	DeathByEndGameCollapse                   = 1,
	EKillerTutorialEndGameType_MAX           = 2,
};

// Enum DeadByDaylight.EKillerHeight
// NumValues: 0x0004
enum class EKillerHeight : uint8
{
	Short                                    = 0,
	Average                                  = 1,
	Tall                                     = 2,
	EKillerHeight_MAX                        = 3,
};

// Enum DeadByDaylight.EFPVTransitionStrategy
// NumValues: 0x0003
enum class EFPVTransitionStrategy : uint8
{
	TurnInvisible                            = 0,
	SquishTorsoBackward                      = 1,
	EFPVTransitionStrategy_MAX               = 2,
};

// Enum DeadByDaylight.EPlayerDataType
// NumValues: 0x0005
enum class EPlayerDataType : uint8
{
	None                                     = 0,
	PlayerState                              = 1,
	SocialPartyMember                        = 2,
	BotPartyMember                           = 3,
	EPlayerDataType_MAX                      = 4,
};

// Enum DeadByDaylight.ELobbyWaitStopReason
// NumValues: 0x0004
enum class ELobbyWaitStopReason : uint8
{
	StartMatchWait                           = 0,
	PlayerCancelled                          = 1,
	Unknown                                  = 2,
	ELobbyWaitStopReason_MAX                 = 3,
};

// Enum DeadByDaylight.EMainMenuButton
// NumValues: 0x0010
enum class EMainMenuButton : uint8
{
	News                                     = 0,
	PlaySurvivor                             = 1,
	PlayKiller                               = 2,
	KillYourFriends                          = 3,
	DailyRituals                             = 4,
	Store                                    = 5,
	Settings                                 = 6,
	Onboarding                               = 7,
	Credits                                  = 8,
	QuitGame                                 = 9,
	Friends                                  = 10,
	Archives                                 = 11,
	CrowdChoice                              = 12,
	PlaySurvivorFromCrowdChoice              = 13,
	PlayKillerFromCrowdChoice                = 14,
	EMainMenuButton_MAX                      = 15,
};

// Enum DeadByDaylight.EMapActorCategory
// NumValues: 0x0007
enum class EMapActorCategory : uint8
{
	None                                     = 0,
	Objective                                = 1,
	Chest                                    = 2,
	BlackLock                                = 3,
	KillerObject                             = 4,
	ExitGate                                 = 5,
	EMapActorCategory_MAX                    = 6,
};

// Enum DeadByDaylight.EQuadDirection
// NumValues: 0x0007
enum class EQuadDirection : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	Empty                                    = 5,
	EQuadDirection_MAX                       = 6,
};

// Enum DeadByDaylight.ETileVariation
// NumValues: 0x0007
enum class ETileVariation : uint8
{
	None                                     = 0,
	BlueTag                                  = 1,
	PinkTag                                  = 2,
	YellowTag                                = 3,
	GreenTag                                 = 4,
	Empty                                    = 5,
	ETileVariation_MAX                       = 6,
};

// Enum DeadByDaylight.EPathType
// NumValues: 0x000A
enum class EPathType : uint8
{
	None                                     = 0,
	Straight                                 = 1,
	DeadEnd                                  = 2,
	Corner                                   = 3,
	Crossroads                               = 4,
	TJunction                                = 5,
	OrientationOnly                          = 6,
	Unspecified                              = 7,
	OrientedCrossroads                       = 8,
	EPathType_MAX                            = 9,
};

// Enum DeadByDaylight.EDensity
// NumValues: 0x0006
enum class EDensity : uint8
{
	Unspecified                              = 0,
	Light                                    = 1,
	Moderate                                 = 2,
	Heavy                                    = 3,
	Empty                                    = 4,
	EDensity_MAX                             = 5,
};

// Enum DeadByDaylight.ETileType
// NumValues: 0x0009
enum class ETileType : uint8
{
	None                                     = 0,
	Blocker                                  = 1,
	Any                                      = 2,
	Forest                                   = 3,
	Building                                 = 4,
	Maze                                     = 5,
	Landmark                                 = 6,
	Signature                                = 7,
	ETileType_MAX                            = 8,
};

// Enum DeadByDaylight.EDirection
// NumValues: 0x0009
enum class EDirection : uint8
{
	Up                                       = 0,
	Down                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	UpLeft                                   = 4,
	UpRight                                  = 5,
	DownLeft                                 = 6,
	DownRight                                = 7,
	EDirection_MAX                           = 8,
};

// Enum DeadByDaylight.EBasementType
// NumValues: 0x0006
enum class EBasementType : uint8
{
	None                                     = 0,
	Basic                                    = 1,
	MainBuilding                             = 2,
	Shack                                    = 3,
	Count                                    = 4,
	EBasementType_MAX                        = 5,
};

// Enum DeadByDaylight.EQuadrantSpawnType
// NumValues: 0x0007
enum class EQuadrantSpawnType : uint8
{
	L_Shape                                  = 0,
	Square                                   = 1,
	Rect_X                                   = 2,
	Rect_Y                                   = 3,
	Rect                                     = 4,
	None                                     = 5,
	EQuadrantSpawnType_MAX                   = 6,
};

// Enum DeadByDaylight.EQuadrant
// NumValues: 0x0006
enum class EQuadrant : uint8
{
	BottomRight                              = 0,
	BottomLeft                               = 1,
	TopLeft                                  = 2,
	TopRight                                 = 3,
	Count                                    = 4,
	EQuadrant_MAX                            = 5,
};

// Enum DeadByDaylight.EQueueingState
// NumValues: 0x0007
enum class EQueueingState : uint8
{
	None                                     = 0,
	Queueing                                 = 1,
	MatchCreated                             = 2,
	MatchOpened                              = 3,
	WaitingForTransactions                   = 4,
	Complete                                 = 5,
	EQueueingState_MAX                       = 6,
};

// Enum DeadByDaylight.EPlayerAnimState
// NumValues: 0x0005
enum class EPlayerAnimState : uint8
{
	VE_Default                               = 0,
	VE_Injured                               = 1,
	VE_InjuredCrouch                         = 2,
	VE_Crouch                                = 3,
	VE_MAX                                   = 4,
};

// Enum DeadByDaylight.EOfferingEffectType
// NumValues: 0x0039
enum class EOfferingEffectType : uint8
{
	SlasherPointsAll                         = 0,
	PointsBrutality                          = 1,
	PointsDeviouness                         = 2,
	PointsSacrice                            = 3,
	PointsHunting                            = 4,
	CamperPointsAll                          = 5,
	PointsObjective                          = 6,
	PointsSurvival                           = 7,
	PointsAltruism                           = 8,
	PointsBoldness                           = 9,
	SurvivorCharacterXP                      = 10,
	KillerCharacterXP                        = 11,
	CamperItemLostPrevention                 = 12,
	KillerItemLostPrevention                 = 13,
	Luck                                     = 14,
	IndustrialThemeSelectionModifier         = 15,
	JunkyardThemeSelectionModifier           = 16,
	FarmThemeSelectionModifier               = 17,
	SwampThemeSelectionModifier              = 18,
	MapModifier                              = 19,
	ChestCountModifier                       = 20,
	PortableHookCountModifier                = 21,
	LairCountModifier                        = 22,
	PlayerGrouping                           = 23,
	FarKiller                                = 24,
	KillAllowedModifier                      = 25,
	LightingModification                     = 26,
	FogModification                          = 27,
	LivingWorldObjectCountModifier           = 28,
	LivingWorldObjectMultModifier            = 29,
	KillLastSurvivor                         = 30,
	SuburbsThemeSelectionModifier            = 31,
	AsylumThemeSelectionModifier             = 32,
	KillerSelectionModifier                  = 33,
	HospitalThemeSelectionModifier           = 34,
	KillAllowedAfterStrugglePhase            = 35,
	BorealThemeSelectionModifier             = 36,
	SpringwoodThemeSelectionModifier         = 37,
	FinlandThemeSelectionModifier            = 38,
	JapaneseCountrySideSelectionModifier     = 39,
	KenyaThemeSelectionModifier              = 40,
	QatarThemeSelectionModifier              = 41,
	UkraineThemeSelectionModifier            = 42,
	WalesThemeSelectionModifier              = 43,
	CancelThemeSelectionModifier             = 44,
	BasementMainBuildingModifier             = 45,
	BasementShackModifier                    = 46,
	HatchMainBuildingModifier                = 47,
	HatchShackModifier                       = 48,
	EclipseThemeSelectionModifier            = 49,
	IonThemeSelectionModifier                = 50,
	MeteorThemeSelectionModifier             = 51,
	QuantumThemeSelectionModifier            = 52,
	SpecialEvent                             = 53,
	ObjectSubsitution                        = 54,
	ObjectAddition                           = 55,
	EOfferingEffectType_MAX                  = 56,
};

// Enum DeadByDaylight.EOfferingType
// NumValues: 0x0013
enum class EOfferingType : uint8
{
	None                                     = 0,
	Atmosphere                               = 1,
	Lighting                                 = 2,
	Points                                   = 3,
	Zone                                     = 4,
	Position                                 = 5,
	Chest                                    = 6,
	Hook                                     = 7,
	Protection                               = 8,
	Hatch                                    = 9,
	Odds                                     = 10,
	Killing                                  = 11,
	World                                    = 12,
	Luck                                     = 13,
	Killer                                   = 14,
	ProceduralGeneration                     = 15,
	CharacterXP                              = 16,
	Count                                    = 17,
	EOfferingType_MAX                        = 18,
};

// Enum DeadByDaylight.EOfferingCombinationResult
// NumValues: 0x0006
enum class EOfferingCombinationResult : uint8
{
	None                                     = 0,
	Stacked                                  = 1,
	CoConsummed                              = 2,
	Overruling                               = 3,
	Cancelled                                = 4,
	EOfferingCombinationResult_MAX           = 5,
};

// Enum DeadByDaylight.EOfferingSequenceState
// NumValues: 0x000D
enum class EOfferingSequenceState : uint8
{
	SmokeIn                                  = 0,
	FadeOut                                  = 1,
	FadeIn                                   = 2,
	NotInitialized                           = 3,
	Idle                                     = 4,
	Init                                     = 5,
	InitDone                                 = 6,
	Reveal                                   = 7,
	RevealDone                               = 8,
	ShowInteraction                          = 9,
	Finalize                                 = 10,
	Done                                     = 11,
	EOfferingSequenceState_MAX               = 12,
};

// Enum DeadByDaylight.EOfflineLobbyState
// NumValues: 0x0007
enum class EOfflineLobbyState : uint8
{
	None                                     = 0,
	RoleSelection                            = 1,
	OfflineLobby                             = 2,
	Store                                    = 3,
	PartyLobby                               = 4,
	Archives                                 = 5,
	EOfflineLobbyState_MAX                   = 6,
};

// Enum DeadByDaylight.EOniAttackType
// NumValues: 0x0005
enum class EOniAttackType : uint8
{
	VE_NotDemonMode                          = 0,
	VE_DemonBasicAttack                      = 1,
	VE_DemonPowerAttack                      = 2,
	VE_DemonDashAttack                       = 3,
	VE_MAX                                   = 4,
};

// Enum DeadByDaylight.EJoinSessionFailureType
// NumValues: 0x000A
enum class EJoinSessionFailureType : uint8
{
	None                                     = 0,
	JoiningAlreadyStartedGame                = 1,
	JoiningPrivateGame                       = 2,
	JoiningAlreadyFullGame                   = 3,
	JoiningInvitation                        = 4,
	JoiningFailedOnDisconnect                = 5,
	JoiningHostUnreachable                   = 6,
	JoiningIncompatibleServer                = 7,
	MatchmakingInfoExpired                   = 8,
	EJoinSessionFailureType_MAX              = 9,
};

// Enum DeadByDaylight.EOnlineOperation
// NumValues: 0x000A
enum class EOnlineOperation : uint8
{
	None                                     = 0,
	HostGame                                 = 1,
	EndingSession                            = 2,
	DestroyingSession                        = 3,
	PreparingJoinGame                        = 4,
	JoinGame                                 = 5,
	JoinCancelled                            = 6,
	OnlineCheck                              = 7,
	CancellingMatchmaking                    = 8,
	EOnlineOperation_MAX                     = 9,
};

// Enum DeadByDaylight.EOverlayMode
// NumValues: 0x0005
enum class EOverlayMode : uint8
{
	Default                                  = 0,
	TrialOrTally                             = 1,
	TutorialLevel                            = 2,
	TutorialBotMatch                         = 3,
	EOverlayMode_MAX                         = 4,
};

// Enum DeadByDaylight.EOverlayTabs
// NumValues: 0x0008
enum class EOverlayTabs : uint8
{
	Settings                                 = 0,
	Controls                                 = 1,
	Help                                     = 2,
	Survivors                                = 3,
	CoreTabCount                             = 4,
	About                                    = 5,
	Language                                 = 6,
	EOverlayTabs_MAX                         = 7,
};

// Enum DeadByDaylight.EPalletStunZoneSideStrategy
// NumValues: 0x0003
enum class EPalletStunZoneSideStrategy : uint8
{
	OppositeSideToPlayerExecutingPulldown    = 0,
	SameSideToPlayerExecutingPulldown        = 1,
	EPalletStunZoneSideStrategy_MAX          = 2,
};

// Enum DeadByDaylight.EPalletPushSideStrategy
// NumValues: 0x0003
enum class EPalletPushSideStrategy : uint8
{
	PushToClosestPalletSide                  = 0,
	PushOppositeToPlayerExecutingPulldown    = 1,
	EPalletPushSideStrategy_MAX              = 2,
};

// Enum DeadByDaylight.EPalletSide
// NumValues: 0x0004
enum class EPalletSide : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EPalletSide_MAX                          = 3,
};

// Enum DeadByDaylight.EPalletState
// NumValues: 0x0005
enum class EPalletState : uint8
{
	Up                                       = 0,
	Falling                                  = 1,
	Fallen                                   = 2,
	Destroyed                                = 3,
	EPalletState_MAX                         = 4,
};

// Enum DeadByDaylight.EPerkTokenSoundStrategy
// NumValues: 0x0004
enum class EPerkTokenSoundStrategy : uint8
{
	NoSound                                  = 0,
	SoundOnEveryTokenChange                  = 1,
	SoundOnReachMaxTokens                    = 2,
	EPerkTokenSoundStrategy_MAX              = 3,
};

// Enum DeadByDaylight.EPerspectiveActivationCondition
// NumValues: 0x0004
enum class EPerspectiveActivationCondition : uint8
{
	LocallyControlled                        = 0,
	LocallyObserved                          = 1,
	NotLocallyObserved                       = 2,
	EPerspectiveActivationCondition_MAX      = 3,
};

// Enum DeadByDaylight.ESaveGameFailureType
// NumValues: 0x0007
enum class ESaveGameFailureType : uint8
{
	None                                     = 0,
	InvalidPlayerID                          = 1,
	InvalidGameInstance                      = 2,
	NoServerConnection                       = 3,
	UserNotSignedIn                          = 4,
	Unknown                                  = 5,
	ESaveGameFailureType_MAX                 = 6,
};

// Enum DeadByDaylight.ERequestState
// NumValues: 0x0005
enum class ERequestState : uint8
{
	VE_None                                  = 0,
	VE_Pending                               = 1,
	VE_Success                               = 2,
	VE_Fail                                  = 3,
	VE_MAX                                   = 4,
};

// Enum DeadByDaylight.EInteractionValidationState
// NumValues: 0x0007
enum class EInteractionValidationState : uint8
{
	None                                     = 0,
	Predicted                                = 1,
	Authorized                               = 2,
	DeniedByRaceCondition                    = 3,
	DeniedByTimeout                          = 4,
	DeniedByError                            = 5,
	EInteractionValidationState_MAX          = 6,
};

// Enum DeadByDaylight.ESecondaryActionRequestTypes
// NumValues: 0x0004
enum class ESecondaryActionRequestTypes : uint8
{
	None                                     = 0,
	SecondaryActionRequested                 = 1,
	SecondaryActionRequestedFromCancel       = 2,
	ESecondaryActionRequestTypes_MAX         = 3,
};

// Enum DeadByDaylight.ERadialProgressBarType
// NumValues: 0x0003
enum class ERadialProgressBarType : uint8
{
	Yellow                                   = 0,
	Red                                      = 1,
	ERadialProgressBarType_MAX               = 2,
};

// Enum DeadByDaylight.EPreLevelGenerationModifierType
// NumValues: 0x0003
enum class EPreLevelGenerationModifierType : uint8
{
	None                                     = 0,
	ModifyKillerObjectCount                  = 1,
	EPreLevelGenerationModifierType_MAX      = 2,
};

// Enum DeadByDaylight.EPrestigeRewardType
// NumValues: 0x0004
enum class EPrestigeRewardType : uint8
{
	None                                     = 0,
	Customization                            = 1,
	Perk                                     = 2,
	EPrestigeRewardType_MAX                  = 3,
};

// Enum DeadByDaylight.ESurvivorGrouping
// NumValues: 0x0006
enum class ESurvivorGrouping : uint8
{
	Invalid                                  = 0,
	Separated                                = 1,
	Grouped2_2                               = 2,
	Grouped3_1                               = 3,
	Grouped4_0                               = 4,
	ESurvivorGrouping_MAX                    = 5,
};

// Enum DeadByDaylight.EscapeStrategyType
// NumValues: 0x0003
enum class EscapeStrategyType : uint8
{
	EscapeDoor                               = 0,
	EscapeHatch                              = 1,
	EscapeStrategyType_MAX                   = 2,
};

// Enum DeadByDaylight.ELevelBuildingState
// NumValues: 0x0014
enum class ELevelBuildingState : uint8
{
	NotInitialized                           = 0,
	WaitingForInitialSync                    = 1,
	SyncSeeds                                = 2,
	GetAvailableItems                        = 3,
	PendingGettingItems                      = 4,
	GettingLevelsDone                        = 5,
	PendingPremadeMapStreaming               = 6,
	GetThemedTiles                           = 7,
	PendingGettingTiles                      = 8,
	SpawnEscapeTiles                         = 9,
	SpawnBasementTile                        = 10,
	SpawningLevelTiles                       = 11,
	SpawnInterTileElements                   = 12,
	PendingInterTileElementsSpawning         = 13,
	SpawningActors                           = 14,
	SpawningMultiPassActors                  = 15,
	StallingForRemotes                       = 16,
	BuildingDone                             = 17,
	BuildingStateCount                       = 18,
	ELevelBuildingState_MAX                  = 19,
};

// Enum DeadByDaylight.EPromoPackContentType
// NumValues: 0x000C
enum class EPromoPackContentType : uint8
{
	None                                     = 0,
	Item                                     = 1,
	Addon                                    = 2,
	Offering                                 = 3,
	Character                                = 4,
	Customization                            = 5,
	Bonus                                    = 6,
	BloodPoints                              = 7,
	IridescentShards                         = 8,
	FreeTicket                               = 9,
	Count                                    = 10,
	EPromoPackContentType_MAX                = 11,
};

// Enum DeadByDaylight.EConditionNeedsType
// NumValues: 0x0003
enum class EConditionNeedsType : uint8
{
	AllTrue                                  = 0,
	AnyTrue                                  = 1,
	EConditionNeedsType_MAX                  = 2,
};

// Enum DeadByDaylight.ERefundSource
// NumValues: 0x0006
enum class ERefundSource : uint8
{
	None                                     = 0,
	BloodMarket                              = 1,
	DailyCalendar                            = 2,
	PromoPack                                = 3,
	Count                                    = 4,
	ERefundSource_MAX                        = 5,
};

// Enum DeadByDaylight.ESaveGameErrorCategory
// NumValues: 0x0006
enum class ESaveGameErrorCategory : uint8
{
	EvaluateDisconnectPenalty                = 0,
	SaveGameSaveError                        = 1,
	SaveGameUnreadable                       = 2,
	SaveGameValidation                       = 3,
	SaveFailed                               = 4,
	ESaveGameErrorCategory_MAX               = 5,
};

// Enum DeadByDaylight.EScreenType
// NumValues: 0x0004
enum class EScreenType : uint8
{
	eScaleformScreen                         = 0,
	eUMGScreen                               = 1,
	eMixedScaleformUMG                       = 2,
	EScreenType_MAX                          = 3,
};

// Enum DeadByDaylight.EScreenshotToolBatchType
// NumValues: 0x000E
enum class EScreenshotToolBatchType : uint8
{
	SelectedItemOrOutfit                     = 0,
	SelectedItemOrOutfitSeparated            = 1,
	SelectedCharacterItems                   = 2,
	SelectedCharacterOutfits                 = 3,
	SelectedCharacterAndCategory             = 4,
	ItemsMissingIcon                         = 5,
	OutfitMissingIcon                        = 6,
	CharmsMissingIcon                        = 7,
	PerkCharmsMissingIcon                    = 8,
	AllItems                                 = 9,
	AllOutfits                               = 10,
	AllCharms                                = 11,
	AllPerkCharms                            = 12,
	EScreenshotToolBatchType_MAX             = 13,
};

// Enum DeadByDaylight.EScreenshotToolState
// NumValues: 0x000A
enum class EScreenshotToolState : uint8
{
	None                                     = 0,
	PrepareBatch                             = 1,
	GenerateIcons                            = 2,
	ShaderCompilation                        = 3,
	GenerateAsset                            = 4,
	SaveAndCheckout                          = 5,
	FinishSuccess                            = 6,
	FinishFail                               = 7,
	FinishCancel                             = 8,
	EScreenshotToolState_MAX                 = 9,
};

// Enum DeadByDaylight.SettingsId
// NumValues: 0x0042
enum class ESettingsId : uint64
{
	None                                     = 18446744073709551615,
	Language                                 = 0,
	RevokeConsent                            = 1,
	RevokeMarketingConsent                   = 2,
	BhvrAccount                              = 3,
	AllowCrossplayGeneric                    = 4,
	AllowCrossplayLive                       = 5,
	AutoDeclineFriendRequests                = 6,
	PlayerId                                 = 7,
	PartyPrivacy                             = 8,
	Quality                                  = 9,
	AutoAdjust                               = 10,
	Resolution                               = 11,
	FullScreen                               = 12,
	HUDConstrainedAspectRatio                = 13,
	MenuScaleFactor                          = 14,
	HudScaleFactor                           = 15,
	SkillCheckScaleFactor                    = 16,
	LargeText                                = 17,
	BloodwebInteractionBehaviour             = 18,
	TerrorRadiusVisualFeedback               = 19,
	HUDPlayerNamesVisibility                 = 20,
	HUDKillerHookCountVisibility             = 21,
	HUDScoreEventsVisibility                 = 22,
	LegacyPrestigePortraits                  = 23,
	ChallengeProgression                     = 24,
	ChallengeCompletion                      = 25,
	MainVolume                               = 26,
	MenuMusicVolume                          = 27,
	Headphones                               = 28,
	MuteOnFocusLost                          = 29,
	InvertYAxis                              = 30,
	SurvivorMouseSensitivity                 = 31,
	SurvivorControllerSensitivity            = 32,
	KillerMouseSensitivity                   = 33,
	KillerControllerSensitivity              = 34,
	SurvivorToggleInteractions               = 35,
	KillerToggleInteractions                 = 36,
	SprintToCancel                           = 37,
	ColorBarPalette                          = 38,
	ColorBlindMode                           = 39,
	ColorBlindModeIntensity                  = 40,
	BeginnerMode                             = 41,
	Subtitles                                = 42,
	SubtitlesBackgroundOpacity               = 43,
	SubtitlesSize                            = 44,
	IsAnonymousMode                          = 45,
	HideYourName                             = 46,
	HideOtherNames                           = 47,
	HiddenMatchmakingDelay                   = 48,
	SurvivorCameraSensitivity                = 49,
	KillerCameraSensitivity                  = 50,
	MenuMusicVolumeOn                        = 51,
	MainVolumeOn                             = 52,
	AimAssist                                = 53,
	SurvivorQuickTurn                        = 54,
	KillerQuickTurn                          = 55,
	FPSLimit                                 = 56,
	AutoQuality                              = 57,
	ControlType                              = 58,
	CustomizedControls                       = 59,
	DynamicResolution                        = 60,
	InvertYAxisSurvivor                      = 61,
	BetaWiggleSkillCheck                     = 62,
	HapticsVibrationPS5                      = 63,
	SettingsId_MAX                           = 64,
};

// Enum DeadByDaylight.SettingsSubCategory
// NumValues: 0x0012
enum class ESettingsSubCategory : uint64
{
	None                                     = 18446744073709551615,
	Language                                 = 0,
	Tutorial                                 = 1,
	Privacy                                  = 2,
	Accessibility                            = 3,
	InGameText                               = 4,
	ColorBlindMode                           = 5,
	MotionSickness                           = 6,
	Social                                   = 7,
	GameplayPrivacy                          = 8,
	Graphics                                 = 9,
	UIHud                                    = 10,
	Audio                                    = 11,
	CommonControls                           = 12,
	SurvivorControls                         = 13,
	KillerControls                           = 14,
	Atlanta                                  = 15,
	SettingsSubCategory_MAX                  = 16,
};

// Enum DeadByDaylight.SettingsCategory
// NumValues: 0x000A
enum class ESettingsCategory : uint64
{
	None                                     = 18446744073709551615,
	General                                  = 0,
	Accessibility                            = 1,
	Beta                                     = 2,
	Online                                   = 3,
	Graphics                                 = 4,
	Audio                                    = 5,
	Controls                                 = 6,
	Atlanta                                  = 7,
	SettingsCategory_MAX                     = 8,
};

// Enum DeadByDaylight.SettingsType
// NumValues: 0x000A
enum class ESettingsType : uint64
{
	None                                     = 18446744073709551615,
	Button                                   = 0,
	PlayerId                                 = 1,
	NumericStepper                           = 2,
	Dropdown                                 = 3,
	ColorBar                                 = 4,
	TextStepper                              = 5,
	BoolTextStepper                          = 6,
	Checkbox                                 = 7,
	SettingsType_MAX                         = 8,
};

// Enum DeadByDaylight.EStoreUITag
// NumValues: 0x0004
enum class EStoreUITag : uint8
{
	None                                     = 0,
	Sale                                     = 1,
	New                                      = 2,
	EStoreUITag_MAX                          = 3,
};

// Enum DeadByDaylight.ECatalogStatus
// NumValues: 0x0004
enum class ECatalogStatus : uint8
{
	NotReady                                 = 0,
	Updating                                 = 1,
	Fetched                                  = 2,
	ECatalogStatus_MAX                       = 3,
};

// Enum DeadByDaylight.EShopLoadProgress
// NumValues: 0x0008
enum class EShopLoadProgress : uint8
{
	None                                     = 0,
	LoadCatalog                              = 1,
	LoadCurrencyPacks                        = 2,
	PlatformStoreCatalog                     = 3,
	Inventory                                = 4,
	Wallet                                   = 5,
	FeaturedPageContent                      = 6,
	EShopLoadProgress_MAX                    = 7,
};

// Enum DeadByDaylight.ESoftBanReason
// NumValues: 0x0007
enum class ESoftBanReason : uint64
{
	Invalid                                  = 18446744073709551615,
	Harassment                               = 0,
	Griefing                                 = 1,
	Exploits                                 = 2,
	Unsportsmanlike                          = 3,
	Count                                    = 4,
	ESoftBanReason_MAX                       = 5,
};

// Enum DeadByDaylight.ESoundIndicatorType
// NumValues: 0x000A
enum class ESoundIndicatorType : uint8
{
	None                                     = 0,
	CloseNoiseIndicator                      = 1,
	ExitOpenedIndicator                      = 2,
	GeneratorIndicator                       = 3,
	HatchIndicator                           = 4,
	HookedIndicator                          = 5,
	KillerCuesIndicator                      = 6,
	GlobalSoundIndicator                     = 7,
	DirectionalTerrorRadiusIndicator         = 8,
	ESoundIndicatorType_MAX                  = 9,
};

// Enum DeadByDaylight.ESpawnerStrategyType
// NumValues: 0x0004
enum class ESpawnerStrategyType : uint8
{
	None                                     = 0,
	NoAccumulation                           = 1,
	LimitAccumulation                        = 2,
	ESpawnerStrategyType_MAX                 = 3,
};

// Enum DeadByDaylight.EGiftSpecialAction
// NumValues: 0x0003
enum class EGiftSpecialAction : uint8
{
	None                                     = 0,
	KeplerGift                               = 1,
	EGiftSpecialAction_MAX                   = 2,
};

// Enum DeadByDaylight.ESpecialEventBloodwebChestCondition
// NumValues: 0x0004
enum class ESpecialEventBloodwebChestCondition : uint8
{
	Default                                  = 0,
	All                                      = 1,
	WithEventItem                            = 2,
	ESpecialEventBloodwebChestCondition_MAX  = 3,
};

// Enum DeadByDaylight.ESpecialEventDependency
// NumValues: 0x0003
enum class ESpecialEventDependency : uint8
{
	None                                     = 0,
	Archives                                 = 1,
	ESpecialEventDependency_MAX              = 2,
};

// Enum DeadByDaylight.ESpecialEventGameMode
// NumValues: 0x0004
enum class ESpecialEventGameMode : uint8
{
	Progression                              = 0,
	Counter                                  = 1,
	Collection                               = 2,
	ESpecialEventGameMode_MAX                = 3,
};

// Enum DeadByDaylight.ESpecialEventStatus
// NumValues: 0x0004
enum class ESpecialEventStatus : uint8
{
	Inactive                                 = 0,
	ActiveMain                               = 1,
	ActivePost                               = 2,
	ESpecialEventStatus_MAX                  = 3,
};

// Enum DeadByDaylight.ELoadCompleteState
// NumValues: 0x0028
enum class ELoadCompleteState : uint8
{
	InProgress                               = 0,
	Success                                  = 1,
	ReloginRequested                         = 2,
	FailedEAC                                = 3,
	FailedRecoverable                        = 4,
	FailedRecoverableProfileLoad             = 5,
	FailedRecoverableWindowsStoreAndXboxLiveAccountNotMatching = 6,
	FailedUnequipedDisableditems             = 7,
	FailedBlocking                           = 8,
	FailedBlockingNoDBDServer                = 9,
	FailedBlockingNotConnected               = 10,
	FailedBlockedNoNetworkConnection         = 11,
	FailedBlockingSharedAuthenticationFailed = 12,
	FailedBlockingPlatformNotAuthenticated   = 13,
	FailedBlockingPlatformSubsystemNotInitialized = 14,
	FailedBlockingOnlinePresenceNotInitialized = 15,
	FailedBlockingPlatformNetUniqueIdInvalid = 16,
	FailedBlockingInvalidLocalPlayer         = 17,
	FailedBlockingInvalidGameObjects         = 18,
	FailedBlockingInvalidSDA                 = 19,
	FailedBlockingInvalidClientVersion       = 20,
	FailedBlockingInvalidAtlantaClientVersion = 21,
	FailedBlockingWindowsStoreAccountNotLoggedIn = 22,
	FailedBlockingSSLCACert                  = 23,
	FailedBlockingUserCancelled              = 24,
	FailedBlockingCDNFailure                 = 25,
	FailedBlockingCDNContentError            = 26,
	FailedBlockingCDNCantFindContentToDownload = 27,
	FailedBlockingCDNNoPatchForCurrentPlatformAndVersion = 28,
	FailedBlockingCDNNotEnoughDiskSpace      = 29,
	FailedBlockingCDNFailureToRetrieveContent = 30,
	FailedRecoverableCDNUserCancelled        = 31,
	FailedBlockingVersionFileError           = 32,
	FailedBlockingRTMConnection              = 33,
	FailedBlockingMaxTrialsReached           = 34,
	FailedBlockingMirrorsHealthCheckFailed   = 35,
	FailedBlockingTutorialRewardsFetchFailed = 36,
	FailedBlockingUserBanned                 = 37,
	FailedRetrieveStoreItem                  = 38,
	ELoadCompleteState_MAX                   = 39,
};

// Enum DeadByDaylight.EExternalEffectSource
// NumValues: 0x0005
enum class EExternalEffectSource : uint8
{
	None                                     = 0,
	Perk                                     = 1,
	Addon                                    = 2,
	Power                                    = 3,
	EExternalEffectSource_MAX                = 4,
};

// Enum DeadByDaylight.EStoreBannerLocation
// NumValues: 0x0003
enum class EStoreBannerLocation : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	EStoreBannerLocation_MAX                 = 2,
};

// Enum DeadByDaylight.EInteractionStorerRole
// NumValues: 0x0006
enum class EInteractionStorerRole : uint8
{
	None                                     = 0,
	AuthorityAndAutonomousProxy              = 1,
	ClientAndAutonomousProxy                 = 2,
	AuthorityAndSimulatedProxy               = 3,
	ClientAndSimulatedProxy                  = 4,
	EInteractionStorerRole_MAX               = 5,
};

// Enum DeadByDaylight.ETextBannerPosition
// NumValues: 0x0009
enum class ETextBannerPosition : uint8
{
	TopLeft                                  = 0,
	MiddleLeft                               = 1,
	BottomLeft                               = 2,
	MiddleRight                              = 3,
	BottomRight                              = 4,
	TopCenter                                = 5,
	MiddleCenter                             = 6,
	BottomCenter                             = 7,
	ETextBannerPosition_MAX                  = 8,
};

// Enum DeadByDaylight.EStorefrontState
// NumValues: 0x000B
enum class EStorefrontState : uint8
{
	None                                     = 0,
	Character                                = 1,
	Currency                                 = 2,
	Customization                            = 3,
	Featured                                 = 4,
	PromoPacks                               = 5,
	ShrineOfSecrets                          = 6,
	Subscriptions                            = 7,
	LandingPage                              = 8,
	Count                                    = 9,
	EStorefrontState_MAX                     = 10,
};

// Enum DeadByDaylight.EStoreTab
// NumValues: 0x0006
enum class EStoreTab : uint8
{
	Featured                                 = 0,
	Characters                               = 1,
	Currency                                 = 2,
	ShrineOfSecrets                          = 3,
	TabCount                                 = 4,
	EStoreTab_MAX                            = 5,
};

// Enum DeadByDaylight.EStoreState
// NumValues: 0x0008
enum class EStoreState : uint8
{
	None                                     = 0,
	Featured                                 = 1,
	CharacterSelection                       = 2,
	CharacterStory                           = 3,
	CharacterCatalog                         = 4,
	BuyCurrency                              = 5,
	ShrineOfSecrets                          = 6,
	EStoreState_MAX                          = 7,
};

// Enum DeadByDaylight.EStreamVideoDataType
// NumValues: 0x0006
enum class EStreamVideoDataType : uint8
{
	None                                     = 0,
	LoreCinematic                            = 1,
	SurvivorTutorial                         = 2,
	KillerTutorial                           = 3,
	Count                                    = 4,
	EStreamVideoDataType_MAX                 = 5,
};

// Enum DeadByDaylight.ESubscriptionRewardType
// NumValues: 0x000B
enum class ESubscriptionRewardType : uint8
{
	None                                     = 0,
	Item                                     = 1,
	AddOn                                    = 2,
	Offering                                 = 3,
	FreeTicket                               = 4,
	AuricCells                               = 5,
	BloodPoints                              = 6,
	IridescentShards                         = 7,
	Customization                            = 8,
	Character                                = 9,
	ESubscriptionRewardType_MAX              = 10,
};

// Enum DeadByDaylight.EPromptType
// NumValues: 0x0005
enum class EPromptType : uint8
{
	None                                     = 0,
	ExitsPowered                             = 1,
	HatchSpawned                             = 2,
	HatchOpened                              = 3,
	EPromptType_MAX                          = 4,
};

// Enum DeadByDaylight.ENotificationStyle
// NumValues: 0x0004
enum class ENotificationStyle : uint8
{
	None                                     = 0,
	Game                                     = 1,
	Tutorial                                 = 2,
	ENotificationStyle_MAX                   = 3,
};

// Enum DeadByDaylight.EPromptPriority
// NumValues: 0x0005
enum class EPromptPriority : uint8
{
	Tutorial                                 = 0,
	High                                     = 1,
	Medium                                   = 2,
	Low                                      = 3,
	EPromptPriority_MAX                      = 4,
};

// Enum DeadByDaylight.ELegalTermsStatus
// NumValues: 0x0004
enum class ELegalTermsStatus : uint8
{
	None                                     = 0,
	Accepted                                 = 1,
	Declined                                 = 2,
	ELegalTermsStatus_MAX                    = 3,
};

// Enum DeadByDaylight.EInventoryGridFormat
// NumValues: 0x0004
enum class EInventoryGridFormat : uint8
{
	DEFAULT                                  = 0,
	DIAMOND                                  = 1,
	HONEYCOMB                                = 2,
	EInventoryGridFormat_MAX                 = 3,
};

// Enum DeadByDaylight.ENewContentType
// NumValues: 0x0008
enum class ENewContentType : uint8
{
	FEATURED_CONTENT                         = 1,
	NEW_CONTENT                              = 2,
	PATCH_NOTES                              = 3,
	DEV_MESSAGES                             = 4,
	EVENTS                                   = 5,
	SALE                                     = 6,
	COMMUNITY                                = 7,
	ENewContentType_MAX                      = 8,
};

// Enum DeadByDaylight.EOverlayButtonOptions
// NumValues: 0x0004
enum class EOverlayButtonOptions : uint8
{
	HIDDEN                                   = 0,
	DISABLED                                 = 1,
	ENABLED                                  = 2,
	EOverlayButtonOptions_MAX                = 3,
};

// Enum DeadByDaylight.EUIControllerType
// NumValues: 0x0003
enum class EUIControllerType : uint8
{
	KeyboardMouse                            = 0,
	GamePad                                  = 1,
	EUIControllerType_MAX                    = 2,
};

// Enum DeadByDaylight.EForumLanguages
// NumValues: 0x0006
enum class EForumLanguages : uint8
{
	None                                     = 0,
	de                                       = 1,
	en                                       = 2,
	ja                                       = 3,
	ru                                       = 4,
	EForumLanguages_MAX                      = 5,
};

// Enum DeadByDaylight.ECustomerSupportLanguages
// NumValues: 0x000E
enum class ECustomerSupportLanguages : uint8
{
	None                                     = 0,
	de                                       = 1,
	en                                       = 2,
	ja                                       = 3,
	ru                                       = 4,
	es                                       = 5,
	fr                                       = 6,
	it                                       = 7,
	ko                                       = 8,
	pl                                       = 9,
	pt                                       = 10,
	th                                       = 11,
	zh                                       = 12,
	ECustomerSupportLanguages_MAX            = 13,
};

// Enum DeadByDaylight.ELeaveLobbyReason
// NumValues: 0x000A
enum class ELeaveLobbyReason : uint8
{
	eNone                                    = 0,
	eNetworkDisconnect                       = 1,
	eProfileOffline                          = 2,
	eAppSuspended                            = 3,
	eInternetDisconnect                      = 4,
	eHostDisconnect                          = 5,
	eDLCInstalled                            = 6,
	eTrialExtensionExpired                   = 7,
	ePartyManagementError                    = 8,
	ELeaveLobbyReason_MAX                    = 9,
};

// Enum DeadByDaylight.EFriendSearchPanelOption
// NumValues: 0x0007
enum class EFriendSearchPanelOption : uint8
{
	NotFoundPanel                            = 0,
	NonFriendPanel                           = 1,
	FriendRequestReceivedPanel               = 2,
	FriendRequestSentPanel                   = 3,
	FriendPanel                              = 4,
	IsOwnerPanel                             = 5,
	EFriendSearchPanelOption_MAX             = 6,
};

// Enum DeadByDaylight.EFriendContainerType
// NumValues: 0x0009
enum class EFriendContainerType : uint8
{
	Connected                                = 0,
	Disconnected                             = 1,
	PendingSentRequest                       = 2,
	RecentlyPlayed                           = 3,
	SocialSuggestions                        = 4,
	PendingReceivedRequest                   = 5,
	QueriedPlayer                            = 6,
	Unknown                                  = 7,
	EFriendContainerType_MAX                 = 8,
};

// Enum DeadByDaylight.EPurchasePopupState
// NumValues: 0x0003
enum class EPurchasePopupState : uint8
{
	Information                              = 0,
	TitleOnly                                = 1,
	EPurchasePopupState_MAX                  = 2,
};

// Enum DeadByDaylight.EAtlantaSettingMenuType
// NumValues: 0x0003
enum class EAtlantaSettingMenuType : uint8
{
	TabButton                                = 0,
	AlwaysDisplay                            = 1,
	EAtlantaSettingMenuType_MAX              = 2,
};

// Enum DeadByDaylight.EBloodStoreRowStyle
// NumValues: 0x0003
enum class EBloodStoreRowStyle : uint8
{
	FiveItemRow                              = 0,
	ThreeItemRow                             = 1,
	EBloodStoreRowStyle_MAX                  = 2,
};

// Enum DeadByDaylight.EButtonType
// NumValues: 0x0008
enum class EButtonType : uint8
{
	None                                     = 0,
	AttackButton                             = 1,
	PowerButton                              = 2,
	CancelButton                             = 3,
	SettingsButton                           = 4,
	SecondaryActionButton                    = 5,
	PowerAttackJoystick                      = 6,
	EButtonType_MAX                          = 7,
};

// Enum DeadByDaylight.EInboxMessageTimeUnit
// NumValues: 0x0004
enum class EInboxMessageTimeUnit : uint8
{
	Days                                     = 0,
	Hours                                    = 1,
	Minutes                                  = 2,
	EInboxMessageTimeUnit_MAX                = 3,
};

// Enum DeadByDaylight.EInboxMessageUIState
// NumValues: 0x0004
enum class EInboxMessageUIState : uint8
{
	New                                      = 0,
	Read                                     = 1,
	Archived                                 = 2,
	EInboxMessageUIState_MAX                 = 3,
};

// Enum DeadByDaylight.EInboxMessageUIType
// NumValues: 0x0005
enum class EInboxMessageUIType : uint8
{
	None                                     = 0,
	Social                                   = 1,
	Rewards                                  = 2,
	News                                     = 3,
	EInboxMessageUIType_MAX                  = 4,
};

// Enum DeadByDaylight.EPartyPlayerSlotWidgetState
// NumValues: 0x0006
enum class EPartyPlayerSlotWidgetState : uint8
{
	None                                     = 0,
	Empty                                    = 1,
	NotReady                                 = 2,
	Ready                                    = 3,
	Hidden                                   = 4,
	EPartyPlayerSlotWidgetState_MAX          = 5,
};

// Enum DeadByDaylight.ERewardLayoutBox
// NumValues: 0x0003
enum class ERewardLayoutBox : uint8
{
	Top                                      = 0,
	Bottom                                   = 1,
	ERewardLayoutBox_MAX                     = 2,
};

// Enum DeadByDaylight.ESettingScreenButtonData
// NumValues: 0x000D
enum class ESettingScreenButtonData : uint8
{
	PRIVACY                                  = 0,
	EULA                                     = 1,
	CREDITS                                  = 2,
	SURVIVORTUTORIAL                         = 3,
	KILLERTUTORIAL                           = 4,
	SURVIVORCINEMATIC                        = 5,
	KILLERCINEMATIC                          = 6,
	LORECINEMATIC                            = 7,
	COMMUNITY                                = 8,
	PLAYERCLOUDID                            = 9,
	SUBSCRIBE                                = 10,
	TERMSOFUSE                               = 11,
	ESettingScreenButtonData_MAX             = 12,
};

// Enum DeadByDaylight.ENavigationState
// NumValues: 0x0007
enum class ENavigationState : uint8
{
	RoleSelection                            = 0,
	Customization                            = 1,
	CharacterSelection                       = 2,
	Lobby                                    = 3,
	BloodStore                               = 4,
	None                                     = 5,
	ENavigationState_MAX                     = 6,
};

// Enum DeadByDaylight.EInventoryButtonState
// NumValues: 0x0008
enum class EInventoryButtonState : uint8
{
	StateDisabled                            = 0,
	StateEmpty                               = 1,
	StateLocked                              = 2,
	StateWithItem                            = 3,
	StateWithItemDisabled                    = 4,
	StateWithItemLocked                      = 5,
	StatePrivate                             = 6,
	EInventoryButtonState_MAX                = 7,
};

// Enum DeadByDaylight.EFogScreenButton
// NumValues: 0x0004
enum class EFogScreenButton : uint8
{
	AddCurrency                              = 0,
	Setting                                  = 1,
	Chat                                     = 2,
	EFogScreenButton_MAX                     = 3,
};

// Enum DeadByDaylight.ERoleSelectionScreenButton
// NumValues: 0x0007
enum class ERoleSelectionScreenButton : uint8
{
	DailyRitual                              = 0,
	Inbox                                    = 1,
	InviteFriend                             = 2,
	Setting                                  = 3,
	Marketing                                = 4,
	Events                                   = 5,
	ERoleSelectionScreenButton_MAX           = 6,
};

// Enum DeadByDaylight.ENavigationScreenButton
// NumValues: 0x000D
enum class ENavigationScreenButton : uint8
{
	AddCurrency                              = 0,
	Back                                     = 1,
	Bloodweb                                 = 2,
	ChangeRole                               = 3,
	CharacterSelection                       = 4,
	Customization                            = 5,
	InviteFriend                             = 6,
	Loadout                                  = 7,
	Start                                    = 8,
	Subscriptions                            = 9,
	EditCustomGame                           = 10,
	CustomGameRequestRole                    = 11,
	ENavigationScreenButton_MAX              = 12,
};

// Enum DeadByDaylight.EInboxScreenButton
// NumValues: 0x0005
enum class EInboxScreenButton : uint8
{
	Rewards                                  = 0,
	Social                                   = 1,
	News                                     = 2,
	Back                                     = 3,
	EInboxScreenButton_MAX                   = 4,
};

// Enum DeadByDaylight.ETallyListPageID
// NumValues: 0x0007
enum class ETallyListPageID : uint8
{
	Scoreboard                               = 0,
	Bloodpoints                              = 1,
	Rank                                     = 2,
	PlayerLevel                              = 3,
	CharacterLevel                           = 4,
	NumberOfPages                            = 5,
	ETallyListPageID_MAX                     = 6,
};

// Enum DeadByDaylight.EToastWidgetType
// NumValues: 0x0003
enum class EToastWidgetType : uint8
{
	Simple                                   = 0,
	Interactable                             = 1,
	EToastWidgetType_MAX                     = 2,
};

// Enum DeadByDaylight.ELinkedVomitState
// NumValues: 0x0004
enum class ELinkedVomitState : uint8
{
	Idle                                     = 0,
	Charging                                 = 1,
	Vomiting                                 = 2,
	ELinkedVomitState_MAX                    = 3,
};

// ScriptStruct DeadByDaylight.SpecialEventUIInfo
// 0x0060 (0x0060 - 0x0000)
struct FSpecialEventUIInfo final
{
public:
	class FString                                 EventId;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventBannerFrameLabel;                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventThemeFrameLabel;                              // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventName;                                         // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          IsPastEvent;                                       // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BloodwebCollectSoundEvent;                         // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventUIInfo) == 0x000008, "Wrong alignment on FSpecialEventUIInfo");
static_assert(sizeof(FSpecialEventUIInfo) == 0x000060, "Wrong size on FSpecialEventUIInfo");
static_assert(offsetof(FSpecialEventUIInfo, EventId) == 0x000000, "Member 'FSpecialEventUIInfo::EventId' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, EventBannerFrameLabel) == 0x000010, "Member 'FSpecialEventUIInfo::EventBannerFrameLabel' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, EventThemeFrameLabel) == 0x000020, "Member 'FSpecialEventUIInfo::EventThemeFrameLabel' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, EventName) == 0x000030, "Member 'FSpecialEventUIInfo::EventName' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, IsPastEvent) == 0x000048, "Member 'FSpecialEventUIInfo::IsPastEvent' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, BloodwebCollectSoundEvent) == 0x000050, "Member 'FSpecialEventUIInfo::BloodwebCollectSoundEvent' has a wrong offset!");

// ScriptStruct DeadByDaylight.InventorySlotData
// 0x0128 (0x0128 - 0x0000)
struct FInventorySlotData final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconFilePath;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentDisplayName;                                 // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentTypeDisplayName;                             // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsParentAvailable;                                 // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPerkCategory>                         PerkCategory;                                      // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	EOfferingCategory                             OfferingCategory;                                  // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x0079(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x007A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x007B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Subtitle;                                          // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAvailability                             Availability;                                      // 0x0094(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeachablePerk;                                   // 0x0095(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasherPerk;                                     // 0x0096(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPerkAvailableInFearMarket;                       // 0x0097(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPerkAvailableInBloodWeb;                         // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeachableLevel;                                    // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DlcDisplayName;                                    // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventUIInfo                    EventInfo;                                         // 0x00B8(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	int32                                         UnlockableLevel;                                   // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLimitedItem;                                     // 0x011C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPrivateIcon;                                     // 0x011D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x011E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSharablePerk;                                    // 0x011F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadoutPartState                             LoadoutPartState;                                  // 0x0120(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventorySlotData) == 0x000008, "Wrong alignment on FInventorySlotData");
static_assert(sizeof(FInventorySlotData) == 0x000128, "Wrong size on FInventorySlotData");
static_assert(offsetof(FInventorySlotData, ItemId) == 0x000000, "Member 'FInventorySlotData::ItemId' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IconFilePath) == 0x000010, "Member 'FInventorySlotData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, DisplayName) == 0x000020, "Member 'FInventorySlotData::DisplayName' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, ParentDisplayName) == 0x000030, "Member 'FInventorySlotData::ParentDisplayName' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, ParentTypeDisplayName) == 0x000040, "Member 'FInventorySlotData::ParentTypeDisplayName' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsParentAvailable) == 0x000050, "Member 'FInventorySlotData::IsParentAvailable' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, Description) == 0x000058, "Member 'FInventorySlotData::Description' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, PerkCategory) == 0x000068, "Member 'FInventorySlotData::PerkCategory' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, OfferingCategory) == 0x000078, "Member 'FInventorySlotData::OfferingCategory' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, ItemType) == 0x000079, "Member 'FInventorySlotData::ItemType' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, Rarity) == 0x00007A, "Member 'FInventorySlotData::Rarity' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, StatusEffectType) == 0x00007B, "Member 'FInventorySlotData::StatusEffectType' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, Level) == 0x00007C, "Member 'FInventorySlotData::Level' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, Subtitle) == 0x000080, "Member 'FInventorySlotData::Subtitle' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, StackCount) == 0x000090, "Member 'FInventorySlotData::StackCount' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, Availability) == 0x000094, "Member 'FInventorySlotData::Availability' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsTeachablePerk) == 0x000095, "Member 'FInventorySlotData::IsTeachablePerk' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsSlasherPerk) == 0x000096, "Member 'FInventorySlotData::IsSlasherPerk' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsPerkAvailableInFearMarket) == 0x000097, "Member 'FInventorySlotData::IsPerkAvailableInFearMarket' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsPerkAvailableInBloodWeb) == 0x000098, "Member 'FInventorySlotData::IsPerkAvailableInBloodWeb' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, TeachableLevel) == 0x00009C, "Member 'FInventorySlotData::TeachableLevel' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, DlcDisplayName) == 0x0000A0, "Member 'FInventorySlotData::DlcDisplayName' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsLocked) == 0x0000B0, "Member 'FInventorySlotData::IsLocked' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, EventInfo) == 0x0000B8, "Member 'FInventorySlotData::EventInfo' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, UnlockableLevel) == 0x000118, "Member 'FInventorySlotData::UnlockableLevel' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsLimitedItem) == 0x00011C, "Member 'FInventorySlotData::IsLimitedItem' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsPrivateIcon) == 0x00011D, "Member 'FInventorySlotData::IsPrivateIcon' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsEnabled) == 0x00011E, "Member 'FInventorySlotData::IsEnabled' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsSharablePerk) == 0x00011F, "Member 'FInventorySlotData::IsSharablePerk' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, LoadoutPartState) == 0x000120, "Member 'FInventorySlotData::LoadoutPartState' has a wrong offset!");

// ScriptStruct DeadByDaylight.TeachableData
// 0x0140 (0x0140 - 0x0000)
struct FTeachableData final
{
public:
	struct FInventorySlotData                     InventorySlotData;                                 // 0x0000(0x0128)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	ETeachableStatus                              Status;                                            // 0x0128(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnlockLevel;                                       // 0x012C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeachableData) == 0x000008, "Wrong alignment on FTeachableData");
static_assert(sizeof(FTeachableData) == 0x000140, "Wrong size on FTeachableData");
static_assert(offsetof(FTeachableData, InventorySlotData) == 0x000000, "Member 'FTeachableData::InventorySlotData' has a wrong offset!");
static_assert(offsetof(FTeachableData, Status) == 0x000128, "Member 'FTeachableData::Status' has a wrong offset!");
static_assert(offsetof(FTeachableData, UnlockLevel) == 0x00012C, "Member 'FTeachableData::UnlockLevel' has a wrong offset!");
static_assert(offsetof(FTeachableData, Message) == 0x000130, "Member 'FTeachableData::Message' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractionProficiencyData
// 0x0010 (0x0010 - 0x0000)
struct FInteractionProficiencyData final
{
public:
	bool                                          IsActive;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStatusEffectType                             ProficiencyType;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInteractionProficiencyData) == 0x000004, "Wrong alignment on FInteractionProficiencyData");
static_assert(sizeof(FInteractionProficiencyData) == 0x000010, "Wrong size on FInteractionProficiencyData");
static_assert(offsetof(FInteractionProficiencyData, IsActive) == 0x000000, "Member 'FInteractionProficiencyData::IsActive' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyData, Level) == 0x000004, "Member 'FInteractionProficiencyData::Level' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyData, ProficiencyType) == 0x000008, "Member 'FInteractionProficiencyData::ProficiencyType' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyData, Value) == 0x00000C, "Member 'FInteractionProficiencyData::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesVignetteEntry
// 0x0070 (0x0078 - 0x0008)
struct FArchivesVignetteEntry final : public FDBDTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          HasAudio;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              RewardImage;                                       // 0x0040(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviewTextureOffset;                              // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesVignetteEntry) == 0x000008, "Wrong alignment on FArchivesVignetteEntry");
static_assert(sizeof(FArchivesVignetteEntry) == 0x000078, "Wrong size on FArchivesVignetteEntry");
static_assert(offsetof(FArchivesVignetteEntry, Title) == 0x000008, "Member 'FArchivesVignetteEntry::Title' has a wrong offset!");
static_assert(offsetof(FArchivesVignetteEntry, Text) == 0x000020, "Member 'FArchivesVignetteEntry::Text' has a wrong offset!");
static_assert(offsetof(FArchivesVignetteEntry, HasAudio) == 0x000038, "Member 'FArchivesVignetteEntry::HasAudio' has a wrong offset!");
static_assert(offsetof(FArchivesVignetteEntry, RewardImage) == 0x000040, "Member 'FArchivesVignetteEntry::RewardImage' has a wrong offset!");
static_assert(offsetof(FArchivesVignetteEntry, PreviewTextureOffset) == 0x000070, "Member 'FArchivesVignetteEntry::PreviewTextureOffset' has a wrong offset!");

// ScriptStruct DeadByDaylight.GamePresetData
// 0x0090 (0x0090 - 0x0000)
struct FGamePresetData final
{
public:
	TArray<uint8>                                 _mapAvailabilities;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _perkAvailabilities;                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _offeringAvailabilities;                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _itemAvailabilities;                               // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _itemAddonAvailabilities;                          // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _customizationItemAvailabilities;                  // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _characterAvailabilities;                          // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _allowDlcContent;                                  // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _privateMatch;                                     // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomGameBotsData                    _botsData;                                         // 0x0078(0x0018)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGamePresetData) == 0x000008, "Wrong alignment on FGamePresetData");
static_assert(sizeof(FGamePresetData) == 0x000090, "Wrong size on FGamePresetData");
static_assert(offsetof(FGamePresetData, _mapAvailabilities) == 0x000000, "Member 'FGamePresetData::_mapAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _perkAvailabilities) == 0x000010, "Member 'FGamePresetData::_perkAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _offeringAvailabilities) == 0x000020, "Member 'FGamePresetData::_offeringAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _itemAvailabilities) == 0x000030, "Member 'FGamePresetData::_itemAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _itemAddonAvailabilities) == 0x000040, "Member 'FGamePresetData::_itemAddonAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _customizationItemAvailabilities) == 0x000050, "Member 'FGamePresetData::_customizationItemAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _characterAvailabilities) == 0x000060, "Member 'FGamePresetData::_characterAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _allowDlcContent) == 0x000070, "Member 'FGamePresetData::_allowDlcContent' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _privateMatch) == 0x000071, "Member 'FGamePresetData::_privateMatch' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _botsData) == 0x000078, "Member 'FGamePresetData::_botsData' has a wrong offset!");

// ScriptStruct DeadByDaylight.EndOfMatchRPCData
// 0x0018 (0x0018 - 0x0000)
struct FEndOfMatchRPCData final
{
public:
	class FString                                 _jsonData;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isValid;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndOfMatchRPCData) == 0x000008, "Wrong alignment on FEndOfMatchRPCData");
static_assert(sizeof(FEndOfMatchRPCData) == 0x000018, "Wrong size on FEndOfMatchRPCData");
static_assert(offsetof(FEndOfMatchRPCData, _jsonData) == 0x000000, "Member 'FEndOfMatchRPCData::_jsonData' has a wrong offset!");
static_assert(offsetof(FEndOfMatchRPCData, _isValid) == 0x000010, "Member 'FEndOfMatchRPCData::_isValid' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebMandatoryContentByLevel
// 0x0028 (0x0030 - 0x0008)
struct FBloodwebMandatoryContentByLevel final : public FDBDTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForcedItem01;                                      // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForcedItem02;                                      // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForcedItem03;                                      // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebMandatoryContentByLevel) == 0x000008, "Wrong alignment on FBloodwebMandatoryContentByLevel");
static_assert(sizeof(FBloodwebMandatoryContentByLevel) == 0x000030, "Wrong size on FBloodwebMandatoryContentByLevel");
static_assert(offsetof(FBloodwebMandatoryContentByLevel, Level) == 0x000008, "Member 'FBloodwebMandatoryContentByLevel::Level' has a wrong offset!");
static_assert(offsetof(FBloodwebMandatoryContentByLevel, ForcedItem01) == 0x00000C, "Member 'FBloodwebMandatoryContentByLevel::ForcedItem01' has a wrong offset!");
static_assert(offsetof(FBloodwebMandatoryContentByLevel, ForcedItem02) == 0x000018, "Member 'FBloodwebMandatoryContentByLevel::ForcedItem02' has a wrong offset!");
static_assert(offsetof(FBloodwebMandatoryContentByLevel, ForcedItem03) == 0x000024, "Member 'FBloodwebMandatoryContentByLevel::ForcedItem03' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDTimer
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FDBDTimer
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _startTime;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _startTimeDirty;                                   // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloat_NetQuantize8                    _timeLeft;                                         // 0x0010(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _replicateTimeLeft;                                // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19[0xB];                                       // 0x0019(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _interpSpeed;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDBDTimer) == 0x000008, "Wrong alignment on FDBDTimer");
static_assert(sizeof(FDBDTimer) == 0x000028, "Wrong size on FDBDTimer");
static_assert(offsetof(FDBDTimer, _startTime) == 0x000008, "Member 'FDBDTimer::_startTime' has a wrong offset!");
static_assert(offsetof(FDBDTimer, _startTimeDirty) == 0x00000C, "Member 'FDBDTimer::_startTimeDirty' has a wrong offset!");
static_assert(offsetof(FDBDTimer, _timeLeft) == 0x000010, "Member 'FDBDTimer::_timeLeft' has a wrong offset!");
static_assert(offsetof(FDBDTimer, _replicateTimeLeft) == 0x000018, "Member 'FDBDTimer::_replicateTimeLeft' has a wrong offset!");
static_assert(offsetof(FDBDTimer, _interpSpeed) == 0x000024, "Member 'FDBDTimer::_interpSpeed' has a wrong offset!");

// ScriptStruct DeadByDaylight.TargetFocusTimer
// 0x0038 (0x0038 - 0x0000)
struct FTargetFocusTimer final
{
public:
	class ACamperPlayer*                          _camper;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTimer                              _cooldownTimer;                                    // 0x0008(0x0028)(NativeAccessSpecifierPrivate)
	float                                         _totalTime;                                        // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetFocusTimer) == 0x000008, "Wrong alignment on FTargetFocusTimer");
static_assert(sizeof(FTargetFocusTimer) == 0x000038, "Wrong size on FTargetFocusTimer");
static_assert(offsetof(FTargetFocusTimer, _camper) == 0x000000, "Member 'FTargetFocusTimer::_camper' has a wrong offset!");
static_assert(offsetof(FTargetFocusTimer, _cooldownTimer) == 0x000008, "Member 'FTargetFocusTimer::_cooldownTimer' has a wrong offset!");
static_assert(offsetof(FTargetFocusTimer, _totalTime) == 0x000030, "Member 'FTargetFocusTimer::_totalTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.Dependency
// 0x0038 (0x0038 - 0x0000)
struct FDependency final
{
public:
	ETileSpawnPointType                           Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AssetReference;                                    // 0x0008(0x0020)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     Object;                                            // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Unique;                                            // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDependency) == 0x000008, "Wrong alignment on FDependency");
static_assert(sizeof(FDependency) == 0x000038, "Wrong size on FDependency");
static_assert(offsetof(FDependency, Type) == 0x000000, "Member 'FDependency::Type' has a wrong offset!");
static_assert(offsetof(FDependency, AssetReference) == 0x000008, "Member 'FDependency::AssetReference' has a wrong offset!");
static_assert(offsetof(FDependency, Object) == 0x000028, "Member 'FDependency::Object' has a wrong offset!");
static_assert(offsetof(FDependency, Unique) == 0x000030, "Member 'FDependency::Unique' has a wrong offset!");
static_assert(offsetof(FDependency, Count) == 0x000034, "Member 'FDependency::Count' has a wrong offset!");

// ScriptStruct DeadByDaylight.BuiltLevelData
// 0x00B0 (0x00B0 - 0x0000)
struct FBuiltLevelData final
{
public:
	class FName                                   ThemeName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThemeWeather;                                      // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateThemes;                                  // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateWeather;                                 // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioThemeEvent;                                   // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioLimitPointEvent;                              // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioBank>            AudioThemeSoundBank;                               // 0x0048(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileCount;                                         // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDependency>                    Dependencies;                                      // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SpecialEventId;                                    // 0x00A0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBuiltLevelData) == 0x000008, "Wrong alignment on FBuiltLevelData");
static_assert(sizeof(FBuiltLevelData) == 0x0000B0, "Wrong size on FBuiltLevelData");
static_assert(offsetof(FBuiltLevelData, ThemeName) == 0x000000, "Member 'FBuiltLevelData::ThemeName' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, ThemeWeather) == 0x00000C, "Member 'FBuiltLevelData::ThemeWeather' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, AudioStateThemes) == 0x000018, "Member 'FBuiltLevelData::AudioStateThemes' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, AudioStateWeather) == 0x000024, "Member 'FBuiltLevelData::AudioStateWeather' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, AudioThemeEvent) == 0x000030, "Member 'FBuiltLevelData::AudioThemeEvent' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, AudioLimitPointEvent) == 0x00003C, "Member 'FBuiltLevelData::AudioLimitPointEvent' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, AudioThemeSoundBank) == 0x000048, "Member 'FBuiltLevelData::AudioThemeSoundBank' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, MapName) == 0x000078, "Member 'FBuiltLevelData::MapName' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, TileCount) == 0x000088, "Member 'FBuiltLevelData::TileCount' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, Dependencies) == 0x000090, "Member 'FBuiltLevelData::Dependencies' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, SpecialEventId) == 0x0000A0, "Member 'FBuiltLevelData::SpecialEventId' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesNodeCoordinates
// 0x0010 (0x0010 - 0x0000)
struct FArchivesNodeCoordinates final
{
public:
	double                                        X;                                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Y;                                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivesNodeCoordinates) == 0x000008, "Wrong alignment on FArchivesNodeCoordinates");
static_assert(sizeof(FArchivesNodeCoordinates) == 0x000010, "Wrong size on FArchivesNodeCoordinates");
static_assert(offsetof(FArchivesNodeCoordinates, X) == 0x000000, "Member 'FArchivesNodeCoordinates::X' has a wrong offset!");
static_assert(offsetof(FArchivesNodeCoordinates, Y) == 0x000008, "Member 'FArchivesNodeCoordinates::Y' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesQuestCondition
// 0x0020 (0x0020 - 0x0000)
struct FArchivesQuestCondition final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Value;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivesQuestCondition) == 0x000008, "Wrong alignment on FArchivesQuestCondition");
static_assert(sizeof(FArchivesQuestCondition) == 0x000020, "Wrong size on FArchivesQuestCondition");
static_assert(offsetof(FArchivesQuestCondition, Key) == 0x000000, "Member 'FArchivesQuestCondition::Key' has a wrong offset!");
static_assert(offsetof(FArchivesQuestCondition, Value) == 0x000010, "Member 'FArchivesQuestCondition::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesQuestEvent
// 0x0040 (0x0040 - 0x0000)
struct FArchivesQuestEvent final
{
public:
	class FString                                 QuestEventId;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Repetition;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Parameters;                                        // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Operation;                                         // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Parameters_IsSet;                                  // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Operation_IsSet;                                   // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesQuestEvent) == 0x000008, "Wrong alignment on FArchivesQuestEvent");
static_assert(sizeof(FArchivesQuestEvent) == 0x000040, "Wrong size on FArchivesQuestEvent");
static_assert(offsetof(FArchivesQuestEvent, QuestEventId) == 0x000000, "Member 'FArchivesQuestEvent::QuestEventId' has a wrong offset!");
static_assert(offsetof(FArchivesQuestEvent, Repetition) == 0x000010, "Member 'FArchivesQuestEvent::Repetition' has a wrong offset!");
static_assert(offsetof(FArchivesQuestEvent, Parameters) == 0x000018, "Member 'FArchivesQuestEvent::Parameters' has a wrong offset!");
static_assert(offsetof(FArchivesQuestEvent, Operation) == 0x000028, "Member 'FArchivesQuestEvent::Operation' has a wrong offset!");
static_assert(offsetof(FArchivesQuestEvent, Parameters_IsSet) == 0x000038, "Member 'FArchivesQuestEvent::Parameters_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesQuestEvent, Operation_IsSet) == 0x000039, "Member 'FArchivesQuestEvent::Operation_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesQuestSpecialBehaviour
// 0x0028 (0x0028 - 0x0000)
struct FArchivesQuestSpecialBehaviour final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Params;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Params_IsSet;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesQuestSpecialBehaviour) == 0x000008, "Wrong alignment on FArchivesQuestSpecialBehaviour");
static_assert(sizeof(FArchivesQuestSpecialBehaviour) == 0x000028, "Wrong size on FArchivesQuestSpecialBehaviour");
static_assert(offsetof(FArchivesQuestSpecialBehaviour, Id) == 0x000000, "Member 'FArchivesQuestSpecialBehaviour::Id' has a wrong offset!");
static_assert(offsetof(FArchivesQuestSpecialBehaviour, Params) == 0x000010, "Member 'FArchivesQuestSpecialBehaviour::Params' has a wrong offset!");
static_assert(offsetof(FArchivesQuestSpecialBehaviour, Params_IsSet) == 0x000020, "Member 'FArchivesQuestSpecialBehaviour::Params_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesObjective
// 0x0060 (0x0060 - 0x0000)
struct FArchivesObjective final
{
public:
	class FString                                 ObjectiveId;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ObjectiveId_IsSet;                                 // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncrementWithEventRepetitions;                     // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NeededProgression;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FArchivesQuestCondition>        Conditions;                                        // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Conditions_IsSet;                                  // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArchivesQuestEvent>            QuestEvent;                                        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          QuestEvent_IsSet;                                  // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArchivesQuestSpecialBehaviour> SpecialBehaviours;                                 // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SpecialBehaviours_IsSet;                           // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCommunityObjective;                              // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCommunityObjective_IsSet;                        // 0x005A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesObjective) == 0x000008, "Wrong alignment on FArchivesObjective");
static_assert(sizeof(FArchivesObjective) == 0x000060, "Wrong size on FArchivesObjective");
static_assert(offsetof(FArchivesObjective, ObjectiveId) == 0x000000, "Member 'FArchivesObjective::ObjectiveId' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, ObjectiveId_IsSet) == 0x000010, "Member 'FArchivesObjective::ObjectiveId_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, IncrementWithEventRepetitions) == 0x000011, "Member 'FArchivesObjective::IncrementWithEventRepetitions' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, NeededProgression) == 0x000014, "Member 'FArchivesObjective::NeededProgression' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, Conditions) == 0x000018, "Member 'FArchivesObjective::Conditions' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, Conditions_IsSet) == 0x000028, "Member 'FArchivesObjective::Conditions_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, QuestEvent) == 0x000030, "Member 'FArchivesObjective::QuestEvent' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, QuestEvent_IsSet) == 0x000040, "Member 'FArchivesObjective::QuestEvent_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, SpecialBehaviours) == 0x000048, "Member 'FArchivesObjective::SpecialBehaviours' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, SpecialBehaviours_IsSet) == 0x000058, "Member 'FArchivesObjective::SpecialBehaviours_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, IsCommunityObjective) == 0x000059, "Member 'FArchivesObjective::IsCommunityObjective' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, IsCommunityObjective_IsSet) == 0x00005A, "Member 'FArchivesObjective::IsCommunityObjective_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.RewardResponseItem
// 0x0030 (0x0030 - 0x0000)
struct FRewardResponseItem final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Type_IsSet;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Id;                                                // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRewardResponseItem) == 0x000008, "Wrong alignment on FRewardResponseItem");
static_assert(sizeof(FRewardResponseItem) == 0x000030, "Wrong size on FRewardResponseItem");
static_assert(offsetof(FRewardResponseItem, Type) == 0x000000, "Member 'FRewardResponseItem::Type' has a wrong offset!");
static_assert(offsetof(FRewardResponseItem, Type_IsSet) == 0x000010, "Member 'FRewardResponseItem::Type_IsSet' has a wrong offset!");
static_assert(offsetof(FRewardResponseItem, Id) == 0x000018, "Member 'FRewardResponseItem::Id' has a wrong offset!");
static_assert(offsetof(FRewardResponseItem, Amount) == 0x000028, "Member 'FRewardResponseItem::Amount' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesNodeDefinition
// 0x00C8 (0x00C8 - 0x0000)
struct FArchivesNodeDefinition final
{
public:
	class FString                                 ClientInfoId;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FArchivesNodeCoordinates               Coordinates;                                       // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Neighbors;                                         // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 NodeType;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FArchivesObjective> Objectives;                                       // 0x0040(0x0050)(NativeAccessSpecifierPublic)
	bool                                          Objectives_IsSet;                                  // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Journal;                                           // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Journal_IsSet;                                     // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Reward;                                            // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Reward_IsSet;                                      // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesNodeDefinition) == 0x000008, "Wrong alignment on FArchivesNodeDefinition");
static_assert(sizeof(FArchivesNodeDefinition) == 0x0000C8, "Wrong size on FArchivesNodeDefinition");
static_assert(offsetof(FArchivesNodeDefinition, ClientInfoId) == 0x000000, "Member 'FArchivesNodeDefinition::ClientInfoId' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Coordinates) == 0x000010, "Member 'FArchivesNodeDefinition::Coordinates' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Neighbors) == 0x000020, "Member 'FArchivesNodeDefinition::Neighbors' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, NodeType) == 0x000030, "Member 'FArchivesNodeDefinition::NodeType' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Objectives) == 0x000040, "Member 'FArchivesNodeDefinition::Objectives' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Objectives_IsSet) == 0x000090, "Member 'FArchivesNodeDefinition::Objectives_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Journal) == 0x000098, "Member 'FArchivesNodeDefinition::Journal' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Journal_IsSet) == 0x0000A8, "Member 'FArchivesNodeDefinition::Journal_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Reward) == 0x0000B0, "Member 'FArchivesNodeDefinition::Reward' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Reward_IsSet) == 0x0000C0, "Member 'FArchivesNodeDefinition::Reward_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.NewsContentDetails
// 0x00B8 (0x00B8 - 0x0000)
struct FNewsContentDetails final
{
public:
	int32                                         Weight;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Version;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ImagePath_IsSet;                                   // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DwnImagePath;                                      // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DwnImagePath_IsSet;                                // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ImageHeight;                                       // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ImageHeight_IsSet;                                 // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHidden;                                          // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHidden_IsSet;                                    // 0x006A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x21];                                      // 0x006B(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Type;                                              // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Type_IsSet;                                        // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ContentTags;                                       // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 StartDate;                                         // 0x00A8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FNewsContentDetails) == 0x000008, "Wrong alignment on FNewsContentDetails");
static_assert(sizeof(FNewsContentDetails) == 0x0000B8, "Wrong size on FNewsContentDetails");
static_assert(offsetof(FNewsContentDetails, Weight) == 0x000000, "Member 'FNewsContentDetails::Weight' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, Version) == 0x000008, "Member 'FNewsContentDetails::Version' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, Title) == 0x000018, "Member 'FNewsContentDetails::Title' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, Description) == 0x000028, "Member 'FNewsContentDetails::Description' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, ImagePath) == 0x000038, "Member 'FNewsContentDetails::ImagePath' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, ImagePath_IsSet) == 0x000048, "Member 'FNewsContentDetails::ImagePath_IsSet' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, DwnImagePath) == 0x000050, "Member 'FNewsContentDetails::DwnImagePath' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, DwnImagePath_IsSet) == 0x000060, "Member 'FNewsContentDetails::DwnImagePath_IsSet' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, ImageHeight) == 0x000064, "Member 'FNewsContentDetails::ImageHeight' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, ImageHeight_IsSet) == 0x000068, "Member 'FNewsContentDetails::ImageHeight_IsSet' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, IsHidden) == 0x000069, "Member 'FNewsContentDetails::IsHidden' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, IsHidden_IsSet) == 0x00006A, "Member 'FNewsContentDetails::IsHidden_IsSet' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, Type) == 0x00008C, "Member 'FNewsContentDetails::Type' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, Type_IsSet) == 0x000090, "Member 'FNewsContentDetails::Type_IsSet' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, ContentTags) == 0x000098, "Member 'FNewsContentDetails::ContentTags' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, StartDate) == 0x0000A8, "Member 'FNewsContentDetails::StartDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractionArray
// 0x0010 (0x0010 - 0x0000)
struct FInteractionArray final
{
public:
	TArray<TWeakObjectPtr<class UInteractionDefinition>> _interactions;                              // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInteractionArray) == 0x000008, "Wrong alignment on FInteractionArray");
static_assert(sizeof(FInteractionArray) == 0x000010, "Wrong size on FInteractionArray");
static_assert(offsetof(FInteractionArray, _interactions) == 0x000000, "Member 'FInteractionArray::_interactions' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameEventData
// 0x0028 (0x0028 - 0x0000)
struct FGameEventData final
{
public:
	class ADBDPlayer*                             Instigator;                                        // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomValue;                                       // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CustomObjectParameter;                             // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomIntValue;                                    // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameEventData) == 0x000008, "Wrong alignment on FGameEventData");
static_assert(sizeof(FGameEventData) == 0x000028, "Wrong size on FGameEventData");
static_assert(offsetof(FGameEventData, Instigator) == 0x000000, "Member 'FGameEventData::Instigator' has a wrong offset!");
static_assert(offsetof(FGameEventData, Target) == 0x000008, "Member 'FGameEventData::Target' has a wrong offset!");
static_assert(offsetof(FGameEventData, CustomValue) == 0x000010, "Member 'FGameEventData::CustomValue' has a wrong offset!");
static_assert(offsetof(FGameEventData, CustomObjectParameter) == 0x000018, "Member 'FGameEventData::CustomObjectParameter' has a wrong offset!");
static_assert(offsetof(FGameEventData, CustomIntValue) == 0x000020, "Member 'FGameEventData::CustomIntValue' has a wrong offset!");

// ScriptStruct DeadByDaylight.AssignedPerkProperties
// 0x0014 (0x0014 - 0x0000)
struct FAssignedPerkProperties final
{
public:
	class FName                                   PerkId;                                            // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkLevel;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeachable;                                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssignedPerkProperties) == 0x000004, "Wrong alignment on FAssignedPerkProperties");
static_assert(sizeof(FAssignedPerkProperties) == 0x000014, "Wrong size on FAssignedPerkProperties");
static_assert(offsetof(FAssignedPerkProperties, PerkId) == 0x000000, "Member 'FAssignedPerkProperties::PerkId' has a wrong offset!");
static_assert(offsetof(FAssignedPerkProperties, PerkLevel) == 0x00000C, "Member 'FAssignedPerkProperties::PerkLevel' has a wrong offset!");
static_assert(offsetof(FAssignedPerkProperties, IsTeachable) == 0x000010, "Member 'FAssignedPerkProperties::IsTeachable' has a wrong offset!");

// ScriptStruct DeadByDaylight.RoleDropdown
// 0x0002 (0x0002 - 0x0000)
struct FRoleDropdown
{
public:
	bool                                          ShowRoleSelection;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoleDropdown) == 0x000001, "Wrong alignment on FRoleDropdown");
static_assert(sizeof(FRoleDropdown) == 0x000002, "Wrong size on FRoleDropdown");
static_assert(offsetof(FRoleDropdown, ShowRoleSelection) == 0x000000, "Member 'FRoleDropdown::ShowRoleSelection' has a wrong offset!");
static_assert(offsetof(FRoleDropdown, Role) == 0x000001, "Member 'FRoleDropdown::Role' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterDropdown
// 0x0006 (0x0008 - 0x0002)
struct FCharacterDropdown : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterID;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDropdown) == 0x000004, "Wrong alignment on FCharacterDropdown");
static_assert(sizeof(FCharacterDropdown) == 0x000008, "Wrong size on FCharacterDropdown");
static_assert(offsetof(FCharacterDropdown, CharacterID) == 0x000004, "Member 'FCharacterDropdown::CharacterID' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterCustomizationDropdown
// 0x0054 (0x005C - 0x0008)
struct FCharacterCustomizationDropdown final : public FCharacterDropdown
{
public:
	class FName                                   OutfitId;                                          // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorHead;                                      // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorTorso;                                     // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorLegs;                                      // 0x002C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerHead;                                        // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerBody;                                        // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerWeapon;                                      // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCustomizationDropdown) == 0x000004, "Wrong alignment on FCharacterCustomizationDropdown");
static_assert(sizeof(FCharacterCustomizationDropdown) == 0x00005C, "Wrong size on FCharacterCustomizationDropdown");
static_assert(offsetof(FCharacterCustomizationDropdown, OutfitId) == 0x000008, "Member 'FCharacterCustomizationDropdown::OutfitId' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, SurvivorHead) == 0x000014, "Member 'FCharacterCustomizationDropdown::SurvivorHead' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, SurvivorTorso) == 0x000020, "Member 'FCharacterCustomizationDropdown::SurvivorTorso' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, SurvivorLegs) == 0x00002C, "Member 'FCharacterCustomizationDropdown::SurvivorLegs' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, KillerHead) == 0x000038, "Member 'FCharacterCustomizationDropdown::KillerHead' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, KillerBody) == 0x000044, "Member 'FCharacterCustomizationDropdown::KillerBody' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, KillerWeapon) == 0x000050, "Member 'FCharacterCustomizationDropdown::KillerWeapon' has a wrong offset!");

// ScriptStruct DeadByDaylight.SelectedOffering
// 0x0010 (0x0010 - 0x0000)
struct FSelectedOffering final
{
public:
	int32                                         ownerId;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OfferingName;                                      // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectedOffering) == 0x000004, "Wrong alignment on FSelectedOffering");
static_assert(sizeof(FSelectedOffering) == 0x000010, "Wrong size on FSelectedOffering");
static_assert(offsetof(FSelectedOffering, ownerId) == 0x000000, "Member 'FSelectedOffering::ownerId' has a wrong offset!");
static_assert(offsetof(FSelectedOffering, OfferingName) == 0x000004, "Member 'FSelectedOffering::OfferingName' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerFloatTuple
// 0x0010 (0x0010 - 0x0000)
struct FPlayerFloatTuple final
{
public:
	class ACharacter*                             Player;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerFloatTuple) == 0x000008, "Wrong alignment on FPlayerFloatTuple");
static_assert(sizeof(FPlayerFloatTuple) == 0x000010, "Wrong size on FPlayerFloatTuple");
static_assert(offsetof(FPlayerFloatTuple, Player) == 0x000000, "Member 'FPlayerFloatTuple::Player' has a wrong offset!");
static_assert(offsetof(FPlayerFloatTuple, Value) == 0x000008, "Member 'FPlayerFloatTuple::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDJoinParams
// 0x0001 (0x0001 - 0x0000)
struct FDBDJoinParams final
{
public:
	EGameType                                     GameType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDJoinParams) == 0x000001, "Wrong alignment on FDBDJoinParams");
static_assert(sizeof(FDBDJoinParams) == 0x000001, "Wrong size on FDBDJoinParams");
static_assert(offsetof(FDBDJoinParams, GameType) == 0x000000, "Member 'FDBDJoinParams::GameType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScoreEventData
// 0x0018 (0x0018 - 0x0000)
struct FScoreEventData final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentToAward;                                    // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CustomObjectParameter;                             // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreEventData) == 0x000008, "Wrong alignment on FScoreEventData");
static_assert(sizeof(FScoreEventData) == 0x000018, "Wrong size on FScoreEventData");
static_assert(offsetof(FScoreEventData, Target) == 0x000000, "Member 'FScoreEventData::Target' has a wrong offset!");
static_assert(offsetof(FScoreEventData, PercentToAward) == 0x000008, "Member 'FScoreEventData::PercentToAward' has a wrong offset!");
static_assert(offsetof(FScoreEventData, CustomObjectParameter) == 0x000010, "Member 'FScoreEventData::CustomObjectParameter' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveQuestSpecialBehaviour
// 0x0030 (0x0048 - 0x0018)
struct FArchiveQuestSpecialBehaviour final : public FDBDTableRowBaseWithId
{
public:
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EContextualType                               Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnObjectId;                                     // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdditiveBehaviour                            AdditiveBehaviour;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStackingBehaviours                           StackableBehaviour;                                // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOwnershipBehaviour                           OwnershipBehaviour;                                // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnQuantity;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchiveQuestSpecialBehaviour) == 0x000008, "Wrong alignment on FArchiveQuestSpecialBehaviour");
static_assert(sizeof(FArchiveQuestSpecialBehaviour) == 0x000048, "Wrong size on FArchiveQuestSpecialBehaviour");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, Description) == 0x000018, "Member 'FArchiveQuestSpecialBehaviour::Description' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, Type) == 0x000030, "Member 'FArchiveQuestSpecialBehaviour::Type' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, SpawnObjectId) == 0x000034, "Member 'FArchiveQuestSpecialBehaviour::SpawnObjectId' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, AdditiveBehaviour) == 0x000040, "Member 'FArchiveQuestSpecialBehaviour::AdditiveBehaviour' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, StackableBehaviour) == 0x000041, "Member 'FArchiveQuestSpecialBehaviour::StackableBehaviour' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, OwnershipBehaviour) == 0x000042, "Member 'FArchiveQuestSpecialBehaviour::OwnershipBehaviour' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, SpawnQuantity) == 0x000044, "Member 'FArchiveQuestSpecialBehaviour::SpawnQuantity' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialBehaviourObjectsInfo
// 0x0014 (0x0014 - 0x0000)
struct FSpecialBehaviourObjectsInfo final
{
public:
	class FName                                   SpecialBehaviourId;                                // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountRequired;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesInteractedWith;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialBehaviourObjectsInfo) == 0x000004, "Wrong alignment on FSpecialBehaviourObjectsInfo");
static_assert(sizeof(FSpecialBehaviourObjectsInfo) == 0x000014, "Wrong size on FSpecialBehaviourObjectsInfo");
static_assert(offsetof(FSpecialBehaviourObjectsInfo, SpecialBehaviourId) == 0x000000, "Member 'FSpecialBehaviourObjectsInfo::SpecialBehaviourId' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourObjectsInfo, AmountRequired) == 0x00000C, "Member 'FSpecialBehaviourObjectsInfo::AmountRequired' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourObjectsInfo, TimesInteractedWith) == 0x000010, "Member 'FSpecialBehaviourObjectsInfo::TimesInteractedWith' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRitualSaveData
// 0x0008 (0x0008 - 0x0000)
struct FDailyRitualSaveData final
{
public:
	struct FDateTime                              LastRitualPopupDate;                               // 0x0000(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRitualSaveData) == 0x000008, "Wrong alignment on FDailyRitualSaveData");
static_assert(sizeof(FDailyRitualSaveData) == 0x000008, "Wrong size on FDailyRitualSaveData");
static_assert(offsetof(FDailyRitualSaveData, LastRitualPopupDate) == 0x000000, "Member 'FDailyRitualSaveData::LastRitualPopupDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.ParentItemIDs
// 0x0018 (0x0018 - 0x0000)
struct FParentItemIDs final
{
public:
	bool                                          MatchAnyItemID;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ItemIDs;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParentItemIDs) == 0x000008, "Wrong alignment on FParentItemIDs");
static_assert(sizeof(FParentItemIDs) == 0x000018, "Wrong size on FParentItemIDs");
static_assert(offsetof(FParentItemIDs, MatchAnyItemID) == 0x000000, "Member 'FParentItemIDs::MatchAnyItemID' has a wrong offset!");
static_assert(offsetof(FParentItemIDs, ItemIDs) == 0x000008, "Member 'FParentItemIDs::ItemIDs' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemAvailability
// 0x0030 (0x0030 - 0x0000)
struct FItemAvailability final
{
public:
	EItemAvailability                             itemAvailability;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DLCId;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CloudInventoryId;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CommunityId;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FItemAvailability) == 0x000008, "Wrong alignment on FItemAvailability");
static_assert(sizeof(FItemAvailability) == 0x000030, "Wrong size on FItemAvailability");
static_assert(offsetof(FItemAvailability, itemAvailability) == 0x000000, "Member 'FItemAvailability::itemAvailability' has a wrong offset!");
static_assert(offsetof(FItemAvailability, DLCId) == 0x000008, "Member 'FItemAvailability::DLCId' has a wrong offset!");
static_assert(offsetof(FItemAvailability, CloudInventoryId) == 0x000018, "Member 'FItemAvailability::CloudInventoryId' has a wrong offset!");
static_assert(offsetof(FItemAvailability, CommunityId) == 0x000020, "Member 'FItemAvailability::CommunityId' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomTransformation
// 0x0014 (0x0014 - 0x0000)
struct FCustomTransformation final
{
public:
	bool                                          UseCustomTransformation;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CustomScale;                                       // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              CustomTranslation;                                 // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCustomTransformation) == 0x000004, "Wrong alignment on FCustomTransformation");
static_assert(sizeof(FCustomTransformation) == 0x000014, "Wrong size on FCustomTransformation");
static_assert(offsetof(FCustomTransformation, UseCustomTransformation) == 0x000000, "Member 'FCustomTransformation::UseCustomTransformation' has a wrong offset!");
static_assert(offsetof(FCustomTransformation, CustomScale) == 0x000004, "Member 'FCustomTransformation::CustomScale' has a wrong offset!");
static_assert(offsetof(FCustomTransformation, CustomTranslation) == 0x00000C, "Member 'FCustomTransformation::CustomTranslation' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemUIData
// 0x00C0 (0x00C0 - 0x0000)
struct FItemUIData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TArray<class FString>                         IconFilePathList;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UTexture2D>>      IconAssetList;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FCustomTransformation                  CustomTransformation;                              // 0x0050(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint32                                        PlatformsUnlicensedNameOverride;                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        PlatformsUnlicensedDescriptionOverride;            // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        PlatformsForIconUnlicensedFilePathListOverride;    // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         IconUnlicensedFilePathListOverride;                // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          LicenseExpirationOverride;                         // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayNameUnlicensedOverride;                     // 0x0088(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   DescriptionUnlicensedOverride;                     // 0x00A0(0x0018)(Edit, NativeAccessSpecifierPrivate)
	int32                                         AssociatedCharacterIndex;                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemUIData) == 0x000008, "Wrong alignment on FItemUIData");
static_assert(sizeof(FItemUIData) == 0x0000C0, "Wrong size on FItemUIData");
static_assert(offsetof(FItemUIData, DisplayName) == 0x000000, "Member 'FItemUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FItemUIData, Description) == 0x000018, "Member 'FItemUIData::Description' has a wrong offset!");
static_assert(offsetof(FItemUIData, IconFilePathList) == 0x000030, "Member 'FItemUIData::IconFilePathList' has a wrong offset!");
static_assert(offsetof(FItemUIData, IconAssetList) == 0x000040, "Member 'FItemUIData::IconAssetList' has a wrong offset!");
static_assert(offsetof(FItemUIData, CustomTransformation) == 0x000050, "Member 'FItemUIData::CustomTransformation' has a wrong offset!");
static_assert(offsetof(FItemUIData, PlatformsUnlicensedNameOverride) == 0x000064, "Member 'FItemUIData::PlatformsUnlicensedNameOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, PlatformsUnlicensedDescriptionOverride) == 0x000068, "Member 'FItemUIData::PlatformsUnlicensedDescriptionOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, PlatformsForIconUnlicensedFilePathListOverride) == 0x00006C, "Member 'FItemUIData::PlatformsForIconUnlicensedFilePathListOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, IconUnlicensedFilePathListOverride) == 0x000070, "Member 'FItemUIData::IconUnlicensedFilePathListOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, LicenseExpirationOverride) == 0x000080, "Member 'FItemUIData::LicenseExpirationOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, DisplayNameUnlicensedOverride) == 0x000088, "Member 'FItemUIData::DisplayNameUnlicensedOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, DescriptionUnlicensedOverride) == 0x0000A0, "Member 'FItemUIData::DescriptionUnlicensedOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, AssociatedCharacterIndex) == 0x0000B8, "Member 'FItemUIData::AssociatedCharacterIndex' has a wrong offset!");

// ScriptStruct DeadByDaylight.BaseItemData
// 0x0160 (0x0168 - 0x0008)
struct FBaseItemData : public FDBDTableRowBase
{
public:
	EInventoryItemType                            Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemUIData                            UIData;                                            // 0x0010(0x00C0)(Edit, NativeAccessSpecifierPublic)
	class FText                                   GenericDisplayName;                                // 0x00D0(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ItemBlueprint;                                     // 0x00E8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDBDPrimaryDataAsset>    AssetData;                                         // 0x0118(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemId;                                            // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x10];                                     // 0x0158(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseItemData) == 0x000008, "Wrong alignment on FBaseItemData");
static_assert(sizeof(FBaseItemData) == 0x000168, "Wrong size on FBaseItemData");
static_assert(offsetof(FBaseItemData, Type) == 0x000008, "Member 'FBaseItemData::Type' has a wrong offset!");
static_assert(offsetof(FBaseItemData, UIData) == 0x000010, "Member 'FBaseItemData::UIData' has a wrong offset!");
static_assert(offsetof(FBaseItemData, GenericDisplayName) == 0x0000D0, "Member 'FBaseItemData::GenericDisplayName' has a wrong offset!");
static_assert(offsetof(FBaseItemData, ItemBlueprint) == 0x0000E8, "Member 'FBaseItemData::ItemBlueprint' has a wrong offset!");
static_assert(offsetof(FBaseItemData, AssetData) == 0x000118, "Member 'FBaseItemData::AssetData' has a wrong offset!");
static_assert(offsetof(FBaseItemData, ItemId) == 0x000148, "Member 'FBaseItemData::ItemId' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemData
// 0x0080 (0x01E8 - 0x0168)
struct FItemData : public FBaseItemData
{
public:
	TSoftObjectPtr<class USkeletalMesh>           ItemMesh;                                          // 0x0168(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemHandPosition                             HandPosition;                                      // 0x0198(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x0199(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x019A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Inventory;                                         // 0x019B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Chest;                                             // 0x019C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKillerAbilities                              RequiredKillerAbility;                             // 0x019D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19E[0x2];                                      // 0x019E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemAvailability                      Availability;                                      // 0x01A0(0x0030)(Edit, NativeAccessSpecifierPublic)
	bool                                          IsInNonViolentBuild;                               // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableInAtlantaBuild;                         // 0x01D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AntiDLC;                                           // 0x01D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bloodweb;                                          // 0x01D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanKeepInLoadout;                                  // 0x01D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBotSupported;                                    // 0x01D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D6[0x2];                                      // 0x01D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventId;                                           // 0x01D8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseAfterEventEnd;                               // 0x01E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadoutItemType                              ItemType;                                          // 0x01E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E6[0x2];                                      // 0x01E6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemData) == 0x000008, "Wrong alignment on FItemData");
static_assert(sizeof(FItemData) == 0x0001E8, "Wrong size on FItemData");
static_assert(offsetof(FItemData, ItemMesh) == 0x000168, "Member 'FItemData::ItemMesh' has a wrong offset!");
static_assert(offsetof(FItemData, HandPosition) == 0x000198, "Member 'FItemData::HandPosition' has a wrong offset!");
static_assert(offsetof(FItemData, Role) == 0x000199, "Member 'FItemData::Role' has a wrong offset!");
static_assert(offsetof(FItemData, Rarity) == 0x00019A, "Member 'FItemData::Rarity' has a wrong offset!");
static_assert(offsetof(FItemData, Inventory) == 0x00019B, "Member 'FItemData::Inventory' has a wrong offset!");
static_assert(offsetof(FItemData, Chest) == 0x00019C, "Member 'FItemData::Chest' has a wrong offset!");
static_assert(offsetof(FItemData, RequiredKillerAbility) == 0x00019D, "Member 'FItemData::RequiredKillerAbility' has a wrong offset!");
static_assert(offsetof(FItemData, Availability) == 0x0001A0, "Member 'FItemData::Availability' has a wrong offset!");
static_assert(offsetof(FItemData, IsInNonViolentBuild) == 0x0001D0, "Member 'FItemData::IsInNonViolentBuild' has a wrong offset!");
static_assert(offsetof(FItemData, IsAvailableInAtlantaBuild) == 0x0001D1, "Member 'FItemData::IsAvailableInAtlantaBuild' has a wrong offset!");
static_assert(offsetof(FItemData, AntiDLC) == 0x0001D2, "Member 'FItemData::AntiDLC' has a wrong offset!");
static_assert(offsetof(FItemData, Bloodweb) == 0x0001D3, "Member 'FItemData::Bloodweb' has a wrong offset!");
static_assert(offsetof(FItemData, CanKeepInLoadout) == 0x0001D4, "Member 'FItemData::CanKeepInLoadout' has a wrong offset!");
static_assert(offsetof(FItemData, IsBotSupported) == 0x0001D5, "Member 'FItemData::IsBotSupported' has a wrong offset!");
static_assert(offsetof(FItemData, EventId) == 0x0001D8, "Member 'FItemData::EventId' has a wrong offset!");
static_assert(offsetof(FItemData, CanUseAfterEventEnd) == 0x0001E4, "Member 'FItemData::CanUseAfterEventEnd' has a wrong offset!");
static_assert(offsetof(FItemData, ItemType) == 0x0001E5, "Member 'FItemData::ItemType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemAddonProperties
// 0x0058 (0x0240 - 0x01E8)
struct FItemAddonProperties final : public FItemData
{
public:
	TSoftClassPtr<class UClass>                   ItemAddonBlueprint;                                // 0x01E8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FParentItemIDs                         ParentItem;                                        // 0x0218(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           PreLevelGenerationModifierID;                      // 0x0230(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemAddonProperties) == 0x000008, "Wrong alignment on FItemAddonProperties");
static_assert(sizeof(FItemAddonProperties) == 0x000240, "Wrong size on FItemAddonProperties");
static_assert(offsetof(FItemAddonProperties, ItemAddonBlueprint) == 0x0001E8, "Member 'FItemAddonProperties::ItemAddonBlueprint' has a wrong offset!");
static_assert(offsetof(FItemAddonProperties, ParentItem) == 0x000218, "Member 'FItemAddonProperties::ParentItem' has a wrong offset!");
static_assert(offsetof(FItemAddonProperties, PreLevelGenerationModifierID) == 0x000230, "Member 'FItemAddonProperties::PreLevelGenerationModifierID' has a wrong offset!");

// ScriptStruct DeadByDaylight.AkObservedPlayerSoundLoop
// 0x0018 (0x0040 - 0x0028)
struct FAkObservedPlayerSoundLoop final : public FAkSoundLoop
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPlayerPerspectiveComponent> _perspectiveComponent;                         // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAkObservedPlayerSoundLoop) == 0x000008, "Wrong alignment on FAkObservedPlayerSoundLoop");
static_assert(sizeof(FAkObservedPlayerSoundLoop) == 0x000040, "Wrong size on FAkObservedPlayerSoundLoop");
static_assert(offsetof(FAkObservedPlayerSoundLoop, _perspectiveComponent) == 0x000038, "Member 'FAkObservedPlayerSoundLoop::_perspectiveComponent' has a wrong offset!");

// ScriptStruct DeadByDaylight.EscapeTypeObjects
// 0x0018 (0x0018 - 0x0000)
struct FEscapeTypeObjects final
{
public:
	EscapeStrategyType                            Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           EscapeObjects;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEscapeTypeObjects) == 0x000008, "Wrong alignment on FEscapeTypeObjects");
static_assert(sizeof(FEscapeTypeObjects) == 0x000018, "Wrong size on FEscapeTypeObjects");
static_assert(offsetof(FEscapeTypeObjects, Type) == 0x000000, "Member 'FEscapeTypeObjects::Type' has a wrong offset!");
static_assert(offsetof(FEscapeTypeObjects, EscapeObjects) == 0x000008, "Member 'FEscapeTypeObjects::EscapeObjects' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingData
// 0x0018 (0x0018 - 0x0000)
struct FOfferingData final
{
public:
	bool                                          OfferingReady;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSelectedOffering>              Offerings;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingData) == 0x000008, "Wrong alignment on FOfferingData");
static_assert(sizeof(FOfferingData) == 0x000018, "Wrong size on FOfferingData");
static_assert(offsetof(FOfferingData, OfferingReady) == 0x000000, "Member 'FOfferingData::OfferingReady' has a wrong offset!");
static_assert(offsetof(FOfferingData, Offerings) == 0x000008, "Member 'FOfferingData::Offerings' has a wrong offset!");

// ScriptStruct DeadByDaylight.MaterialReplacerData
// 0x0060 (0x0060 - 0x0000)
struct FMaterialReplacerData final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      From;                                              // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      To;                                                // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialReplacerData) == 0x000008, "Wrong alignment on FMaterialReplacerData");
static_assert(sizeof(FMaterialReplacerData) == 0x000060, "Wrong size on FMaterialReplacerData");
static_assert(offsetof(FMaterialReplacerData, From) == 0x000000, "Member 'FMaterialReplacerData::From' has a wrong offset!");
static_assert(offsetof(FMaterialReplacerData, To) == 0x000030, "Member 'FMaterialReplacerData::To' has a wrong offset!");

// ScriptStruct DeadByDaylight.MaterialReplacerArray
// 0x0010 (0x0010 - 0x0000)
struct FMaterialReplacerArray final
{
public:
	TArray<struct FMaterialReplacerData>          MaterialsMap;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialReplacerArray) == 0x000008, "Wrong alignment on FMaterialReplacerArray");
static_assert(sizeof(FMaterialReplacerArray) == 0x000010, "Wrong size on FMaterialReplacerArray");
static_assert(offsetof(FMaterialReplacerArray, MaterialsMap) == 0x000000, "Member 'FMaterialReplacerArray::MaterialsMap' has a wrong offset!");

// ScriptStruct DeadByDaylight.ConditionalMaterialReplacer
// 0x0060 (0x0060 - 0x0000)
struct FConditionalMaterialReplacer final
{
public:
	class FName                                   ItemTag;                                           // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FMaterialReplacerArray> ConditionalMaterials;                           // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalMaterialReplacer) == 0x000008, "Wrong alignment on FConditionalMaterialReplacer");
static_assert(sizeof(FConditionalMaterialReplacer) == 0x000060, "Wrong size on FConditionalMaterialReplacer");
static_assert(offsetof(FConditionalMaterialReplacer, ItemTag) == 0x000000, "Member 'FConditionalMaterialReplacer::ItemTag' has a wrong offset!");
static_assert(offsetof(FConditionalMaterialReplacer, ConditionalMaterials) == 0x000010, "Member 'FConditionalMaterialReplacer::ConditionalMaterials' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractionPlayerProperties
// 0x0050 (0x0050 - 0x0000)
struct FInteractionPlayerProperties final
{
public:
	struct FVector_NetQuantize                    AverageVelocityAtStart;                            // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    PlayerPositionAtStart;                             // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerRotationAtStart;                             // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADBDPlayer>              Requester;                                         // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    SnapPositionAtStart;                               // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SnapRotationAtStart;                               // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SnapDistanceAtStart;                               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapTimeAtStart;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSnapPosition;                                // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionPlayerProperties) == 0x000004, "Wrong alignment on FInteractionPlayerProperties");
static_assert(sizeof(FInteractionPlayerProperties) == 0x000050, "Wrong size on FInteractionPlayerProperties");
static_assert(offsetof(FInteractionPlayerProperties, AverageVelocityAtStart) == 0x000000, "Member 'FInteractionPlayerProperties::AverageVelocityAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, PlayerPositionAtStart) == 0x00000C, "Member 'FInteractionPlayerProperties::PlayerPositionAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, PlayerRotationAtStart) == 0x000018, "Member 'FInteractionPlayerProperties::PlayerRotationAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, Requester) == 0x000024, "Member 'FInteractionPlayerProperties::Requester' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, SnapPositionAtStart) == 0x00002C, "Member 'FInteractionPlayerProperties::SnapPositionAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, SnapRotationAtStart) == 0x000038, "Member 'FInteractionPlayerProperties::SnapRotationAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, SnapDistanceAtStart) == 0x000044, "Member 'FInteractionPlayerProperties::SnapDistanceAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, SnapTimeAtStart) == 0x000048, "Member 'FInteractionPlayerProperties::SnapTimeAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, ShouldSnapPosition) == 0x00004C, "Member 'FInteractionPlayerProperties::ShouldSnapPosition' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualRewardUIData
// 0x0020 (0x0020 - 0x0000)
struct FAtlantaRitualRewardUIData final
{
public:
	EAtlantaRitualRewardUIType                    Type;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Quantity;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFilePath;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaRitualRewardUIData) == 0x000008, "Wrong alignment on FAtlantaRitualRewardUIData");
static_assert(sizeof(FAtlantaRitualRewardUIData) == 0x000020, "Wrong size on FAtlantaRitualRewardUIData");
static_assert(offsetof(FAtlantaRitualRewardUIData, Type) == 0x000000, "Member 'FAtlantaRitualRewardUIData::Type' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualRewardUIData, Quantity) == 0x000004, "Member 'FAtlantaRitualRewardUIData::Quantity' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualRewardUIData, IconFilePath) == 0x000008, "Member 'FAtlantaRitualRewardUIData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualRewardUIData, Rarity) == 0x000018, "Member 'FAtlantaRitualRewardUIData::Rarity' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaSubRitualUIData
// 0x0018 (0x0018 - 0x0000)
struct FAtlantaSubRitualUIData final
{
public:
	class FString                                 Description;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetNumber;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentNumber;                                     // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaSubRitualUIData) == 0x000008, "Wrong alignment on FAtlantaSubRitualUIData");
static_assert(sizeof(FAtlantaSubRitualUIData) == 0x000018, "Wrong size on FAtlantaSubRitualUIData");
static_assert(offsetof(FAtlantaSubRitualUIData, Description) == 0x000000, "Member 'FAtlantaSubRitualUIData::Description' has a wrong offset!");
static_assert(offsetof(FAtlantaSubRitualUIData, TargetNumber) == 0x000010, "Member 'FAtlantaSubRitualUIData::TargetNumber' has a wrong offset!");
static_assert(offsetof(FAtlantaSubRitualUIData, CurrentNumber) == 0x000014, "Member 'FAtlantaSubRitualUIData::CurrentNumber' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualUIData
// 0x0068 (0x0068 - 0x0000)
struct FAtlantaRitualUIData final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAltantaRitualUIType                          Type;                                              // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFilePath;                                      // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClaimed;                                         // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressPercentage;                                // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RefreshPrice;                                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlantaRitualRewardUIData>     Rewards;                                           // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtlantaSubRitualUIData>        SubRituals;                                        // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRitualUIData) == 0x000008, "Wrong alignment on FAtlantaRitualUIData");
static_assert(sizeof(FAtlantaRitualUIData) == 0x000068, "Wrong size on FAtlantaRitualUIData");
static_assert(offsetof(FAtlantaRitualUIData, ID) == 0x000000, "Member 'FAtlantaRitualUIData::ID' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, Type) == 0x000004, "Member 'FAtlantaRitualUIData::Type' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, Title) == 0x000008, "Member 'FAtlantaRitualUIData::Title' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, Description) == 0x000018, "Member 'FAtlantaRitualUIData::Description' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, IconFilePath) == 0x000028, "Member 'FAtlantaRitualUIData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, IsNew) == 0x000038, "Member 'FAtlantaRitualUIData::IsNew' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, IsClaimed) == 0x000039, "Member 'FAtlantaRitualUIData::IsClaimed' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, ProgressPercentage) == 0x00003C, "Member 'FAtlantaRitualUIData::ProgressPercentage' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, RefreshPrice) == 0x000040, "Member 'FAtlantaRitualUIData::RefreshPrice' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, Rewards) == 0x000048, "Member 'FAtlantaRitualUIData::Rewards' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, SubRituals) == 0x000058, "Member 'FAtlantaRitualUIData::SubRituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualsUIScreenData
// 0x0030 (0x0030 - 0x0000)
struct FAtlantaRitualsUIScreenData final
{
public:
	struct FDateTime                              DailyRefreshTime;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              WeeklyRefreshTime;                                 // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAtlantaRitualUIData>           DailyRituals;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtlantaRitualUIData>           WeeklyRituals;                                     // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRitualsUIScreenData) == 0x000008, "Wrong alignment on FAtlantaRitualsUIScreenData");
static_assert(sizeof(FAtlantaRitualsUIScreenData) == 0x000030, "Wrong size on FAtlantaRitualsUIScreenData");
static_assert(offsetof(FAtlantaRitualsUIScreenData, DailyRefreshTime) == 0x000000, "Member 'FAtlantaRitualsUIScreenData::DailyRefreshTime' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualsUIScreenData, WeeklyRefreshTime) == 0x000008, "Member 'FAtlantaRitualsUIScreenData::WeeklyRefreshTime' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualsUIScreenData, DailyRituals) == 0x000010, "Member 'FAtlantaRitualsUIScreenData::DailyRituals' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualsUIScreenData, WeeklyRituals) == 0x000020, "Member 'FAtlantaRitualsUIScreenData::WeeklyRituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.FearMarketItemInstance
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FFearMarketItemInstance final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodpointConversion;                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Purchased;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiscountPercentage;                                // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFearMarketItemInstance) == 0x000008, "Wrong alignment on FFearMarketItemInstance");
static_assert(sizeof(FFearMarketItemInstance) == 0x000030, "Wrong size on FFearMarketItemInstance");
static_assert(offsetof(FFearMarketItemInstance, ItemId) == 0x000000, "Member 'FFearMarketItemInstance::ItemId' has a wrong offset!");
static_assert(offsetof(FFearMarketItemInstance, BloodpointConversion) == 0x00000C, "Member 'FFearMarketItemInstance::BloodpointConversion' has a wrong offset!");
static_assert(offsetof(FFearMarketItemInstance, Purchased) == 0x000010, "Member 'FFearMarketItemInstance::Purchased' has a wrong offset!");
static_assert(offsetof(FFearMarketItemInstance, DiscountPercentage) == 0x000014, "Member 'FFearMarketItemInstance::DiscountPercentage' has a wrong offset!");

// ScriptStruct DeadByDaylight.OnMovementCacheStruct
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FOnMovementCacheStruct final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnMovementCacheStruct) == 0x000004, "Wrong alignment on FOnMovementCacheStruct");
static_assert(sizeof(FOnMovementCacheStruct) == 0x00000C, "Wrong size on FOnMovementCacheStruct");

// ScriptStruct DeadByDaylight.InteractionProficiencyProperties
// 0x0078 (0x0080 - 0x0008)
struct FInteractionProficiencyProperties final : public FDBDTableRowBase
{
public:
	class FName                                   ProficiencyID;                                     // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ProficiencyBlueprint;                              // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 BuffLevelThresholds;                               // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 DebuffLevelThresholds;                             // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          HasLevels;                                         // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconFilePath;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInteractionProficiencyProperties) == 0x000008, "Wrong alignment on FInteractionProficiencyProperties");
static_assert(sizeof(FInteractionProficiencyProperties) == 0x000080, "Wrong size on FInteractionProficiencyProperties");
static_assert(offsetof(FInteractionProficiencyProperties, ProficiencyID) == 0x000008, "Member 'FInteractionProficiencyProperties::ProficiencyID' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyProperties, ProficiencyBlueprint) == 0x000018, "Member 'FInteractionProficiencyProperties::ProficiencyBlueprint' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyProperties, BuffLevelThresholds) == 0x000048, "Member 'FInteractionProficiencyProperties::BuffLevelThresholds' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyProperties, DebuffLevelThresholds) == 0x000058, "Member 'FInteractionProficiencyProperties::DebuffLevelThresholds' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyProperties, HasLevels) == 0x000068, "Member 'FInteractionProficiencyProperties::HasLevels' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyProperties, IconFilePath) == 0x000070, "Member 'FInteractionProficiencyProperties::IconFilePath' has a wrong offset!");

// ScriptStruct DeadByDaylight.ManagedGameplayElementData
// 0x0050 (0x0050 - 0x0000)
struct FManagedGameplayElementData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorSpawner*>                  ActivatedSpawners;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UActorSpawner*>                  RemovedSpawners;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EGameplayElementType                          PopulationType;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentPopulationCost;                             // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPopulationCost;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPopulationCost;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapWidth;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenElements;                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistSqrBetweenElements;                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileWidth;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FactorToAdjustToWhenOutOfProximity;                // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManagedGameplayElementData) == 0x000008, "Wrong alignment on FManagedGameplayElementData");
static_assert(sizeof(FManagedGameplayElementData) == 0x000050, "Wrong size on FManagedGameplayElementData");
static_assert(offsetof(FManagedGameplayElementData, ActivatedSpawners) == 0x000008, "Member 'FManagedGameplayElementData::ActivatedSpawners' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, RemovedSpawners) == 0x000018, "Member 'FManagedGameplayElementData::RemovedSpawners' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, PopulationType) == 0x000028, "Member 'FManagedGameplayElementData::PopulationType' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, CurrentPopulationCost) == 0x00002C, "Member 'FManagedGameplayElementData::CurrentPopulationCost' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, MaxPopulationCost) == 0x000030, "Member 'FManagedGameplayElementData::MaxPopulationCost' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, MinPopulationCost) == 0x000034, "Member 'FManagedGameplayElementData::MinPopulationCost' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, MapWidth) == 0x000038, "Member 'FManagedGameplayElementData::MapWidth' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, MinProximityBetweenElements) == 0x00003C, "Member 'FManagedGameplayElementData::MinProximityBetweenElements' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, MinDistSqrBetweenElements) == 0x000040, "Member 'FManagedGameplayElementData::MinDistSqrBetweenElements' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, TileWidth) == 0x000044, "Member 'FManagedGameplayElementData::TileWidth' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, FactorToAdjustToWhenOutOfProximity) == 0x000048, "Member 'FManagedGameplayElementData::FactorToAdjustToWhenOutOfProximity' has a wrong offset!");

// ScriptStruct DeadByDaylight.EffectCameraTypeSettings
// 0x0003 (0x0003 - 0x0000)
struct FEffectCameraTypeSettings final
{
public:
	ECustomizationCategory                        Category;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibilityInFirstPerson;                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibilityInThirdPerson;                           // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectCameraTypeSettings) == 0x000001, "Wrong alignment on FEffectCameraTypeSettings");
static_assert(sizeof(FEffectCameraTypeSettings) == 0x000003, "Wrong size on FEffectCameraTypeSettings");
static_assert(offsetof(FEffectCameraTypeSettings, Category) == 0x000000, "Member 'FEffectCameraTypeSettings::Category' has a wrong offset!");
static_assert(offsetof(FEffectCameraTypeSettings, VisibilityInFirstPerson) == 0x000001, "Member 'FEffectCameraTypeSettings::VisibilityInFirstPerson' has a wrong offset!");
static_assert(offsetof(FEffectCameraTypeSettings, VisibilityInThirdPerson) == 0x000002, "Member 'FEffectCameraTypeSettings::VisibilityInThirdPerson' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArrayOfSceneComponent
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfSceneComponent final
{
public:
	TArray<class USceneComponent*>                sceneComp;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfSceneComponent) == 0x000008, "Wrong alignment on FArrayOfSceneComponent");
static_assert(sizeof(FArrayOfSceneComponent) == 0x000010, "Wrong size on FArrayOfSceneComponent");
static_assert(offsetof(FArrayOfSceneComponent, sceneComp) == 0x000000, "Member 'FArrayOfSceneComponent::sceneComp' has a wrong offset!");

// ScriptStruct DeadByDaylight.SecondaryInteractionProperties
// 0x0038 (0x0038 - 0x0000)
struct FSecondaryInteractionProperties final
{
public:
	class FString                                 SecondaryInteractionID;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         SecondaryInteractionInputType;                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SecondaryInteractionDescriptionText;               // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          ShouldShow;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSecondaryInteractionProperties) == 0x000008, "Wrong alignment on FSecondaryInteractionProperties");
static_assert(sizeof(FSecondaryInteractionProperties) == 0x000038, "Wrong size on FSecondaryInteractionProperties");
static_assert(offsetof(FSecondaryInteractionProperties, SecondaryInteractionID) == 0x000000, "Member 'FSecondaryInteractionProperties::SecondaryInteractionID' has a wrong offset!");
static_assert(offsetof(FSecondaryInteractionProperties, SecondaryInteractionInputType) == 0x000010, "Member 'FSecondaryInteractionProperties::SecondaryInteractionInputType' has a wrong offset!");
static_assert(offsetof(FSecondaryInteractionProperties, SecondaryInteractionDescriptionText) == 0x000018, "Member 'FSecondaryInteractionProperties::SecondaryInteractionDescriptionText' has a wrong offset!");
static_assert(offsetof(FSecondaryInteractionProperties, ShouldShow) == 0x000030, "Member 'FSecondaryInteractionProperties::ShouldShow' has a wrong offset!");

// ScriptStruct DeadByDaylight.HitValidationValidator
// 0x0018 (0x0018 - 0x0000)
struct FHitValidationValidator final
{
public:
	float                                         CapsuleInflation;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistance;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitValidationValidator) == 0x000008, "Wrong alignment on FHitValidationValidator");
static_assert(sizeof(FHitValidationValidator) == 0x000018, "Wrong size on FHitValidationValidator");
static_assert(offsetof(FHitValidationValidator, CapsuleInflation) == 0x000000, "Member 'FHitValidationValidator::CapsuleInflation' has a wrong offset!");
static_assert(offsetof(FHitValidationValidator, MaximumDistance) == 0x000004, "Member 'FHitValidationValidator::MaximumDistance' has a wrong offset!");
static_assert(offsetof(FHitValidationValidator, Name) == 0x000008, "Member 'FHitValidationValidator::Name' has a wrong offset!");

// ScriptStruct DeadByDaylight.MontageInstanceInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FMontageInstanceInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMontageInstanceInfo) == 0x000008, "Wrong alignment on FMontageInstanceInfo");
static_assert(sizeof(FMontageInstanceInfo) == 0x000030, "Wrong size on FMontageInstanceInfo");

// ScriptStruct DeadByDaylight.ConsentDefinitionData
// 0x0050 (0x0050 - 0x0000)
struct FConsentDefinitionData final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Platform;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Sku;                                               // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Sku_IsSet;                                         // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Language;                                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          NeedAcceptance;                                    // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMandatory;                                       // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConsentDefinitionData) == 0x000008, "Wrong alignment on FConsentDefinitionData");
static_assert(sizeof(FConsentDefinitionData) == 0x000050, "Wrong size on FConsentDefinitionData");
static_assert(offsetof(FConsentDefinitionData, Id) == 0x000000, "Member 'FConsentDefinitionData::Id' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, Platform) == 0x000010, "Member 'FConsentDefinitionData::Platform' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, Sku) == 0x000020, "Member 'FConsentDefinitionData::Sku' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, Sku_IsSet) == 0x000030, "Member 'FConsentDefinitionData::Sku_IsSet' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, Language) == 0x000038, "Member 'FConsentDefinitionData::Language' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, NeedAcceptance) == 0x000048, "Member 'FConsentDefinitionData::NeedAcceptance' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, IsMandatory) == 0x000049, "Member 'FConsentDefinitionData::IsMandatory' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoryLevel
// 0x00E0 (0x00E0 - 0x0000)
struct FStoryLevel final
{
public:
	TArray<class FString>                         Start;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         End;                                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 StartDate;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FArchivesNodeDefinition> Nodes;                                       // 0x0030(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FRewardResponseItem>            EndNodeRewards;                                    // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EndNodeRewards_IsSet;                              // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            LevelRewards;                                      // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          LevelRewards_IsSet;                                // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            TaskRewards;                                       // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          TaskRewards_IsSet;                                 // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            ChallengeRewards;                                  // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ChallengeRewards_IsSet;                            // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoryLevel) == 0x000008, "Wrong alignment on FStoryLevel");
static_assert(sizeof(FStoryLevel) == 0x0000E0, "Wrong size on FStoryLevel");
static_assert(offsetof(FStoryLevel, Start) == 0x000000, "Member 'FStoryLevel::Start' has a wrong offset!");
static_assert(offsetof(FStoryLevel, End) == 0x000010, "Member 'FStoryLevel::End' has a wrong offset!");
static_assert(offsetof(FStoryLevel, StartDate) == 0x000020, "Member 'FStoryLevel::StartDate' has a wrong offset!");
static_assert(offsetof(FStoryLevel, Nodes) == 0x000030, "Member 'FStoryLevel::Nodes' has a wrong offset!");
static_assert(offsetof(FStoryLevel, EndNodeRewards) == 0x000080, "Member 'FStoryLevel::EndNodeRewards' has a wrong offset!");
static_assert(offsetof(FStoryLevel, EndNodeRewards_IsSet) == 0x000090, "Member 'FStoryLevel::EndNodeRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FStoryLevel, LevelRewards) == 0x000098, "Member 'FStoryLevel::LevelRewards' has a wrong offset!");
static_assert(offsetof(FStoryLevel, LevelRewards_IsSet) == 0x0000A8, "Member 'FStoryLevel::LevelRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FStoryLevel, TaskRewards) == 0x0000B0, "Member 'FStoryLevel::TaskRewards' has a wrong offset!");
static_assert(offsetof(FStoryLevel, TaskRewards_IsSet) == 0x0000C0, "Member 'FStoryLevel::TaskRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FStoryLevel, ChallengeRewards) == 0x0000C8, "Member 'FStoryLevel::ChallengeRewards' has a wrong offset!");
static_assert(offsetof(FStoryLevel, ChallengeRewards_IsSet) == 0x0000D8, "Member 'FStoryLevel::ChallengeRewards_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIDetectedStimulus
// 0x005C (0x005C - 0x0000)
struct FAIDetectedStimulus final
{
public:
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtTime;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x2C];                                      // 0x0030(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDetectedStimulus) == 0x000004, "Wrong alignment on FAIDetectedStimulus");
static_assert(sizeof(FAIDetectedStimulus) == 0x00005C, "Wrong size on FAIDetectedStimulus");
static_assert(offsetof(FAIDetectedStimulus, Instigator) == 0x000000, "Member 'FAIDetectedStimulus::Instigator' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, Location) == 0x000008, "Member 'FAIDetectedStimulus::Location' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, Rotation) == 0x000014, "Member 'FAIDetectedStimulus::Rotation' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, Velocity) == 0x000020, "Member 'FAIDetectedStimulus::Velocity' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, AtTime) == 0x00002C, "Member 'FAIDetectedStimulus::AtTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.NewsContentOnlineData
// 0x0018 (0x0018 - 0x0000)
struct FNewsContentOnlineData final
{
public:
	TArray<struct FNewsContentDetails>            News;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          News_isset;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNewsContentOnlineData) == 0x000008, "Wrong alignment on FNewsContentOnlineData");
static_assert(sizeof(FNewsContentOnlineData) == 0x000018, "Wrong size on FNewsContentOnlineData");
static_assert(offsetof(FNewsContentOnlineData, News) == 0x000000, "Member 'FNewsContentOnlineData::News' has a wrong offset!");
static_assert(offsetof(FNewsContentOnlineData, News_isset) == 0x000010, "Member 'FNewsContentOnlineData::News_isset' has a wrong offset!");

// ScriptStruct DeadByDaylight.ModifierTickableConditionReplicatedData
// 0x0018 (0x0018 - 0x0000)
struct FModifierTickableConditionReplicatedData final
{
public:
	TArray<class UBaseModifierCondition*>         Conditions;                                        // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          HasCondition;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AuthorityDataSet;                                  // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifierTickableConditionReplicatedData) == 0x000008, "Wrong alignment on FModifierTickableConditionReplicatedData");
static_assert(sizeof(FModifierTickableConditionReplicatedData) == 0x000018, "Wrong size on FModifierTickableConditionReplicatedData");
static_assert(offsetof(FModifierTickableConditionReplicatedData, Conditions) == 0x000000, "Member 'FModifierTickableConditionReplicatedData::Conditions' has a wrong offset!");
static_assert(offsetof(FModifierTickableConditionReplicatedData, HasCondition) == 0x000010, "Member 'FModifierTickableConditionReplicatedData::HasCondition' has a wrong offset!");
static_assert(offsetof(FModifierTickableConditionReplicatedData, AuthorityDataSet) == 0x000011, "Member 'FModifierTickableConditionReplicatedData::AuthorityDataSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.TooltipPressedData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FTooltipPressedData final
{
public:
	struct FVector2D                              touchPosition;                                     // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTooltipPressedData) == 0x000008, "Wrong alignment on FTooltipPressedData");
static_assert(sizeof(FTooltipPressedData) == 0x000018, "Wrong size on FTooltipPressedData");
static_assert(offsetof(FTooltipPressedData, touchPosition) == 0x000000, "Member 'FTooltipPressedData::touchPosition' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerRoleRankData
// 0x0010 (0x0010 - 0x0000)
struct FPlayerRoleRankData final
{
public:
	EPlayerRole                                   PlayerRole;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Rank;                                              // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PipsRequiredForNextRank;                           // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivePips;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerRoleRankData) == 0x000004, "Wrong alignment on FPlayerRoleRankData");
static_assert(sizeof(FPlayerRoleRankData) == 0x000010, "Wrong size on FPlayerRoleRankData");
static_assert(offsetof(FPlayerRoleRankData, PlayerRole) == 0x000000, "Member 'FPlayerRoleRankData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FPlayerRoleRankData, Rank) == 0x000004, "Member 'FPlayerRoleRankData::Rank' has a wrong offset!");
static_assert(offsetof(FPlayerRoleRankData, PipsRequiredForNextRank) == 0x000008, "Member 'FPlayerRoleRankData::PipsRequiredForNextRank' has a wrong offset!");
static_assert(offsetof(FPlayerRoleRankData, ActivePips) == 0x00000C, "Member 'FPlayerRoleRankData::ActivePips' has a wrong offset!");

// ScriptStruct DeadByDaylight.BaseTooltipData
// 0x0098 (0x0098 - 0x0000)
struct FBaseTooltipData
{
public:
	class FString                                 Title;                                             // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TouchPosition;                                     // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LeftTooltipWidgetAsset;                            // 0x0028(0x0030)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RightTooltipWidgetAsset;                           // 0x0058(0x0030)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseTooltipData) == 0x000008, "Wrong alignment on FBaseTooltipData");
static_assert(sizeof(FBaseTooltipData) == 0x000098, "Wrong size on FBaseTooltipData");
static_assert(offsetof(FBaseTooltipData, Title) == 0x000000, "Member 'FBaseTooltipData::Title' has a wrong offset!");
static_assert(offsetof(FBaseTooltipData, Description) == 0x000010, "Member 'FBaseTooltipData::Description' has a wrong offset!");
static_assert(offsetof(FBaseTooltipData, TouchPosition) == 0x000020, "Member 'FBaseTooltipData::TouchPosition' has a wrong offset!");
static_assert(offsetof(FBaseTooltipData, LeftTooltipWidgetAsset) == 0x000028, "Member 'FBaseTooltipData::LeftTooltipWidgetAsset' has a wrong offset!");
static_assert(offsetof(FBaseTooltipData, RightTooltipWidgetAsset) == 0x000058, "Member 'FBaseTooltipData::RightTooltipWidgetAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankTooltipData
// 0x0028 (0x00C0 - 0x0098)
struct FRankTooltipData final : public FBaseTooltipData
{
public:
	EPlayerRole                                   CurrentPlayerRole;                                 // 0x0098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerRoleRankData                    SurvivorRankData;                                  // 0x009C(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerRoleRankData                    KillerRankData;                                    // 0x00AC(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRankTooltipData) == 0x000008, "Wrong alignment on FRankTooltipData");
static_assert(sizeof(FRankTooltipData) == 0x0000C0, "Wrong size on FRankTooltipData");
static_assert(offsetof(FRankTooltipData, CurrentPlayerRole) == 0x000098, "Member 'FRankTooltipData::CurrentPlayerRole' has a wrong offset!");
static_assert(offsetof(FRankTooltipData, SurvivorRankData) == 0x00009C, "Member 'FRankTooltipData::SurvivorRankData' has a wrong offset!");
static_assert(offsetof(FRankTooltipData, KillerRankData) == 0x0000AC, "Member 'FRankTooltipData::KillerRankData' has a wrong offset!");

// ScriptStruct DeadByDaylight.EmblemProgressionData
// 0x0018 (0x0018 - 0x0000)
struct FEmblemProgressionData final
{
public:
	class FString                                 ProgressionText;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressionPercent;                                // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmblemProgressionData) == 0x000008, "Wrong alignment on FEmblemProgressionData");
static_assert(sizeof(FEmblemProgressionData) == 0x000018, "Wrong size on FEmblemProgressionData");
static_assert(offsetof(FEmblemProgressionData, ProgressionText) == 0x000000, "Member 'FEmblemProgressionData::ProgressionText' has a wrong offset!");
static_assert(offsetof(FEmblemProgressionData, ProgressionPercent) == 0x000010, "Member 'FEmblemProgressionData::ProgressionPercent' has a wrong offset!");

// ScriptStruct DeadByDaylight.EmblemSlotData
// 0x0070 (0x0070 - 0x0000)
struct FEmblemSlotData final
{
public:
	EEmblemQuality                                Quality;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         IconPaths;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 ThresholdPoints;                                   // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         CurrentPoints;                                     // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEmblemProgressionData>         ProgressionData;                                   // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         CharacterExperience;                               // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmblemSlotData) == 0x000008, "Wrong alignment on FEmblemSlotData");
static_assert(sizeof(FEmblemSlotData) == 0x000070, "Wrong size on FEmblemSlotData");
static_assert(offsetof(FEmblemSlotData, Quality) == 0x000000, "Member 'FEmblemSlotData::Quality' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, Title) == 0x000008, "Member 'FEmblemSlotData::Title' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, Description) == 0x000018, "Member 'FEmblemSlotData::Description' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, Score) == 0x000028, "Member 'FEmblemSlotData::Score' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, IconPaths) == 0x000030, "Member 'FEmblemSlotData::IconPaths' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, ThresholdPoints) == 0x000040, "Member 'FEmblemSlotData::ThresholdPoints' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, CurrentPoints) == 0x000050, "Member 'FEmblemSlotData::CurrentPoints' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, ProgressionData) == 0x000058, "Member 'FEmblemSlotData::ProgressionData' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, CharacterExperience) == 0x000068, "Member 'FEmblemSlotData::CharacterExperience' has a wrong offset!");

// ScriptStruct DeadByDaylight.BonusTierTooltipVisibility
// 0x0018 (0x0018 - 0x0000)
struct FBonusTierTooltipVisibility final
{
public:
	class FString                                 archiveId;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isVisible;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBonusTierTooltipVisibility) == 0x000008, "Wrong alignment on FBonusTierTooltipVisibility");
static_assert(sizeof(FBonusTierTooltipVisibility) == 0x000018, "Wrong size on FBonusTierTooltipVisibility");
static_assert(offsetof(FBonusTierTooltipVisibility, archiveId) == 0x000000, "Member 'FBonusTierTooltipVisibility::archiveId' has a wrong offset!");
static_assert(offsetof(FBonusTierTooltipVisibility, isVisible) == 0x000010, "Member 'FBonusTierTooltipVisibility::isVisible' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedCharmSlotData
// 0x0010 (0x0010 - 0x0000)
struct FSavedCharmSlotData final
{
public:
	int8                                          SlotIndex;                                         // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharmId;                                           // 0x0004(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedCharmSlotData) == 0x000004, "Wrong alignment on FSavedCharmSlotData");
static_assert(sizeof(FSavedCharmSlotData) == 0x000010, "Wrong size on FSavedCharmSlotData");
static_assert(offsetof(FSavedCharmSlotData, SlotIndex) == 0x000000, "Member 'FSavedCharmSlotData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FSavedCharmSlotData, CharmId) == 0x000004, "Member 'FSavedCharmSlotData::CharmId' has a wrong offset!");

// ScriptStruct DeadByDaylight.SimpleCharacterDropdown
// 0x0004 (0x0004 - 0x0000)
struct FSimpleCharacterDropdown final
{
public:
	int32                                         CharacterID;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleCharacterDropdown) == 0x000004, "Wrong alignment on FSimpleCharacterDropdown");
static_assert(sizeof(FSimpleCharacterDropdown) == 0x000004, "Wrong size on FSimpleCharacterDropdown");
static_assert(offsetof(FSimpleCharacterDropdown, CharacterID) == 0x000000, "Member 'FSimpleCharacterDropdown::CharacterID' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterCamera
// 0x0010 (0x0010 - 0x0000)
struct FCharacterCamera final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSimpleCharacterDropdown               Data;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCamera) == 0x000004, "Wrong alignment on FCharacterCamera");
static_assert(sizeof(FCharacterCamera) == 0x000010, "Wrong size on FCharacterCamera");
static_assert(offsetof(FCharacterCamera, Label) == 0x000000, "Member 'FCharacterCamera::Label' has a wrong offset!");
static_assert(offsetof(FCharacterCamera, Data) == 0x00000C, "Member 'FCharacterCamera::Data' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationData
// 0x0128 (0x0130 - 0x0008)
struct FCustomizationData : public FDBDTableRowBase
{
public:
	int32                                         AssociatedCharacter;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   AssociatedRole;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemUIData                            UIData;                                            // 0x0010(0x00C0)(Edit, NativeAccessSpecifierPublic)
	struct FItemAvailability                      Availability;                                      // 0x00D0(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0100(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomizationId;                                   // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationData) == 0x000008, "Wrong alignment on FCustomizationData");
static_assert(sizeof(FCustomizationData) == 0x000130, "Wrong size on FCustomizationData");
static_assert(offsetof(FCustomizationData, AssociatedCharacter) == 0x000008, "Member 'FCustomizationData::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(FCustomizationData, AssociatedRole) == 0x00000C, "Member 'FCustomizationData::AssociatedRole' has a wrong offset!");
static_assert(offsetof(FCustomizationData, Rarity) == 0x00000D, "Member 'FCustomizationData::Rarity' has a wrong offset!");
static_assert(offsetof(FCustomizationData, UIData) == 0x000010, "Member 'FCustomizationData::UIData' has a wrong offset!");
static_assert(offsetof(FCustomizationData, Availability) == 0x0000D0, "Member 'FCustomizationData::Availability' has a wrong offset!");
static_assert(offsetof(FCustomizationData, InclusionVersion) == 0x000100, "Member 'FCustomizationData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FCustomizationData, CustomizationId) == 0x000110, "Member 'FCustomizationData::CustomizationId' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveNodeDefinition
// 0x0050 (0x0068 - 0x0018)
struct FArchiveNodeDefinition final : public FDBDTableRowBaseWithId
{
public:
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CinematicId;                                       // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchiveNodeDefinition) == 0x000008, "Wrong alignment on FArchiveNodeDefinition");
static_assert(sizeof(FArchiveNodeDefinition) == 0x000068, "Wrong size on FArchiveNodeDefinition");
static_assert(offsetof(FArchiveNodeDefinition, DisplayName) == 0x000018, "Member 'FArchiveNodeDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(FArchiveNodeDefinition, Description) == 0x000030, "Member 'FArchiveNodeDefinition::Description' has a wrong offset!");
static_assert(offsetof(FArchiveNodeDefinition, IconPath) == 0x000048, "Member 'FArchiveNodeDefinition::IconPath' has a wrong offset!");
static_assert(offsetof(FArchiveNodeDefinition, PlayerRole) == 0x000058, "Member 'FArchiveNodeDefinition::PlayerRole' has a wrong offset!");
static_assert(offsetof(FArchiveNodeDefinition, CinematicId) == 0x00005C, "Member 'FArchiveNodeDefinition::CinematicId' has a wrong offset!");

// ScriptStruct DeadByDaylight.FreeToPlayData
// 0x0030 (0x0030 - 0x0000)
struct FFreeToPlayData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Start;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 End;                                               // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFreeToPlayData) == 0x000008, "Wrong alignment on FFreeToPlayData");
static_assert(sizeof(FFreeToPlayData) == 0x000030, "Wrong size on FFreeToPlayData");
static_assert(offsetof(FFreeToPlayData, Start) == 0x000010, "Member 'FFreeToPlayData::Start' has a wrong offset!");
static_assert(offsetof(FFreeToPlayData, End) == 0x000020, "Member 'FFreeToPlayData::End' has a wrong offset!");

// ScriptStruct DeadByDaylight.PurchaseCurrencyData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPurchaseCurrencyData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ECurrencyType                                 CurrencyType;                                      // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscountPercentage;                                // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAffordable;                                      // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0xB];                                       // 0x0015(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPurchaseCurrencyData) == 0x000008, "Wrong alignment on FPurchaseCurrencyData");
static_assert(sizeof(FPurchaseCurrencyData) == 0x000020, "Wrong size on FPurchaseCurrencyData");
static_assert(offsetof(FPurchaseCurrencyData, CurrencyType) == 0x000008, "Member 'FPurchaseCurrencyData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FPurchaseCurrencyData, Price) == 0x00000C, "Member 'FPurchaseCurrencyData::Price' has a wrong offset!");
static_assert(offsetof(FPurchaseCurrencyData, DiscountPercentage) == 0x000010, "Member 'FPurchaseCurrencyData::DiscountPercentage' has a wrong offset!");
static_assert(offsetof(FPurchaseCurrencyData, IsAffordable) == 0x000014, "Member 'FPurchaseCurrencyData::IsAffordable' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreItemSlotData
// 0x01C0 (0x01C0 - 0x0000)
struct FStoreItemSlotData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationCategory                        Category;                                          // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MirrorsId;                                         // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconPath;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayCollectionName;                             // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RoleCategoryInfo;                                  // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RarityPartInfo;                                    // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventUIInfo                    EventInfo;                                         // 0x0090(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<struct FPurchaseCurrencyData>          PurchaseDataList;                                  // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           ParentBundleIds;                                   // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           ChildrenItemIds;                                   // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FCustomTransformation                  CustomTransformation;                              // 0x0120(0x0014)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x0134(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBuyable;                                         // 0x0135(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipped;                                        // 0x0136(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewInStore;                                      // 0x0137(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x0138(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInStore;                                         // 0x0139(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   AssociatedRole;                                    // 0x013A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B[0x5];                                      // 0x013B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ReleaseDate;                                       // 0x0140(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x0148(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x77];                                     // 0x0149(0x0077)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreItemSlotData) == 0x000008, "Wrong alignment on FStoreItemSlotData");
static_assert(sizeof(FStoreItemSlotData) == 0x0001C0, "Wrong size on FStoreItemSlotData");
static_assert(offsetof(FStoreItemSlotData, ItemId) == 0x000008, "Member 'FStoreItemSlotData::ItemId' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, Category) == 0x000014, "Member 'FStoreItemSlotData::Category' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, MirrorsId) == 0x000018, "Member 'FStoreItemSlotData::MirrorsId' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IconPath) == 0x000028, "Member 'FStoreItemSlotData::IconPath' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, DisplayName) == 0x000038, "Member 'FStoreItemSlotData::DisplayName' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, DisplayCollectionName) == 0x000048, "Member 'FStoreItemSlotData::DisplayCollectionName' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, Description) == 0x000058, "Member 'FStoreItemSlotData::Description' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, RoleCategoryInfo) == 0x000068, "Member 'FStoreItemSlotData::RoleCategoryInfo' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, RarityPartInfo) == 0x000078, "Member 'FStoreItemSlotData::RarityPartInfo' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, Rarity) == 0x000088, "Member 'FStoreItemSlotData::Rarity' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, EventInfo) == 0x000090, "Member 'FStoreItemSlotData::EventInfo' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, PurchaseDataList) == 0x0000F0, "Member 'FStoreItemSlotData::PurchaseDataList' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, ParentBundleIds) == 0x000100, "Member 'FStoreItemSlotData::ParentBundleIds' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, ChildrenItemIds) == 0x000110, "Member 'FStoreItemSlotData::ChildrenItemIds' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, CustomTransformation) == 0x000120, "Member 'FStoreItemSlotData::CustomTransformation' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsOwned) == 0x000134, "Member 'FStoreItemSlotData::IsOwned' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsBuyable) == 0x000135, "Member 'FStoreItemSlotData::IsBuyable' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsEquipped) == 0x000136, "Member 'FStoreItemSlotData::IsEquipped' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsNewInStore) == 0x000137, "Member 'FStoreItemSlotData::IsNewInStore' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsLocked) == 0x000138, "Member 'FStoreItemSlotData::IsLocked' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsInStore) == 0x000139, "Member 'FStoreItemSlotData::IsInStore' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, AssociatedRole) == 0x00013A, "Member 'FStoreItemSlotData::AssociatedRole' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, ReleaseDate) == 0x000140, "Member 'FStoreItemSlotData::ReleaseDate' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsEnabled) == 0x000148, "Member 'FStoreItemSlotData::IsEnabled' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkDropdown
// 0x000E (0x0010 - 0x0002)
struct FPerkDropdown : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PerkID;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkDropdown) == 0x000004, "Wrong alignment on FPerkDropdown");
static_assert(sizeof(FPerkDropdown) == 0x000010, "Wrong size on FPerkDropdown");
static_assert(offsetof(FPerkDropdown, PerkID) == 0x000004, "Member 'FPerkDropdown::PerkID' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionVirtualCurrencyParameters
// 0x0028 (0x0028 - 0x0000)
struct FShopTransactionVirtualCurrencyParameters final
{
public:
	int32                                         virtualCurrencyAmount;                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 virtualCurrencyName;                               // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 virtualCurrencyType;                               // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionVirtualCurrencyParameters) == 0x000008, "Wrong alignment on FShopTransactionVirtualCurrencyParameters");
static_assert(sizeof(FShopTransactionVirtualCurrencyParameters) == 0x000028, "Wrong size on FShopTransactionVirtualCurrencyParameters");
static_assert(offsetof(FShopTransactionVirtualCurrencyParameters, virtualCurrencyAmount) == 0x000000, "Member 'FShopTransactionVirtualCurrencyParameters::virtualCurrencyAmount' has a wrong offset!");
static_assert(offsetof(FShopTransactionVirtualCurrencyParameters, virtualCurrencyName) == 0x000008, "Member 'FShopTransactionVirtualCurrencyParameters::virtualCurrencyName' has a wrong offset!");
static_assert(offsetof(FShopTransactionVirtualCurrencyParameters, virtualCurrencyType) == 0x000018, "Member 'FShopTransactionVirtualCurrencyParameters::virtualCurrencyType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionVirtualCurrency
// 0x0028 (0x0028 - 0x0000)
struct FShopTransactionVirtualCurrency final
{
public:
	struct FShopTransactionVirtualCurrencyParameters virtualCurrency;                                // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionVirtualCurrency) == 0x000008, "Wrong alignment on FShopTransactionVirtualCurrency");
static_assert(sizeof(FShopTransactionVirtualCurrency) == 0x000028, "Wrong size on FShopTransactionVirtualCurrency");
static_assert(offsetof(FShopTransactionVirtualCurrency, virtualCurrency) == 0x000000, "Member 'FShopTransactionVirtualCurrency::virtualCurrency' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedBannerData
// 0x0080 (0x0080 - 0x0000)
struct FStoreFeaturedBannerData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssociatedDlcId;                                   // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssociatedCombinedItemId;                          // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssociatedCombinedOutfitId;                        // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextBannerPosition                           TextPosition;                                      // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreFeaturedBannerData) == 0x000008, "Wrong alignment on FStoreFeaturedBannerData");
static_assert(sizeof(FStoreFeaturedBannerData) == 0x000080, "Wrong size on FStoreFeaturedBannerData");
static_assert(offsetof(FStoreFeaturedBannerData, Title) == 0x000008, "Member 'FStoreFeaturedBannerData::Title' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedBannerData, Subtitle) == 0x000020, "Member 'FStoreFeaturedBannerData::Subtitle' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedBannerData, ImagePath) == 0x000038, "Member 'FStoreFeaturedBannerData::ImagePath' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedBannerData, AssociatedDlcId) == 0x000048, "Member 'FStoreFeaturedBannerData::AssociatedDlcId' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedBannerData, AssociatedCombinedItemId) == 0x000058, "Member 'FStoreFeaturedBannerData::AssociatedCombinedItemId' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedBannerData, AssociatedCombinedOutfitId) == 0x000068, "Member 'FStoreFeaturedBannerData::AssociatedCombinedOutfitId' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedBannerData, TextPosition) == 0x000078, "Member 'FStoreFeaturedBannerData::TextPosition' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedBannerUIData
// 0x0098 (0x0098 - 0x0000)
struct FStoreFeaturedBannerUIData final
{
public:
	class FName                                   BannerId;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStoreFeaturedBannerData               BannerData;                                        // 0x0010(0x0080)(NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreFeaturedBannerUIData) == 0x000008, "Wrong alignment on FStoreFeaturedBannerUIData");
static_assert(sizeof(FStoreFeaturedBannerUIData) == 0x000098, "Wrong size on FStoreFeaturedBannerUIData");
static_assert(offsetof(FStoreFeaturedBannerUIData, BannerId) == 0x000000, "Member 'FStoreFeaturedBannerUIData::BannerId' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedBannerUIData, BannerData) == 0x000010, "Member 'FStoreFeaturedBannerUIData::BannerData' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedBannerUIData, IsNew) == 0x000090, "Member 'FStoreFeaturedBannerUIData::IsNew' has a wrong offset!");

// ScriptStruct DeadByDaylight.CamperHealResult
// 0x0018 (0x0018 - 0x0000)
struct FCamperHealResult final
{
public:
	ECamperDamageState                            PreviousDamageState;                               // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            CurrentDamageState;                                // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealAmount;                                        // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADBDPlayer*>                     Healers;                                           // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCamperHealResult) == 0x000008, "Wrong alignment on FCamperHealResult");
static_assert(sizeof(FCamperHealResult) == 0x000018, "Wrong size on FCamperHealResult");
static_assert(offsetof(FCamperHealResult, PreviousDamageState) == 0x000000, "Member 'FCamperHealResult::PreviousDamageState' has a wrong offset!");
static_assert(offsetof(FCamperHealResult, CurrentDamageState) == 0x000001, "Member 'FCamperHealResult::CurrentDamageState' has a wrong offset!");
static_assert(offsetof(FCamperHealResult, HealAmount) == 0x000004, "Member 'FCamperHealResult::HealAmount' has a wrong offset!");
static_assert(offsetof(FCamperHealResult, Healers) == 0x000008, "Member 'FCamperHealResult::Healers' has a wrong offset!");

// ScriptStruct DeadByDaylight.CosmeticPieceMeshLoadingData
// 0x0370 (0x0370 - 0x0000)
struct FCosmeticPieceMeshLoadingData final
{
public:
	uint8                                         Pad_0[0x368];                                      // 0x0000(0x0368)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmeticPieceMeshLoadingData) == 0x000008, "Wrong alignment on FCosmeticPieceMeshLoadingData");
static_assert(sizeof(FCosmeticPieceMeshLoadingData) == 0x000370, "Wrong size on FCosmeticPieceMeshLoadingData");
static_assert(offsetof(FCosmeticPieceMeshLoadingData, SkeletalMesh) == 0x000368, "Member 'FCosmeticPieceMeshLoadingData::SkeletalMesh' has a wrong offset!");

// ScriptStruct DeadByDaylight.TutorialNotificationData
// 0x00A8 (0x00B0 - 0x0008)
struct FTutorialNotificationData : public FDBDTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0048(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0078(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowAnalyticEnabled;                             // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialNotificationData) == 0x000008, "Wrong alignment on FTutorialNotificationData");
static_assert(sizeof(FTutorialNotificationData) == 0x0000B0, "Wrong size on FTutorialNotificationData");
static_assert(offsetof(FTutorialNotificationData, Title) == 0x000008, "Member 'FTutorialNotificationData::Title' has a wrong offset!");
static_assert(offsetof(FTutorialNotificationData, Description) == 0x000020, "Member 'FTutorialNotificationData::Description' has a wrong offset!");
static_assert(offsetof(FTutorialNotificationData, IconPath) == 0x000038, "Member 'FTutorialNotificationData::IconPath' has a wrong offset!");
static_assert(offsetof(FTutorialNotificationData, Icon) == 0x000048, "Member 'FTutorialNotificationData::Icon' has a wrong offset!");
static_assert(offsetof(FTutorialNotificationData, Image) == 0x000078, "Member 'FTutorialNotificationData::Image' has a wrong offset!");
static_assert(offsetof(FTutorialNotificationData, IsShowAnalyticEnabled) == 0x0000A8, "Member 'FTutorialNotificationData::IsShowAnalyticEnabled' has a wrong offset!");

// ScriptStruct DeadByDaylight.CloudInventoryItem
// 0x0010 (0x0010 - 0x0000)
struct FCloudInventoryItem final
{
public:
	int32                                         DefinitionId;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        InstanceId;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudInventoryItem) == 0x000008, "Wrong alignment on FCloudInventoryItem");
static_assert(sizeof(FCloudInventoryItem) == 0x000010, "Wrong size on FCloudInventoryItem");
static_assert(offsetof(FCloudInventoryItem, DefinitionId) == 0x000000, "Member 'FCloudInventoryItem::DefinitionId' has a wrong offset!");
static_assert(offsetof(FCloudInventoryItem, InstanceId) == 0x000008, "Member 'FCloudInventoryItem::InstanceId' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveRewardsData
// 0x0078 (0x0078 - 0x0000)
struct FArchiveRewardsData final
{
public:
	int32                                         XpRequirement;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StarsEarnedPerLevel;                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PreStartDate;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartDate;                                         // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndDate;                                           // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PostEndDate;                                       // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchiveRewardsData) == 0x000008, "Wrong alignment on FArchiveRewardsData");
static_assert(sizeof(FArchiveRewardsData) == 0x000078, "Wrong size on FArchiveRewardsData");
static_assert(offsetof(FArchiveRewardsData, XpRequirement) == 0x000000, "Member 'FArchiveRewardsData::XpRequirement' has a wrong offset!");
static_assert(offsetof(FArchiveRewardsData, StarsEarnedPerLevel) == 0x000004, "Member 'FArchiveRewardsData::StarsEarnedPerLevel' has a wrong offset!");
static_assert(offsetof(FArchiveRewardsData, PreStartDate) == 0x000008, "Member 'FArchiveRewardsData::PreStartDate' has a wrong offset!");
static_assert(offsetof(FArchiveRewardsData, StartDate) == 0x000018, "Member 'FArchiveRewardsData::StartDate' has a wrong offset!");
static_assert(offsetof(FArchiveRewardsData, EndDate) == 0x000028, "Member 'FArchiveRewardsData::EndDate' has a wrong offset!");
static_assert(offsetof(FArchiveRewardsData, PostEndDate) == 0x000038, "Member 'FArchiveRewardsData::PostEndDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.AttackDelegatePair
// 0x0010 (0x0010 - 0x0000)
struct FAttackDelegatePair final
{
public:
	class UDBDAttack*                             _attack;                                           // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackDelegatePair) == 0x000008, "Wrong alignment on FAttackDelegatePair");
static_assert(sizeof(FAttackDelegatePair) == 0x000010, "Wrong size on FAttackDelegatePair");
static_assert(offsetof(FAttackDelegatePair, _attack) == 0x000000, "Member 'FAttackDelegatePair::_attack' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebRingComposition
// 0x0018 (0x0018 - 0x0000)
struct FBloodwebRingComposition final
{
public:
	int32                                         EntityStartingRound;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NodeCountPerRing;                                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebRingComposition) == 0x000008, "Wrong alignment on FBloodwebRingComposition");
static_assert(sizeof(FBloodwebRingComposition) == 0x000018, "Wrong size on FBloodwebRingComposition");
static_assert(offsetof(FBloodwebRingComposition, EntityStartingRound) == 0x000000, "Member 'FBloodwebRingComposition::EntityStartingRound' has a wrong offset!");
static_assert(offsetof(FBloodwebRingComposition, NodeCountPerRing) == 0x000008, "Member 'FBloodwebRingComposition::NodeCountPerRing' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebRarityCost
// 0x0028 (0x0028 - 0x0000)
struct FBloodwebRarityCost final
{
public:
	int32                                         Artifact;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Common;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Legendary;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rare;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEvent;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spectral;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Teachable;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRare;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Uncommon;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRare;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebRarityCost) == 0x000004, "Wrong alignment on FBloodwebRarityCost");
static_assert(sizeof(FBloodwebRarityCost) == 0x000028, "Wrong size on FBloodwebRarityCost");
static_assert(offsetof(FBloodwebRarityCost, Artifact) == 0x000000, "Member 'FBloodwebRarityCost::Artifact' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Common) == 0x000004, "Member 'FBloodwebRarityCost::Common' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Legendary) == 0x000008, "Member 'FBloodwebRarityCost::Legendary' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Rare) == 0x00000C, "Member 'FBloodwebRarityCost::Rare' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, SpecialEvent) == 0x000010, "Member 'FBloodwebRarityCost::SpecialEvent' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Spectral) == 0x000014, "Member 'FBloodwebRarityCost::Spectral' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Teachable) == 0x000018, "Member 'FBloodwebRarityCost::Teachable' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, UltraRare) == 0x00001C, "Member 'FBloodwebRarityCost::UltraRare' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Uncommon) == 0x000020, "Member 'FBloodwebRarityCost::Uncommon' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, VeryRare) == 0x000024, "Member 'FBloodwebRarityCost::VeryRare' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebTypeCostModifiers
// 0x0014 (0x0014 - 0x0000)
struct FBloodwebTypeCostModifiers final
{
public:
	float                                         AddOn;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chest;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Items;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offerings;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Perks;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebTypeCostModifiers) == 0x000004, "Wrong alignment on FBloodwebTypeCostModifiers");
static_assert(sizeof(FBloodwebTypeCostModifiers) == 0x000014, "Wrong size on FBloodwebTypeCostModifiers");
static_assert(offsetof(FBloodwebTypeCostModifiers, AddOn) == 0x000000, "Member 'FBloodwebTypeCostModifiers::AddOn' has a wrong offset!");
static_assert(offsetof(FBloodwebTypeCostModifiers, Chest) == 0x000004, "Member 'FBloodwebTypeCostModifiers::Chest' has a wrong offset!");
static_assert(offsetof(FBloodwebTypeCostModifiers, Items) == 0x000008, "Member 'FBloodwebTypeCostModifiers::Items' has a wrong offset!");
static_assert(offsetof(FBloodwebTypeCostModifiers, Offerings) == 0x00000C, "Member 'FBloodwebTypeCostModifiers::Offerings' has a wrong offset!");
static_assert(offsetof(FBloodwebTypeCostModifiers, Perks) == 0x000010, "Member 'FBloodwebTypeCostModifiers::Perks' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebChestProbability
// 0x0020 (0x0020 - 0x0000)
struct FBloodwebChestProbability final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChestRarity;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebChestProbability) == 0x000008, "Wrong alignment on FBloodwebChestProbability");
static_assert(sizeof(FBloodwebChestProbability) == 0x000020, "Wrong size on FBloodwebChestProbability");
static_assert(offsetof(FBloodwebChestProbability, ID) == 0x000000, "Member 'FBloodwebChestProbability::ID' has a wrong offset!");
static_assert(offsetof(FBloodwebChestProbability, ChestRarity) == 0x000010, "Member 'FBloodwebChestProbability::ChestRarity' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebEventChestProbability
// 0x0020 (0x0020 - 0x0000)
struct FBloodwebEventChestProbability final
{
public:
	class FString                                 EventId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBloodwebChestProbability>      Chests;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebEventChestProbability) == 0x000008, "Wrong alignment on FBloodwebEventChestProbability");
static_assert(sizeof(FBloodwebEventChestProbability) == 0x000020, "Wrong size on FBloodwebEventChestProbability");
static_assert(offsetof(FBloodwebEventChestProbability, EventId) == 0x000000, "Member 'FBloodwebEventChestProbability::EventId' has a wrong offset!");
static_assert(offsetof(FBloodwebEventChestProbability, Chests) == 0x000010, "Member 'FBloodwebEventChestProbability::Chests' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebGenerationRulesData
// 0x0070 (0x0070 - 0x0000)
struct FBloodwebGenerationRulesData final
{
public:
	TArray<struct FBloodwebRingComposition>       RingComposition;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBloodwebRarityCost                    RarityCost;                                        // 0x0010(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FBloodwebTypeCostModifiers             TypeCostModifiers;                                 // 0x0038(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBloodwebChestProbability>      ChestProbability;                                  // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBloodwebEventChestProbability> EventChestProbability;                             // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebGenerationRulesData) == 0x000008, "Wrong alignment on FBloodwebGenerationRulesData");
static_assert(sizeof(FBloodwebGenerationRulesData) == 0x000070, "Wrong size on FBloodwebGenerationRulesData");
static_assert(offsetof(FBloodwebGenerationRulesData, RingComposition) == 0x000000, "Member 'FBloodwebGenerationRulesData::RingComposition' has a wrong offset!");
static_assert(offsetof(FBloodwebGenerationRulesData, RarityCost) == 0x000010, "Member 'FBloodwebGenerationRulesData::RarityCost' has a wrong offset!");
static_assert(offsetof(FBloodwebGenerationRulesData, TypeCostModifiers) == 0x000038, "Member 'FBloodwebGenerationRulesData::TypeCostModifiers' has a wrong offset!");
static_assert(offsetof(FBloodwebGenerationRulesData, ChestProbability) == 0x000050, "Member 'FBloodwebGenerationRulesData::ChestProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebGenerationRulesData, EventChestProbability) == 0x000060, "Member 'FBloodwebGenerationRulesData::EventChestProbability' has a wrong offset!");

// ScriptStruct DeadByDaylight.AITrailEvent
// 0x0030 (0x0030 - 0x0000)
struct FAITrailEvent final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           IgnoreOnPerkTag;                                   // 0x0020(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamIdentifier;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAITrailEvent) == 0x000008, "Wrong alignment on FAITrailEvent");
static_assert(sizeof(FAITrailEvent) == 0x000030, "Wrong size on FAITrailEvent");
static_assert(offsetof(FAITrailEvent, Location) == 0x000000, "Member 'FAITrailEvent::Location' has a wrong offset!");
static_assert(offsetof(FAITrailEvent, StartTime) == 0x00000C, "Member 'FAITrailEvent::StartTime' has a wrong offset!");
static_assert(offsetof(FAITrailEvent, EndTime) == 0x000010, "Member 'FAITrailEvent::EndTime' has a wrong offset!");
static_assert(offsetof(FAITrailEvent, Instigator) == 0x000018, "Member 'FAITrailEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FAITrailEvent, IgnoreOnPerkTag) == 0x000020, "Member 'FAITrailEvent::IgnoreOnPerkTag' has a wrong offset!");
static_assert(offsetof(FAITrailEvent, TeamIdentifier) == 0x00002C, "Member 'FAITrailEvent::TeamIdentifier' has a wrong offset!");

// ScriptStruct DeadByDaylight.DataTableDropdown
// 0x0030 (0x0030 - 0x0000)
struct FDataTableDropdown final
{
public:
	class FName                                   RowValue;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DataTableName;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ColumnName;                                        // 0x0020(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDataTableDropdown) == 0x000008, "Wrong alignment on FDataTableDropdown");
static_assert(sizeof(FDataTableDropdown) == 0x000030, "Wrong size on FDataTableDropdown");
static_assert(offsetof(FDataTableDropdown, RowValue) == 0x000000, "Member 'FDataTableDropdown::RowValue' has a wrong offset!");
static_assert(offsetof(FDataTableDropdown, DataTableName) == 0x000010, "Member 'FDataTableDropdown::DataTableName' has a wrong offset!");
static_assert(offsetof(FDataTableDropdown, ColumnName) == 0x000020, "Member 'FDataTableDropdown::ColumnName' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRewardUIData
// 0x0060 (0x0060 - 0x0000)
struct FAtlantaRewardUIData final
{
public:
	class FName                                   Id;                                                // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtlantaRewardType                            Type;                                              // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Quantity;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconFilePath;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 Currency;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRewardUIData) == 0x000008, "Wrong alignment on FAtlantaRewardUIData");
static_assert(sizeof(FAtlantaRewardUIData) == 0x000060, "Wrong size on FAtlantaRewardUIData");
static_assert(offsetof(FAtlantaRewardUIData, Id) == 0x000000, "Member 'FAtlantaRewardUIData::Id' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, Type) == 0x00000C, "Member 'FAtlantaRewardUIData::Type' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, Quantity) == 0x000010, "Member 'FAtlantaRewardUIData::Quantity' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, IconFilePath) == 0x000018, "Member 'FAtlantaRewardUIData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, Currency) == 0x000028, "Member 'FAtlantaRewardUIData::Currency' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, Rarity) == 0x000029, "Member 'FAtlantaRewardUIData::Rarity' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, DisplayName) == 0x000030, "Member 'FAtlantaRewardUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, Description) == 0x000048, "Member 'FAtlantaRewardUIData::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.RefundUIData
// 0x0078 (0x0078 - 0x0000)
struct FRefundUIData final
{
public:
	TArray<struct FAtlantaRewardUIData>           OriginalRewards;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FAtlantaRewardUIData                   Refund;                                            // 0x0010(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	int32                                         FragmentAmount;                                    // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FragmentRequiredAmount;                            // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRefundUIData) == 0x000008, "Wrong alignment on FRefundUIData");
static_assert(sizeof(FRefundUIData) == 0x000078, "Wrong size on FRefundUIData");
static_assert(offsetof(FRefundUIData, OriginalRewards) == 0x000000, "Member 'FRefundUIData::OriginalRewards' has a wrong offset!");
static_assert(offsetof(FRefundUIData, Refund) == 0x000010, "Member 'FRefundUIData::Refund' has a wrong offset!");
static_assert(offsetof(FRefundUIData, FragmentAmount) == 0x000070, "Member 'FRefundUIData::FragmentAmount' has a wrong offset!");
static_assert(offsetof(FRefundUIData, FragmentRequiredAmount) == 0x000074, "Member 'FRefundUIData::FragmentRequiredAmount' has a wrong offset!");

// ScriptStruct DeadByDaylight.RoleItemCategoryDropdown
// 0x0004 (0x000C - 0x0008)
struct FRoleItemCategoryDropdown : public FCharacterDropdown
{
public:
	bool                                          IncludeOutfits;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeNone;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationCategory                        Category;                                          // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoleItemCategoryDropdown) == 0x000004, "Wrong alignment on FRoleItemCategoryDropdown");
static_assert(sizeof(FRoleItemCategoryDropdown) == 0x00000C, "Wrong size on FRoleItemCategoryDropdown");
static_assert(offsetof(FRoleItemCategoryDropdown, IncludeOutfits) == 0x000008, "Member 'FRoleItemCategoryDropdown::IncludeOutfits' has a wrong offset!");
static_assert(offsetof(FRoleItemCategoryDropdown, IncludeNone) == 0x000009, "Member 'FRoleItemCategoryDropdown::IncludeNone' has a wrong offset!");
static_assert(offsetof(FRoleItemCategoryDropdown, Category) == 0x00000A, "Member 'FRoleItemCategoryDropdown::Category' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotViewSetting
// 0x0028 (0x0028 - 0x0000)
struct FScreenshotViewSetting final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralOffset;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterYaw;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterRoll;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterPitch;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitch;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotViewSetting) == 0x000004, "Wrong alignment on FScreenshotViewSetting");
static_assert(sizeof(FScreenshotViewSetting) == 0x000028, "Wrong size on FScreenshotViewSetting");
static_assert(offsetof(FScreenshotViewSetting, Distance) == 0x000000, "Member 'FScreenshotViewSetting::Distance' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, LateralOffset) == 0x000004, "Member 'FScreenshotViewSetting::LateralOffset' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, HeightOffset) == 0x000008, "Member 'FScreenshotViewSetting::HeightOffset' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, CharacterYaw) == 0x00000C, "Member 'FScreenshotViewSetting::CharacterYaw' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, CharacterRoll) == 0x000010, "Member 'FScreenshotViewSetting::CharacterRoll' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, CharacterPitch) == 0x000014, "Member 'FScreenshotViewSetting::CharacterPitch' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, CameraPitch) == 0x000018, "Member 'FScreenshotViewSetting::CameraPitch' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, SocketName) == 0x00001C, "Member 'FScreenshotViewSetting::SocketName' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterItemCategoryViewSetting
// 0x0040 (0x0040 - 0x0000)
struct FCharacterItemCategoryViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleItemCategoryDropdown              CharacterDropdown;                                 // 0x000C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 Settings;                                          // 0x0018(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterItemCategoryViewSetting) == 0x000004, "Wrong alignment on FCharacterItemCategoryViewSetting");
static_assert(sizeof(FCharacterItemCategoryViewSetting) == 0x000040, "Wrong size on FCharacterItemCategoryViewSetting");
static_assert(offsetof(FCharacterItemCategoryViewSetting, Label) == 0x000000, "Member 'FCharacterItemCategoryViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FCharacterItemCategoryViewSetting, CharacterDropdown) == 0x00000C, "Member 'FCharacterItemCategoryViewSetting::CharacterDropdown' has a wrong offset!");
static_assert(offsetof(FCharacterItemCategoryViewSetting, Settings) == 0x000018, "Member 'FCharacterItemCategoryViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.FearMarketOfferingInstance
// 0x0020 (0x0020 - 0x0000)
struct FFearMarketOfferingInstance final
{
public:
	TArray<struct FFearMarketItemInstance>        ObjectsForSale;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDateTime                              StartTime;                                         // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFearMarketOfferingInstance) == 0x000008, "Wrong alignment on FFearMarketOfferingInstance");
static_assert(sizeof(FFearMarketOfferingInstance) == 0x000020, "Wrong size on FFearMarketOfferingInstance");
static_assert(offsetof(FFearMarketOfferingInstance, ObjectsForSale) == 0x000000, "Member 'FFearMarketOfferingInstance::ObjectsForSale' has a wrong offset!");
static_assert(offsetof(FFearMarketOfferingInstance, StartTime) == 0x000010, "Member 'FFearMarketOfferingInstance::StartTime' has a wrong offset!");
static_assert(offsetof(FFearMarketOfferingInstance, EndTime) == 0x000018, "Member 'FFearMarketOfferingInstance::EndTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemTooltipData
// 0x0088 (0x0120 - 0x0098)
struct FItemTooltipData final : public FBaseTooltipData
{
public:
	uint8                                         Pad_98[0x88];                                      // 0x0098(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTooltipData) == 0x000008, "Wrong alignment on FItemTooltipData");
static_assert(sizeof(FItemTooltipData) == 0x000120, "Wrong size on FItemTooltipData");

// ScriptStruct DeadByDaylight.EscapeStrategyProperty
// 0x0018 (0x0018 - 0x0000)
struct FEscapeStrategyProperty final
{
public:
	EscapeStrategyType                            Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Population;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEscapeStrategyProperty) == 0x000008, "Wrong alignment on FEscapeStrategyProperty");
static_assert(sizeof(FEscapeStrategyProperty) == 0x000018, "Wrong size on FEscapeStrategyProperty");
static_assert(offsetof(FEscapeStrategyProperty, Type) == 0x000000, "Member 'FEscapeStrategyProperty::Type' has a wrong offset!");
static_assert(offsetof(FEscapeStrategyProperty, Population) == 0x000008, "Member 'FEscapeStrategyProperty::Population' has a wrong offset!");
static_assert(offsetof(FEscapeStrategyProperty, Weight) == 0x000010, "Member 'FEscapeStrategyProperty::Weight' has a wrong offset!");

// ScriptStruct DeadByDaylight.FirecrackerEffectData
// 0x0010 (0x0010 - 0x0000)
struct FFirecrackerEffectData final
{
public:
	class AFirecracker*                           Firecracker;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInRange;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFirstTime;                                       // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFirecrackerEffectData) == 0x000008, "Wrong alignment on FFirecrackerEffectData");
static_assert(sizeof(FFirecrackerEffectData) == 0x000010, "Wrong size on FFirecrackerEffectData");
static_assert(offsetof(FFirecrackerEffectData, Firecracker) == 0x000000, "Member 'FFirecrackerEffectData::Firecracker' has a wrong offset!");
static_assert(offsetof(FFirecrackerEffectData, IsInRange) == 0x000008, "Member 'FFirecrackerEffectData::IsInRange' has a wrong offset!");
static_assert(offsetof(FFirecrackerEffectData, IsFirstTime) == 0x000009, "Member 'FFirecrackerEffectData::IsFirstTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.SlideShowDescription
// 0x0060 (0x0068 - 0x0008)
struct FSlideShowDescription final : public FDBDTableRowBase
{
public:
	class FName                                   Id;                                                // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Overview;                                          // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Playstyle;                                         // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 ImageFilePath;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPerkCategory>                         PerkCategory;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlideShowDescription) == 0x000008, "Wrong alignment on FSlideShowDescription");
static_assert(sizeof(FSlideShowDescription) == 0x000068, "Wrong size on FSlideShowDescription");
static_assert(offsetof(FSlideShowDescription, Id) == 0x000008, "Member 'FSlideShowDescription::Id' has a wrong offset!");
static_assert(offsetof(FSlideShowDescription, Overview) == 0x000018, "Member 'FSlideShowDescription::Overview' has a wrong offset!");
static_assert(offsetof(FSlideShowDescription, Playstyle) == 0x000030, "Member 'FSlideShowDescription::Playstyle' has a wrong offset!");
static_assert(offsetof(FSlideShowDescription, ImageFilePath) == 0x000048, "Member 'FSlideShowDescription::ImageFilePath' has a wrong offset!");
static_assert(offsetof(FSlideShowDescription, PerkCategory) == 0x000058, "Member 'FSlideShowDescription::PerkCategory' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveDefinition
// 0x00C0 (0x00D8 - 0x0018)
struct FArchiveDefinition final : public FDBDTableRowBaseWithId
{
public:
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 PurchasePassPicturePath;                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PurchaseTierPicturePath;                           // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PurchasePassPopupMessage;                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EArchivesEventStyle                           EventStyle;                                        // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              StoryBookMarkTexture;                              // 0x0088(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StyleFrameLabel;                                   // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventStoryLabel;                                   // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchiveDefinition) == 0x000008, "Wrong alignment on FArchiveDefinition");
static_assert(sizeof(FArchiveDefinition) == 0x0000D8, "Wrong size on FArchiveDefinition");
static_assert(offsetof(FArchiveDefinition, Title) == 0x000018, "Member 'FArchiveDefinition::Title' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, Description) == 0x000030, "Member 'FArchiveDefinition::Description' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, PurchasePassPicturePath) == 0x000048, "Member 'FArchiveDefinition::PurchasePassPicturePath' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, PurchaseTierPicturePath) == 0x000058, "Member 'FArchiveDefinition::PurchaseTierPicturePath' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, PurchasePassPopupMessage) == 0x000068, "Member 'FArchiveDefinition::PurchasePassPopupMessage' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, EventStyle) == 0x000080, "Member 'FArchiveDefinition::EventStyle' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, StoryBookMarkTexture) == 0x000088, "Member 'FArchiveDefinition::StoryBookMarkTexture' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, StyleFrameLabel) == 0x0000B8, "Member 'FArchiveDefinition::StyleFrameLabel' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, EventStoryLabel) == 0x0000C8, "Member 'FArchiveDefinition::EventStoryLabel' has a wrong offset!");

// ScriptStruct DeadByDaylight.SnappingData
// 0x0024 (0x0024 - 0x0000)
struct FSnappingData final
{
public:
	bool                                          DoSnapPosition;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoSnapRotation;                                    // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoSnapRoll;                                        // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseZCoord;                                         // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SweepOnFinalSnap;                                  // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetPosition;                                    // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSnappingData) == 0x000004, "Wrong alignment on FSnappingData");
static_assert(sizeof(FSnappingData) == 0x000024, "Wrong size on FSnappingData");
static_assert(offsetof(FSnappingData, DoSnapPosition) == 0x000000, "Member 'FSnappingData::DoSnapPosition' has a wrong offset!");
static_assert(offsetof(FSnappingData, DoSnapRotation) == 0x000001, "Member 'FSnappingData::DoSnapRotation' has a wrong offset!");
static_assert(offsetof(FSnappingData, DoSnapRoll) == 0x000002, "Member 'FSnappingData::DoSnapRoll' has a wrong offset!");
static_assert(offsetof(FSnappingData, UseZCoord) == 0x000003, "Member 'FSnappingData::UseZCoord' has a wrong offset!");
static_assert(offsetof(FSnappingData, SweepOnFinalSnap) == 0x000004, "Member 'FSnappingData::SweepOnFinalSnap' has a wrong offset!");
static_assert(offsetof(FSnappingData, TargetPosition) == 0x000008, "Member 'FSnappingData::TargetPosition' has a wrong offset!");
static_assert(offsetof(FSnappingData, TargetRotation) == 0x000014, "Member 'FSnappingData::TargetRotation' has a wrong offset!");
static_assert(offsetof(FSnappingData, Duration) == 0x000020, "Member 'FSnappingData::Duration' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodwebNodeGate
// 0x0020 (0x0020 - 0x0000)
struct FLegacySavedBloodwebNodeGate final
{
public:
	class FName                                   Description;                                       // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x000C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x000D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBloodwebNodeGateTypes                        GateType;                                          // 0x000E(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Param;                                             // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodwebNodeGate) == 0x000008, "Wrong alignment on FLegacySavedBloodwebNodeGate");
static_assert(sizeof(FLegacySavedBloodwebNodeGate) == 0x000020, "Wrong size on FLegacySavedBloodwebNodeGate");
static_assert(offsetof(FLegacySavedBloodwebNodeGate, Description) == 0x000000, "Member 'FLegacySavedBloodwebNodeGate::Description' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeGate, Rarity) == 0x00000C, "Member 'FLegacySavedBloodwebNodeGate::Rarity' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeGate, Role) == 0x00000D, "Member 'FLegacySavedBloodwebNodeGate::Role' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeGate, GateType) == 0x00000E, "Member 'FLegacySavedBloodwebNodeGate::GateType' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeGate, Param) == 0x000010, "Member 'FLegacySavedBloodwebNodeGate::Param' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerDataForQuestConditions
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FPlayerDataForQuestConditions final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataForQuestConditions) == 0x000008, "Wrong alignment on FPlayerDataForQuestConditions");
static_assert(sizeof(FPlayerDataForQuestConditions) == 0x000078, "Wrong size on FPlayerDataForQuestConditions");

// ScriptStruct DeadByDaylight.AITunableParameter
// 0x0010 (0x0010 - 0x0000)
struct FAITunableParameter final
{
public:
	float                                         DefaultValue;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TunableName;                                       // 0x0004(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAITunableParameter) == 0x000004, "Wrong alignment on FAITunableParameter");
static_assert(sizeof(FAITunableParameter) == 0x000010, "Wrong size on FAITunableParameter");
static_assert(offsetof(FAITunableParameter, DefaultValue) == 0x000000, "Member 'FAITunableParameter::DefaultValue' has a wrong offset!");
static_assert(offsetof(FAITunableParameter, TunableName) == 0x000004, "Member 'FAITunableParameter::TunableName' has a wrong offset!");

// ScriptStruct DeadByDaylight.FriendWidgetList
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FFriendWidgetList final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFriendWidgetList) == 0x000008, "Wrong alignment on FFriendWidgetList");
static_assert(sizeof(FFriendWidgetList) == 0x000010, "Wrong size on FFriendWidgetList");

// ScriptStruct DeadByDaylight.AIRoll
// 0x0024 (0x0024 - 0x0000)
struct FAIRoll final
{
public:
	struct FAITunableParameter                    Random;                                            // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    OnFailCooldown;                                    // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIRoll) == 0x000004, "Wrong alignment on FAIRoll");
static_assert(sizeof(FAIRoll) == 0x000024, "Wrong size on FAIRoll");
static_assert(offsetof(FAIRoll, Random) == 0x000000, "Member 'FAIRoll::Random' has a wrong offset!");
static_assert(offsetof(FAIRoll, OnFailCooldown) == 0x000010, "Member 'FAIRoll::OnFailCooldown' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurfaceTypeName
// 0x0010 (0x0018 - 0x0008)
struct FSurfaceTypeName final : public FDBDTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSurfaceTypeName) == 0x000008, "Wrong alignment on FSurfaceTypeName");
static_assert(sizeof(FSurfaceTypeName) == 0x000018, "Wrong size on FSurfaceTypeName");
static_assert(offsetof(FSurfaceTypeName, Name) == 0x000008, "Member 'FSurfaceTypeName::Name' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkIdDropdown
// 0x0000 (0x0010 - 0x0010)
struct FPerkIdDropdown final : public FPerkDropdown
{
};
static_assert(alignof(FPerkIdDropdown) == 0x000004, "Wrong alignment on FPerkIdDropdown");
static_assert(sizeof(FPerkIdDropdown) == 0x000010, "Wrong size on FPerkIdDropdown");

// ScriptStruct DeadByDaylight.ClippedActor
// 0x0060 (0x0060 - 0x0000)
struct FClippedActor final
{
public:
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> DisplayComponents;                             // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UPrimitiveComponent*, TWeakObjectPtr<class UPrimitiveComponent>> CollidingPrimitives; // 0x0010(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClippedActor) == 0x000008, "Wrong alignment on FClippedActor");
static_assert(sizeof(FClippedActor) == 0x000060, "Wrong size on FClippedActor");
static_assert(offsetof(FClippedActor, DisplayComponents) == 0x000000, "Member 'FClippedActor::DisplayComponents' has a wrong offset!");
static_assert(offsetof(FClippedActor, CollidingPrimitives) == 0x000010, "Member 'FClippedActor::CollidingPrimitives' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterCustomizationPreset
// 0x0038 (0x0038 - 0x0000)
struct FCharacterCustomizationPreset final
{
public:
	class FName                                   Head;                                              // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TorsoOrBody;                                       // 0x000C(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LegsOrWeapon;                                      // 0x0018(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharmIdSlot>                   Charms;                                            // 0x0028(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCustomizationPreset) == 0x000008, "Wrong alignment on FCharacterCustomizationPreset");
static_assert(sizeof(FCharacterCustomizationPreset) == 0x000038, "Wrong size on FCharacterCustomizationPreset");
static_assert(offsetof(FCharacterCustomizationPreset, Head) == 0x000000, "Member 'FCharacterCustomizationPreset::Head' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationPreset, TorsoOrBody) == 0x00000C, "Member 'FCharacterCustomizationPreset::TorsoOrBody' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationPreset, LegsOrWeapon) == 0x000018, "Member 'FCharacterCustomizationPreset::LegsOrWeapon' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationPreset, Charms) == 0x000028, "Member 'FCharacterCustomizationPreset::Charms' has a wrong offset!");

// ScriptStruct DeadByDaylight.ActorSpawnerProperties
// 0x0038 (0x0038 - 0x0000)
struct FActorSpawnerProperties final
{
public:
	TSoftClassPtr<class UClass>                   SceneElement;                                      // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorSpawnerProperties) == 0x000008, "Wrong alignment on FActorSpawnerProperties");
static_assert(sizeof(FActorSpawnerProperties) == 0x000038, "Wrong size on FActorSpawnerProperties");
static_assert(offsetof(FActorSpawnerProperties, SceneElement) == 0x000000, "Member 'FActorSpawnerProperties::SceneElement' has a wrong offset!");
static_assert(offsetof(FActorSpawnerProperties, Weight) == 0x000030, "Member 'FActorSpawnerProperties::Weight' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpawnerElement
// 0x0010 (0x0010 - 0x0000)
struct FSpawnerElement final
{
public:
	TArray<struct FActorSpawnerProperties>        ObjectsToBeSpawned;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnerElement) == 0x000008, "Wrong alignment on FSpawnerElement");
static_assert(sizeof(FSpawnerElement) == 0x000010, "Wrong size on FSpawnerElement");
static_assert(offsetof(FSpawnerElement, ObjectsToBeSpawned) == 0x000000, "Member 'FSpawnerElement::ObjectsToBeSpawned' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterAnimationAssetDropdown
// 0x0018 (0x0018 - 0x0000)
struct FCharacterAnimationAssetDropdown
{
public:
	bool                                          IsAnimBP;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimAsset;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnimationAssetDropdown) == 0x000008, "Wrong alignment on FCharacterAnimationAssetDropdown");
static_assert(sizeof(FCharacterAnimationAssetDropdown) == 0x000018, "Wrong size on FCharacterAnimationAssetDropdown");
static_assert(offsetof(FCharacterAnimationAssetDropdown, IsAnimBP) == 0x000000, "Member 'FCharacterAnimationAssetDropdown::IsAnimBP' has a wrong offset!");
static_assert(offsetof(FCharacterAnimationAssetDropdown, AnimAsset) == 0x000008, "Member 'FCharacterAnimationAssetDropdown::AnimAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterAnimationAssetOutfitOverride
// 0x0010 (0x0028 - 0x0018)
struct FCharacterAnimationAssetOutfitOverride final : public FCharacterAnimationAssetDropdown
{
public:
	class FName                                   OutfitId;                                          // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterAnimationAssetOutfitOverride) == 0x000008, "Wrong alignment on FCharacterAnimationAssetOutfitOverride");
static_assert(sizeof(FCharacterAnimationAssetOutfitOverride) == 0x000028, "Wrong size on FCharacterAnimationAssetOutfitOverride");
static_assert(offsetof(FCharacterAnimationAssetOutfitOverride, OutfitId) == 0x000018, "Member 'FCharacterAnimationAssetOutfitOverride::OutfitId' has a wrong offset!");

// ScriptStruct DeadByDaylight.ActorVariationElements
// 0x0038 (0x0038 - 0x0000)
struct FActorVariationElements final
{
public:
	ETileVariation                                Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   Element;                                           // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorVariationElements) == 0x000008, "Wrong alignment on FActorVariationElements");
static_assert(sizeof(FActorVariationElements) == 0x000038, "Wrong size on FActorVariationElements");
static_assert(offsetof(FActorVariationElements, Type) == 0x000000, "Member 'FActorVariationElements::Type' has a wrong offset!");
static_assert(offsetof(FActorVariationElements, Element) == 0x000008, "Member 'FActorVariationElements::Element' has a wrong offset!");

// ScriptStruct DeadByDaylight.AddonDropdown
// 0x000E (0x0010 - 0x0002)
struct FAddonDropdown final : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AddonID;                                           // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddonDropdown) == 0x000004, "Wrong alignment on FAddonDropdown");
static_assert(sizeof(FAddonDropdown) == 0x000010, "Wrong size on FAddonDropdown");
static_assert(offsetof(FAddonDropdown, AddonID) == 0x000004, "Member 'FAddonDropdown::AddonID' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizedMeshPart
// 0x0048 (0x0048 - 0x0000)
struct FCustomizedMeshPart final
{
public:
	ECustomizationCategory                        Category;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableDropdown                     DefaultItemId;                                     // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizedMeshPart) == 0x000008, "Wrong alignment on FCustomizedMeshPart");
static_assert(sizeof(FCustomizedMeshPart) == 0x000048, "Wrong size on FCustomizedMeshPart");
static_assert(offsetof(FCustomizedMeshPart, Category) == 0x000000, "Member 'FCustomizedMeshPart::Category' has a wrong offset!");
static_assert(offsetof(FCustomizedMeshPart, DefaultItemId) == 0x000008, "Member 'FCustomizedMeshPart::DefaultItemId' has a wrong offset!");
static_assert(offsetof(FCustomizedMeshPart, SocketName) == 0x000038, "Member 'FCustomizedMeshPart::SocketName' has a wrong offset!");

// ScriptStruct DeadByDaylight.AimAssistInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FAimAssistInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAimAssistInfo) == 0x000004, "Wrong alignment on FAimAssistInfo");
static_assert(sizeof(FAimAssistInfo) == 0x000018, "Wrong size on FAimAssistInfo");

// ScriptStruct DeadByDaylight.CharacterSlideData
// 0x0068 (0x0068 - 0x0000)
struct FCharacterSlideData final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Overview;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Playstyle;                                         // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ImageFilePath;                                     // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPerkCategory>                         SurvivorPerkCategories;                            // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class FString                                 KillerPowerIconPath;                               // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSlideData) == 0x000008, "Wrong alignment on FCharacterSlideData");
static_assert(sizeof(FCharacterSlideData) == 0x000068, "Wrong size on FCharacterSlideData");
static_assert(offsetof(FCharacterSlideData, DisplayName) == 0x000000, "Member 'FCharacterSlideData::DisplayName' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, Overview) == 0x000010, "Member 'FCharacterSlideData::Overview' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, Playstyle) == 0x000020, "Member 'FCharacterSlideData::Playstyle' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, Role) == 0x000030, "Member 'FCharacterSlideData::Role' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, ImageFilePath) == 0x000038, "Member 'FCharacterSlideData::ImageFilePath' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, SurvivorPerkCategories) == 0x000048, "Member 'FCharacterSlideData::SurvivorPerkCategories' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, KillerPowerIconPath) == 0x000058, "Member 'FCharacterSlideData::KillerPowerIconPath' has a wrong offset!");

// ScriptStruct DeadByDaylight.AnimationMapping
// 0x0050 (0x0058 - 0x0008)
struct FAnimationMapping final : public FDBDTableRowBase
{
public:
	TSoftObjectPtr<class UAnimMontage>            MontageAsset;                                      // 0x0008(0x0030)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           Tags;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           _montage;                                          // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _loadAttempted;                                    // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationMapping) == 0x000008, "Wrong alignment on FAnimationMapping");
static_assert(sizeof(FAnimationMapping) == 0x000058, "Wrong size on FAnimationMapping");
static_assert(offsetof(FAnimationMapping, MontageAsset) == 0x000008, "Member 'FAnimationMapping::MontageAsset' has a wrong offset!");
static_assert(offsetof(FAnimationMapping, Tags) == 0x000038, "Member 'FAnimationMapping::Tags' has a wrong offset!");
static_assert(offsetof(FAnimationMapping, _montage) == 0x000048, "Member 'FAnimationMapping::_montage' has a wrong offset!");
static_assert(offsetof(FAnimationMapping, _loadAttempted) == 0x000050, "Member 'FAnimationMapping::_loadAttempted' has a wrong offset!");

// ScriptStruct DeadByDaylight.AnimationMappingRow
// 0x0010 (0x0018 - 0x0008)
struct FAnimationMappingRow final : public FDBDTableRowBase
{
public:
	TArray<struct FAnimationMapping>              Mappings;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationMappingRow) == 0x000008, "Wrong alignment on FAnimationMappingRow");
static_assert(sizeof(FAnimationMappingRow) == 0x000018, "Wrong size on FAnimationMappingRow");
static_assert(offsetof(FAnimationMappingRow, Mappings) == 0x000008, "Member 'FAnimationMappingRow::Mappings' has a wrong offset!");

// ScriptStruct DeadByDaylight.PrestigeData
// 0x0008 (0x0008 - 0x0000)
struct FPrestigeData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrestigeData) == 0x000004, "Wrong alignment on FPrestigeData");
static_assert(sizeof(FPrestigeData) == 0x000008, "Wrong size on FPrestigeData");
static_assert(offsetof(FPrestigeData, Level) == 0x000000, "Member 'FPrestigeData::Level' has a wrong offset!");
static_assert(offsetof(FPrestigeData, Progress) == 0x000004, "Member 'FPrestigeData::Progress' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaFreeTicketAffectedUIData
// 0x0030 (0x0030 - 0x0000)
struct FAtlantaFreeTicketAffectedUIData final
{
public:
	class FString                                 InEffectBGFilePath;                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Id;                                                // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              EndDate;                                           // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasFreeTicketToUse;                                // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaFreeTicketAffectedUIData) == 0x000008, "Wrong alignment on FAtlantaFreeTicketAffectedUIData");
static_assert(sizeof(FAtlantaFreeTicketAffectedUIData) == 0x000030, "Wrong size on FAtlantaFreeTicketAffectedUIData");
static_assert(offsetof(FAtlantaFreeTicketAffectedUIData, InEffectBGFilePath) == 0x000000, "Member 'FAtlantaFreeTicketAffectedUIData::InEffectBGFilePath' has a wrong offset!");
static_assert(offsetof(FAtlantaFreeTicketAffectedUIData, Id) == 0x000010, "Member 'FAtlantaFreeTicketAffectedUIData::Id' has a wrong offset!");
static_assert(offsetof(FAtlantaFreeTicketAffectedUIData, EndDate) == 0x000020, "Member 'FAtlantaFreeTicketAffectedUIData::EndDate' has a wrong offset!");
static_assert(offsetof(FAtlantaFreeTicketAffectedUIData, HasFreeTicketToUse) == 0x000028, "Member 'FAtlantaFreeTicketAffectedUIData::HasFreeTicketToUse' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSlotData
// 0x0180 (0x0180 - 0x0000)
struct FCharacterSlotData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Id;                                                // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterIndex;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFilePath;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundImagePath;                               // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Biography;                                         // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DLCId;                                             // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DLCTitle;                                          // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrestigeData                          PrestigeData;                                      // 0x007C(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	ECharacterDifficulty                          Difficulty;                                        // 0x0084(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnlocked;                                        // 0x0085(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDLCPurchasable;                                  // 0x0086(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87[0x1];                                       // 0x0087(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPurchaseCurrencyData>          PurchaseDataList;                                  // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         ItemsOwned;                                        // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalItems;                                        // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowNew;                                           // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDlcLockedKiller;                                 // 0x00A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventUIInfo                    EventInfo;                                         // 0x00A8(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          HasNonSelectedPerks;                               // 0x0110(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAtlantaFreeTicketAffectedUIData       FreeTicketAffectedData;                            // 0x0118(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x30];                                     // 0x0148(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerRole                                   PlayerRole;                                        // 0x0178(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterSlotData) == 0x000008, "Wrong alignment on FCharacterSlotData");
static_assert(sizeof(FCharacterSlotData) == 0x000180, "Wrong size on FCharacterSlotData");
static_assert(offsetof(FCharacterSlotData, Id) == 0x000008, "Member 'FCharacterSlotData::Id' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, CharacterIndex) == 0x000014, "Member 'FCharacterSlotData::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IconFilePath) == 0x000018, "Member 'FCharacterSlotData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, BackgroundImagePath) == 0x000028, "Member 'FCharacterSlotData::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, DisplayName) == 0x000038, "Member 'FCharacterSlotData::DisplayName' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, Biography) == 0x000048, "Member 'FCharacterSlotData::Biography' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, DLCId) == 0x000058, "Member 'FCharacterSlotData::DLCId' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, DLCTitle) == 0x000068, "Member 'FCharacterSlotData::DLCTitle' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, Level) == 0x000078, "Member 'FCharacterSlotData::Level' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, PrestigeData) == 0x00007C, "Member 'FCharacterSlotData::PrestigeData' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, Difficulty) == 0x000084, "Member 'FCharacterSlotData::Difficulty' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IsUnlocked) == 0x000085, "Member 'FCharacterSlotData::IsUnlocked' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IsDLCPurchasable) == 0x000086, "Member 'FCharacterSlotData::IsDLCPurchasable' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, PurchaseDataList) == 0x000088, "Member 'FCharacterSlotData::PurchaseDataList' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, ItemsOwned) == 0x000098, "Member 'FCharacterSlotData::ItemsOwned' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, TotalItems) == 0x00009C, "Member 'FCharacterSlotData::TotalItems' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, ShowNew) == 0x0000A0, "Member 'FCharacterSlotData::ShowNew' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IsDlcLockedKiller) == 0x0000A1, "Member 'FCharacterSlotData::IsDlcLockedKiller' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, EventInfo) == 0x0000A8, "Member 'FCharacterSlotData::EventInfo' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IsEnabled) == 0x000108, "Member 'FCharacterSlotData::IsEnabled' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, HasNonSelectedPerks) == 0x000110, "Member 'FCharacterSlotData::HasNonSelectedPerks' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, FreeTicketAffectedData) == 0x000118, "Member 'FCharacterSlotData::FreeTicketAffectedData' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, PlayerRole) == 0x000178, "Member 'FCharacterSlotData::PlayerRole' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveS3Journal
// 0x0008 (0x0008 - 0x0000)
struct FArchiveS3Journal final
{
public:
	int32                                         Nodes;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingPages;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchiveS3Journal) == 0x000004, "Wrong alignment on FArchiveS3Journal");
static_assert(sizeof(FArchiveS3Journal) == 0x000008, "Wrong size on FArchiveS3Journal");
static_assert(offsetof(FArchiveS3Journal, Nodes) == 0x000000, "Member 'FArchiveS3Journal::Nodes' has a wrong offset!");
static_assert(offsetof(FArchiveS3Journal, StartingPages) == 0x000004, "Member 'FArchiveS3Journal::StartingPages' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuestEventDefinition
// 0x0040 (0x0058 - 0x0018)
struct FQuestEventDefinition final : public FDBDTableRowBaseWithId
{
public:
	TArray<struct FGameplayTag>                   TrackedGameEvents;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   QuestEventEvaluator;                               // 0x0028(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestEventDefinition) == 0x000008, "Wrong alignment on FQuestEventDefinition");
static_assert(sizeof(FQuestEventDefinition) == 0x000058, "Wrong size on FQuestEventDefinition");
static_assert(offsetof(FQuestEventDefinition, TrackedGameEvents) == 0x000018, "Member 'FQuestEventDefinition::TrackedGameEvents' has a wrong offset!");
static_assert(offsetof(FQuestEventDefinition, QuestEventEvaluator) == 0x000028, "Member 'FQuestEventDefinition::QuestEventEvaluator' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterLoadoutPreset
// 0x0040 (0x0040 - 0x0000)
struct FCharacterLoadoutPreset final
{
public:
	class FName                                   PowerOrItem;                                       // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AddOns;                                            // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           Perks;                                             // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FName                                   Favor;                                             // 0x0030(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterLoadoutPreset) == 0x000008, "Wrong alignment on FCharacterLoadoutPreset");
static_assert(sizeof(FCharacterLoadoutPreset) == 0x000040, "Wrong size on FCharacterLoadoutPreset");
static_assert(offsetof(FCharacterLoadoutPreset, PowerOrItem) == 0x000000, "Member 'FCharacterLoadoutPreset::PowerOrItem' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPreset, AddOns) == 0x000010, "Member 'FCharacterLoadoutPreset::AddOns' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPreset, Perks) == 0x000020, "Member 'FCharacterLoadoutPreset::Perks' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPreset, Favor) == 0x000030, "Member 'FCharacterLoadoutPreset::Favor' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveQuestObjectiveDefinition
// 0x0048 (0x0060 - 0x0018)
struct FArchiveQuestObjectiveDefinition final : public FDBDTableRowBaseWithId
{
public:
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RulesDescription;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EQuestProgressionType                         ProgressionType;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DescriptionParameters;                             // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchiveQuestObjectiveDefinition) == 0x000008, "Wrong alignment on FArchiveQuestObjectiveDefinition");
static_assert(sizeof(FArchiveQuestObjectiveDefinition) == 0x000060, "Wrong size on FArchiveQuestObjectiveDefinition");
static_assert(offsetof(FArchiveQuestObjectiveDefinition, Description) == 0x000018, "Member 'FArchiveQuestObjectiveDefinition::Description' has a wrong offset!");
static_assert(offsetof(FArchiveQuestObjectiveDefinition, RulesDescription) == 0x000030, "Member 'FArchiveQuestObjectiveDefinition::RulesDescription' has a wrong offset!");
static_assert(offsetof(FArchiveQuestObjectiveDefinition, ProgressionType) == 0x000048, "Member 'FArchiveQuestObjectiveDefinition::ProgressionType' has a wrong offset!");
static_assert(offsetof(FArchiveQuestObjectiveDefinition, DescriptionParameters) == 0x000050, "Member 'FArchiveQuestObjectiveDefinition::DescriptionParameters' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChaseUpdateInfo
// 0x0048 (0x0048 - 0x0000)
struct FChaseUpdateInfo final
{
public:
	struct FTargetFocusTimer                      ChaseTimer;                                        // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	float                                         SurvivorTravelDistance;                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillerTravelDistance;                              // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            ChaseStartHealthStatus;                            // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChaseUpdateInfo) == 0x000008, "Wrong alignment on FChaseUpdateInfo");
static_assert(sizeof(FChaseUpdateInfo) == 0x000048, "Wrong size on FChaseUpdateInfo");
static_assert(offsetof(FChaseUpdateInfo, ChaseTimer) == 0x000000, "Member 'FChaseUpdateInfo::ChaseTimer' has a wrong offset!");
static_assert(offsetof(FChaseUpdateInfo, SurvivorTravelDistance) == 0x000038, "Member 'FChaseUpdateInfo::SurvivorTravelDistance' has a wrong offset!");
static_assert(offsetof(FChaseUpdateInfo, KillerTravelDistance) == 0x00003C, "Member 'FChaseUpdateInfo::KillerTravelDistance' has a wrong offset!");
static_assert(offsetof(FChaseUpdateInfo, ChaseStartHealthStatus) == 0x000040, "Member 'FChaseUpdateInfo::ChaseStartHealthStatus' has a wrong offset!");

// ScriptStruct DeadByDaylight.RewardTrackTierData
// 0x0038 (0x0038 - 0x0000)
struct FRewardTrackTierData final
{
public:
	uint32                                        TierId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TierGroup;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardResponseItem>            Free;                                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Free_IsSet;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Premium;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Premium_IsSet;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRewardTrackTierData) == 0x000008, "Wrong alignment on FRewardTrackTierData");
static_assert(sizeof(FRewardTrackTierData) == 0x000038, "Wrong size on FRewardTrackTierData");
static_assert(offsetof(FRewardTrackTierData, TierId) == 0x000000, "Member 'FRewardTrackTierData::TierId' has a wrong offset!");
static_assert(offsetof(FRewardTrackTierData, TierGroup) == 0x000004, "Member 'FRewardTrackTierData::TierGroup' has a wrong offset!");
static_assert(offsetof(FRewardTrackTierData, Free) == 0x000008, "Member 'FRewardTrackTierData::Free' has a wrong offset!");
static_assert(offsetof(FRewardTrackTierData, Free_IsSet) == 0x000018, "Member 'FRewardTrackTierData::Free_IsSet' has a wrong offset!");
static_assert(offsetof(FRewardTrackTierData, Premium) == 0x000020, "Member 'FRewardTrackTierData::Premium' has a wrong offset!");
static_assert(offsetof(FRewardTrackTierData, Premium_IsSet) == 0x000030, "Member 'FRewardTrackTierData::Premium_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.RewardTrackData
// 0x0028 (0x0028 - 0x0000)
struct FRewardTrackData final
{
public:
	TArray<struct FRewardTrackTierData>           TierInfo;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        Requirement;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x14];                                      // 0x0014(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRewardTrackData) == 0x000008, "Wrong alignment on FRewardTrackData");
static_assert(sizeof(FRewardTrackData) == 0x000028, "Wrong size on FRewardTrackData");
static_assert(offsetof(FRewardTrackData, TierInfo) == 0x000000, "Member 'FRewardTrackData::TierInfo' has a wrong offset!");
static_assert(offsetof(FRewardTrackData, Requirement) == 0x000010, "Member 'FRewardTrackData::Requirement' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterToolSpawnParameters
// 0x0003 (0x0003 - 0x0000)
struct FCharacterToolSpawnParameters final
{
public:
	bool                                          IsAnimated;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowPower;                                         // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMasterPoseForItems;                             // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterToolSpawnParameters) == 0x000001, "Wrong alignment on FCharacterToolSpawnParameters");
static_assert(sizeof(FCharacterToolSpawnParameters) == 0x000003, "Wrong size on FCharacterToolSpawnParameters");
static_assert(offsetof(FCharacterToolSpawnParameters, IsAnimated) == 0x000000, "Member 'FCharacterToolSpawnParameters::IsAnimated' has a wrong offset!");
static_assert(offsetof(FCharacterToolSpawnParameters, ShowPower) == 0x000001, "Member 'FCharacterToolSpawnParameters::ShowPower' has a wrong offset!");
static_assert(offsetof(FCharacterToolSpawnParameters, UseMasterPoseForItems) == 0x000002, "Member 'FCharacterToolSpawnParameters::UseMasterPoseForItems' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterLevelData
// 0x0020 (0x0020 - 0x0000)
struct FCharacterLevelData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExperienceToNextLevel;                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsComplete;                                        // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPerksBeenSelected;                              // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssignedPerkProperties>        PerkSelection;                                     // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterLevelData) == 0x000008, "Wrong alignment on FCharacterLevelData");
static_assert(sizeof(FCharacterLevelData) == 0x000020, "Wrong size on FCharacterLevelData");
static_assert(offsetof(FCharacterLevelData, Level) == 0x000000, "Member 'FCharacterLevelData::Level' has a wrong offset!");
static_assert(offsetof(FCharacterLevelData, ExperienceToNextLevel) == 0x000004, "Member 'FCharacterLevelData::ExperienceToNextLevel' has a wrong offset!");
static_assert(offsetof(FCharacterLevelData, IsComplete) == 0x000008, "Member 'FCharacterLevelData::IsComplete' has a wrong offset!");
static_assert(offsetof(FCharacterLevelData, HasPerksBeenSelected) == 0x000009, "Member 'FCharacterLevelData::HasPerksBeenSelected' has a wrong offset!");
static_assert(offsetof(FCharacterLevelData, PerkSelection) == 0x000010, "Member 'FCharacterLevelData::PerkSelection' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesConfig
// 0x0004 (0x0004 - 0x0000)
struct FArchivesConfig final
{
public:
	int32                                         CommunityNodeRefreshInterval;                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivesConfig) == 0x000004, "Wrong alignment on FArchivesConfig");
static_assert(sizeof(FArchivesConfig) == 0x000004, "Wrong size on FArchivesConfig");
static_assert(offsetof(FArchivesConfig, CommunityNodeRefreshInterval) == 0x000000, "Member 'FArchivesConfig::CommunityNodeRefreshInterval' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesMapFromS3
// 0x0040 (0x0040 - 0x0000)
struct FArchivesMapFromS3 final
{
public:
	TArray<struct FStoryLevel>                    Level;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 RiftId;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RiftId_IsSet;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpecialEventId;                                    // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpecialEventId_IsSet;                              // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesMapFromS3) == 0x000008, "Wrong alignment on FArchivesMapFromS3");
static_assert(sizeof(FArchivesMapFromS3) == 0x000040, "Wrong size on FArchivesMapFromS3");
static_assert(offsetof(FArchivesMapFromS3, Level) == 0x000000, "Member 'FArchivesMapFromS3::Level' has a wrong offset!");
static_assert(offsetof(FArchivesMapFromS3, RiftId) == 0x000010, "Member 'FArchivesMapFromS3::RiftId' has a wrong offset!");
static_assert(offsetof(FArchivesMapFromS3, RiftId_IsSet) == 0x000020, "Member 'FArchivesMapFromS3::RiftId_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesMapFromS3, SpecialEventId) == 0x000028, "Member 'FArchivesMapFromS3::SpecialEventId' has a wrong offset!");
static_assert(offsetof(FArchivesMapFromS3, SpecialEventId_IsSet) == 0x000038, "Member 'FArchivesMapFromS3::SpecialEventId_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ConsentContentVersionData
// 0x00C0 (0x00C0 - 0x0000)
struct FConsentContentVersionData final
{
public:
	class FString                                 Label;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EntryDate;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            Title;                                             // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            Content;                                           // 0x0068(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConsentContentVersionData) == 0x000008, "Wrong alignment on FConsentContentVersionData");
static_assert(sizeof(FConsentContentVersionData) == 0x0000C0, "Wrong size on FConsentContentVersionData");
static_assert(offsetof(FConsentContentVersionData, Label) == 0x000000, "Member 'FConsentContentVersionData::Label' has a wrong offset!");
static_assert(offsetof(FConsentContentVersionData, EntryDate) == 0x000010, "Member 'FConsentContentVersionData::EntryDate' has a wrong offset!");
static_assert(offsetof(FConsentContentVersionData, Title) == 0x000018, "Member 'FConsentContentVersionData::Title' has a wrong offset!");
static_assert(offsetof(FConsentContentVersionData, Content) == 0x000068, "Member 'FConsentContentVersionData::Content' has a wrong offset!");

// ScriptStruct DeadByDaylight.ConsentContentData
// 0x0020 (0x0020 - 0x0000)
struct FConsentContentData final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConsentContentVersionData>     Versions;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConsentContentData) == 0x000008, "Wrong alignment on FConsentContentData");
static_assert(sizeof(FConsentContentData) == 0x000020, "Wrong size on FConsentContentData");
static_assert(offsetof(FConsentContentData, Id) == 0x000000, "Member 'FConsentContentData::Id' has a wrong offset!");
static_assert(offsetof(FConsentContentData, Versions) == 0x000010, "Member 'FConsentContentData::Versions' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArmIKSensorDatum
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FArmIKSensorDatum final
{
public:
	class FName                                   ShoulderBoneName;                                  // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x24];                                       // 0x000C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArmIKSensorDatum) == 0x000008, "Wrong alignment on FArmIKSensorDatum");
static_assert(sizeof(FArmIKSensorDatum) == 0x000030, "Wrong size on FArmIKSensorDatum");
static_assert(offsetof(FArmIKSensorDatum, ShoulderBoneName) == 0x000000, "Member 'FArmIKSensorDatum::ShoulderBoneName' has a wrong offset!");

// ScriptStruct DeadByDaylight.CurrencyPackData
// 0x0008 (0x01F0 - 0x01E8)
struct FCurrencyPackData final : public FItemData
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x01E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurrencyPackData) == 0x000008, "Wrong alignment on FCurrencyPackData");
static_assert(sizeof(FCurrencyPackData) == 0x0001F0, "Wrong size on FCurrencyPackData");
static_assert(offsetof(FCurrencyPackData, CurrencyType) == 0x0001E8, "Member 'FCurrencyPackData::CurrencyType' has a wrong offset!");

// ScriptStruct DeadByDaylight.AssetLibraryLoader
// 0x0028 (0x0028 - 0x0000)
struct FAssetLibraryLoader final
{
public:
	class UAssetLibrary*                          AssetLibrary;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssetLibraryLoader) == 0x000008, "Wrong alignment on FAssetLibraryLoader");
static_assert(sizeof(FAssetLibraryLoader) == 0x000028, "Wrong size on FAssetLibraryLoader");
static_assert(offsetof(FAssetLibraryLoader, AssetLibrary) == 0x000000, "Member 'FAssetLibraryLoader::AssetLibrary' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContentScheduleRecord
// 0x0140 (0x0140 - 0x0000)
struct FContentScheduleRecord final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Description_IsSet;                                 // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LinkedEventId;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LinkedEventId_IsSet;                               // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    MapsThemeWeight;                                   // 0x0038(0x0050)(NativeAccessSpecifierPublic)
	bool                                          MapsThemeWeight_IsSet;                             // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    MapsWeight;                                        // 0x0090(0x0050)(NativeAccessSpecifierPublic)
	bool                                          MapsWeight_IsSet;                                  // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         FeaturedMap;                                       // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          FeaturedMap_IsSet;                                 // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x17];                                      // 0x00F9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartDate;                                         // 0x0110(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          StartDate_IsSet;                                   // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EndDate;                                           // 0x0128(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EndDate_IsSet;                                     // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContentScheduleRecord) == 0x000008, "Wrong alignment on FContentScheduleRecord");
static_assert(sizeof(FContentScheduleRecord) == 0x000140, "Wrong size on FContentScheduleRecord");
static_assert(offsetof(FContentScheduleRecord, Priority) == 0x000000, "Member 'FContentScheduleRecord::Priority' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, Description) == 0x000008, "Member 'FContentScheduleRecord::Description' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, Description_IsSet) == 0x000018, "Member 'FContentScheduleRecord::Description_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, LinkedEventId) == 0x000020, "Member 'FContentScheduleRecord::LinkedEventId' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, LinkedEventId_IsSet) == 0x000030, "Member 'FContentScheduleRecord::LinkedEventId_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, MapsThemeWeight) == 0x000038, "Member 'FContentScheduleRecord::MapsThemeWeight' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, MapsThemeWeight_IsSet) == 0x000088, "Member 'FContentScheduleRecord::MapsThemeWeight_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, MapsWeight) == 0x000090, "Member 'FContentScheduleRecord::MapsWeight' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, MapsWeight_IsSet) == 0x0000E0, "Member 'FContentScheduleRecord::MapsWeight_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, FeaturedMap) == 0x0000E8, "Member 'FContentScheduleRecord::FeaturedMap' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, FeaturedMap_IsSet) == 0x0000F8, "Member 'FContentScheduleRecord::FeaturedMap_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, StartDate) == 0x000110, "Member 'FContentScheduleRecord::StartDate' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, StartDate_IsSet) == 0x000120, "Member 'FContentScheduleRecord::StartDate_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, EndDate) == 0x000128, "Member 'FContentScheduleRecord::EndDate' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, EndDate_IsSet) == 0x000138, "Member 'FContentScheduleRecord::EndDate_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.CurrencyPurchaseData
// 0x0068 (0x0068 - 0x0000)
struct FCurrencyPurchaseData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconPath;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyName;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyIcon;                                      // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyAmount;                                    // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayedPrice;                                    // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusPercentage;                                   // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              BonusEndDate;                                      // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BasicCurrencyAmount;                               // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurrencyPurchaseData) == 0x000008, "Wrong alignment on FCurrencyPurchaseData");
static_assert(sizeof(FCurrencyPurchaseData) == 0x000068, "Wrong size on FCurrencyPurchaseData");
static_assert(offsetof(FCurrencyPurchaseData, IconPath) == 0x000008, "Member 'FCurrencyPurchaseData::IconPath' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, CurrencyName) == 0x000018, "Member 'FCurrencyPurchaseData::CurrencyName' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, CurrencyIcon) == 0x000028, "Member 'FCurrencyPurchaseData::CurrencyIcon' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, CurrencyAmount) == 0x000038, "Member 'FCurrencyPurchaseData::CurrencyAmount' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, DisplayedPrice) == 0x000040, "Member 'FCurrencyPurchaseData::DisplayedPrice' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, BonusPercentage) == 0x000050, "Member 'FCurrencyPurchaseData::BonusPercentage' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, BonusEndDate) == 0x000058, "Member 'FCurrencyPurchaseData::BonusEndDate' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, BasicCurrencyAmount) == 0x000060, "Member 'FCurrencyPurchaseData::BasicCurrencyAmount' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaAuricCellPacksUIData
// 0x0038 (0x0038 - 0x0000)
struct FAtlantaAuricCellPacksUIData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCurrencyPurchaseData>          CurrencyPurchaseData;                              // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         FirstPurchaseBundleMultiplier;                     // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              FirstPurchaseBundleMultiplierEndDate;              // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSet;                                             // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaAuricCellPacksUIData) == 0x000008, "Wrong alignment on FAtlantaAuricCellPacksUIData");
static_assert(sizeof(FAtlantaAuricCellPacksUIData) == 0x000038, "Wrong size on FAtlantaAuricCellPacksUIData");
static_assert(offsetof(FAtlantaAuricCellPacksUIData, CurrencyPurchaseData) == 0x000010, "Member 'FAtlantaAuricCellPacksUIData::CurrencyPurchaseData' has a wrong offset!");
static_assert(offsetof(FAtlantaAuricCellPacksUIData, FirstPurchaseBundleMultiplier) == 0x000020, "Member 'FAtlantaAuricCellPacksUIData::FirstPurchaseBundleMultiplier' has a wrong offset!");
static_assert(offsetof(FAtlantaAuricCellPacksUIData, FirstPurchaseBundleMultiplierEndDate) == 0x000028, "Member 'FAtlantaAuricCellPacksUIData::FirstPurchaseBundleMultiplierEndDate' has a wrong offset!");
static_assert(offsetof(FAtlantaAuricCellPacksUIData, IsSet) == 0x000030, "Member 'FAtlantaAuricCellPacksUIData::IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.CombinedPartyFriendData
// 0x0168 (0x0168 - 0x0000)
struct alignas(0x08) FCombinedPartyFriendData final
{
public:
	uint8                                         Pad_0[0x168];                                      // 0x0000(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCombinedPartyFriendData) == 0x000008, "Wrong alignment on FCombinedPartyFriendData");
static_assert(sizeof(FCombinedPartyFriendData) == 0x000168, "Wrong size on FCombinedPartyFriendData");

// ScriptStruct DeadByDaylight.AtlantaBaseEventsUIData
// 0x00E8 (0x00E8 - 0x0000)
struct FAtlantaBaseEventsUIData
{
public:
	class FString                                 EventId;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0020(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0038(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FString                                 CampaignName;                                      // 0x0050(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2DDynamic*                      Image;                                             // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventPriority;                                     // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BannerPriority;                                    // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeepLink;                                          // 0x0070(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0080(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DisplayStartDate;                                  // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DisplayEndDate;                                    // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              BannerStartDate;                                   // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              BannerEndDate;                                     // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              HotStartDate;                                      // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              HotEndDate;                                        // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              NewStartDate;                                      // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              NewEndDate;                                        // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         RelatedItemsId;                                    // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          mustHideParticipateButton;                         // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaBaseEventsUIData) == 0x000008, "Wrong alignment on FAtlantaBaseEventsUIData");
static_assert(sizeof(FAtlantaBaseEventsUIData) == 0x0000E8, "Wrong size on FAtlantaBaseEventsUIData");
static_assert(offsetof(FAtlantaBaseEventsUIData, EventId) == 0x000000, "Member 'FAtlantaBaseEventsUIData::EventId' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, Type) == 0x000010, "Member 'FAtlantaBaseEventsUIData::Type' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, Title) == 0x000020, "Member 'FAtlantaBaseEventsUIData::Title' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, Description) == 0x000038, "Member 'FAtlantaBaseEventsUIData::Description' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, CampaignName) == 0x000050, "Member 'FAtlantaBaseEventsUIData::CampaignName' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, Image) == 0x000060, "Member 'FAtlantaBaseEventsUIData::Image' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, EventPriority) == 0x000068, "Member 'FAtlantaBaseEventsUIData::EventPriority' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, BannerPriority) == 0x00006C, "Member 'FAtlantaBaseEventsUIData::BannerPriority' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, DeepLink) == 0x000070, "Member 'FAtlantaBaseEventsUIData::DeepLink' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, StartDate) == 0x000080, "Member 'FAtlantaBaseEventsUIData::StartDate' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, EndDate) == 0x000088, "Member 'FAtlantaBaseEventsUIData::EndDate' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, DisplayStartDate) == 0x000090, "Member 'FAtlantaBaseEventsUIData::DisplayStartDate' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, DisplayEndDate) == 0x000098, "Member 'FAtlantaBaseEventsUIData::DisplayEndDate' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, BannerStartDate) == 0x0000A0, "Member 'FAtlantaBaseEventsUIData::BannerStartDate' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, BannerEndDate) == 0x0000A8, "Member 'FAtlantaBaseEventsUIData::BannerEndDate' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, HotStartDate) == 0x0000B0, "Member 'FAtlantaBaseEventsUIData::HotStartDate' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, HotEndDate) == 0x0000B8, "Member 'FAtlantaBaseEventsUIData::HotEndDate' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, NewStartDate) == 0x0000C0, "Member 'FAtlantaBaseEventsUIData::NewStartDate' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, NewEndDate) == 0x0000C8, "Member 'FAtlantaBaseEventsUIData::NewEndDate' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, RelatedItemsId) == 0x0000D0, "Member 'FAtlantaBaseEventsUIData::RelatedItemsId' has a wrong offset!");
static_assert(offsetof(FAtlantaBaseEventsUIData, mustHideParticipateButton) == 0x0000E0, "Member 'FAtlantaBaseEventsUIData::mustHideParticipateButton' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaBonusACEventsUIData
// 0x0038 (0x0120 - 0x00E8)
struct FAtlantaBonusACEventsUIData final : public FAtlantaBaseEventsUIData
{
public:
	struct FAtlantaAuricCellPacksUIData           auricPacksData;                                    // 0x00E8(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaBonusACEventsUIData) == 0x000008, "Wrong alignment on FAtlantaBonusACEventsUIData");
static_assert(sizeof(FAtlantaBonusACEventsUIData) == 0x000120, "Wrong size on FAtlantaBonusACEventsUIData");
static_assert(offsetof(FAtlantaBonusACEventsUIData, auricPacksData) == 0x0000E8, "Member 'FAtlantaBonusACEventsUIData::auricPacksData' has a wrong offset!");

// ScriptStruct DeadByDaylight.CoreRitualsDifficulty
// 0x0020 (0x0020 - 0x0000)
struct FCoreRitualsDifficulty final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayThreshold;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Rewards;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoreRitualsDifficulty) == 0x000008, "Wrong alignment on FCoreRitualsDifficulty");
static_assert(sizeof(FCoreRitualsDifficulty) == 0x000020, "Wrong size on FCoreRitualsDifficulty");
static_assert(offsetof(FCoreRitualsDifficulty, Threshold) == 0x000000, "Member 'FCoreRitualsDifficulty::Threshold' has a wrong offset!");
static_assert(offsetof(FCoreRitualsDifficulty, Tolerance) == 0x000004, "Member 'FCoreRitualsDifficulty::Tolerance' has a wrong offset!");
static_assert(offsetof(FCoreRitualsDifficulty, DisplayThreshold) == 0x000008, "Member 'FCoreRitualsDifficulty::DisplayThreshold' has a wrong offset!");
static_assert(offsetof(FCoreRitualsDifficulty, Rewards) == 0x000010, "Member 'FCoreRitualsDifficulty::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaCalendarEventsUIData
// 0x0030 (0x0118 - 0x00E8)
struct FAtlantaCalendarEventsUIData final : public FAtlantaBaseEventsUIData
{
public:
	uint8                                         Pad_E8[0x30];                                      // 0x00E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaCalendarEventsUIData) == 0x000008, "Wrong alignment on FAtlantaCalendarEventsUIData");
static_assert(sizeof(FAtlantaCalendarEventsUIData) == 0x000118, "Wrong size on FAtlantaCalendarEventsUIData");

// ScriptStruct DeadByDaylight.AtlantaDeepLinkData
// 0x0018 (0x0020 - 0x0008)
struct FAtlantaDeepLinkData final : public FDBDTableRowBase
{
public:
	class FString                                 Url;                                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeepLinkUid                                  DeepLink;                                          // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasCustomParameters;                               // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaDeepLinkData) == 0x000008, "Wrong alignment on FAtlantaDeepLinkData");
static_assert(sizeof(FAtlantaDeepLinkData) == 0x000020, "Wrong size on FAtlantaDeepLinkData");
static_assert(offsetof(FAtlantaDeepLinkData, Url) == 0x000008, "Member 'FAtlantaDeepLinkData::Url' has a wrong offset!");
static_assert(offsetof(FAtlantaDeepLinkData, DeepLink) == 0x000018, "Member 'FAtlantaDeepLinkData::DeepLink' has a wrong offset!");
static_assert(offsetof(FAtlantaDeepLinkData, HasCustomParameters) == 0x000019, "Member 'FAtlantaDeepLinkData::HasCustomParameters' has a wrong offset!");

// ScriptStruct DeadByDaylight.BPAttachementSocketData
// 0x00E0 (0x00E0 - 0x0000)
struct FBPAttachementSocketData final
{
public:
	TSoftClassPtr<class UClass>                   AccessoryBlueprint;                                // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialReplacerData>          MaterialsMap;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FConditionalMaterialReplacer           ConditionalMaterialReplacer;                       // 0x0080(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBPAttachementSocketData) == 0x000008, "Wrong alignment on FBPAttachementSocketData");
static_assert(sizeof(FBPAttachementSocketData) == 0x0000E0, "Wrong size on FBPAttachementSocketData");
static_assert(offsetof(FBPAttachementSocketData, AccessoryBlueprint) == 0x000000, "Member 'FBPAttachementSocketData::AccessoryBlueprint' has a wrong offset!");
static_assert(offsetof(FBPAttachementSocketData, SkeletalMesh) == 0x000030, "Member 'FBPAttachementSocketData::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FBPAttachementSocketData, SocketName) == 0x000060, "Member 'FBPAttachementSocketData::SocketName' has a wrong offset!");
static_assert(offsetof(FBPAttachementSocketData, MaterialsMap) == 0x000070, "Member 'FBPAttachementSocketData::MaterialsMap' has a wrong offset!");
static_assert(offsetof(FBPAttachementSocketData, ConditionalMaterialReplacer) == 0x000080, "Member 'FBPAttachementSocketData::ConditionalMaterialReplacer' has a wrong offset!");

// ScriptStruct DeadByDaylight.DeviceProfiles
// 0x0038 (0x0040 - 0x0008)
struct FDeviceProfiles final : public FDBDTableRowBase
{
public:
	class FText                                   CPU;                                               // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GPU;                                               // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeviceProfiles) == 0x000008, "Wrong alignment on FDeviceProfiles");
static_assert(sizeof(FDeviceProfiles) == 0x000040, "Wrong size on FDeviceProfiles");
static_assert(offsetof(FDeviceProfiles, CPU) == 0x000008, "Member 'FDeviceProfiles::CPU' has a wrong offset!");
static_assert(offsetof(FDeviceProfiles, GPU) == 0x000020, "Member 'FDeviceProfiles::GPU' has a wrong offset!");
static_assert(offsetof(FDeviceProfiles, Quality) == 0x000038, "Member 'FDeviceProfiles::Quality' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaEventElementUIData
// 0x0030 (0x0030 - 0x0000)
struct FAtlantaEventElementUIData final
{
public:
	EPromoPackContentType                         ElementType;                                       // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FName                                   NameID;                                            // 0x0020(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaEventElementUIData) == 0x000008, "Wrong alignment on FAtlantaEventElementUIData");
static_assert(sizeof(FAtlantaEventElementUIData) == 0x000030, "Wrong size on FAtlantaEventElementUIData");
static_assert(offsetof(FAtlantaEventElementUIData, ElementType) == 0x000000, "Member 'FAtlantaEventElementUIData::ElementType' has a wrong offset!");
static_assert(offsetof(FAtlantaEventElementUIData, DisplayName) == 0x000008, "Member 'FAtlantaEventElementUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FAtlantaEventElementUIData, NameID) == 0x000020, "Member 'FAtlantaEventElementUIData::NameID' has a wrong offset!");
static_assert(offsetof(FAtlantaEventElementUIData, Color) == 0x00002C, "Member 'FAtlantaEventElementUIData::Color' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationCategoryData
// 0x0040 (0x0048 - 0x0008)
struct FCustomizationCategoryData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationCategory                        Category;                                          // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconPath;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationCategoryData) == 0x000008, "Wrong alignment on FCustomizationCategoryData");
static_assert(sizeof(FCustomizationCategoryData) == 0x000048, "Wrong size on FCustomizationCategoryData");
static_assert(offsetof(FCustomizationCategoryData, ID) == 0x000008, "Member 'FCustomizationCategoryData::ID' has a wrong offset!");
static_assert(offsetof(FCustomizationCategoryData, Category) == 0x000014, "Member 'FCustomizationCategoryData::Category' has a wrong offset!");
static_assert(offsetof(FCustomizationCategoryData, IconPath) == 0x000018, "Member 'FCustomizationCategoryData::IconPath' has a wrong offset!");
static_assert(offsetof(FCustomizationCategoryData, DisplayName) == 0x000028, "Member 'FCustomizationCategoryData::DisplayName' has a wrong offset!");
static_assert(offsetof(FCustomizationCategoryData, Role) == 0x000040, "Member 'FCustomizationCategoryData::Role' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaFreeTicketUIData
// 0x0028 (0x0210 - 0x01E8)
struct FAtlantaFreeTicketUIData final : public FItemData
{
public:
	struct FSlateColor                            IconColor;                                         // 0x01E8(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaFreeTicketUIData) == 0x000008, "Wrong alignment on FAtlantaFreeTicketUIData");
static_assert(sizeof(FAtlantaFreeTicketUIData) == 0x000210, "Wrong size on FAtlantaFreeTicketUIData");
static_assert(offsetof(FAtlantaFreeTicketUIData, IconColor) == 0x0001E8, "Member 'FAtlantaFreeTicketUIData::IconColor' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaFreeTicketCombinedData
// 0x0220 (0x0220 - 0x0000)
struct FAtlantaFreeTicketCombinedData final
{
public:
	struct FAtlantaFreeTicketUIData               UIData;                                            // 0x0000(0x0210)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x0210(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DurationInMinutes;                                 // 0x0214(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0218(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaFreeTicketCombinedData) == 0x000008, "Wrong alignment on FAtlantaFreeTicketCombinedData");
static_assert(sizeof(FAtlantaFreeTicketCombinedData) == 0x000220, "Wrong size on FAtlantaFreeTicketCombinedData");
static_assert(offsetof(FAtlantaFreeTicketCombinedData, UIData) == 0x000000, "Member 'FAtlantaFreeTicketCombinedData::UIData' has a wrong offset!");
static_assert(offsetof(FAtlantaFreeTicketCombinedData, Role) == 0x000210, "Member 'FAtlantaFreeTicketCombinedData::Role' has a wrong offset!");
static_assert(offsetof(FAtlantaFreeTicketCombinedData, DurationInMinutes) == 0x000214, "Member 'FAtlantaFreeTicketCombinedData::DurationInMinutes' has a wrong offset!");
static_assert(offsetof(FAtlantaFreeTicketCombinedData, Quantity) == 0x000218, "Member 'FAtlantaFreeTicketCombinedData::Quantity' has a wrong offset!");

// ScriptStruct DeadByDaylight.CoreRitualsTunables
// 0x0004 (0x0004 - 0x0000)
struct FCoreRitualsTunables final
{
public:
	int32                                         MaxRituals;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoreRitualsTunables) == 0x000004, "Wrong alignment on FCoreRitualsTunables");
static_assert(sizeof(FCoreRitualsTunables) == 0x000004, "Wrong size on FCoreRitualsTunables");
static_assert(offsetof(FCoreRitualsTunables, MaxRituals) == 0x000000, "Member 'FCoreRitualsTunables::MaxRituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.CoreRitualsEntry
// 0x0020 (0x0020 - 0x0000)
struct FCoreRitualsEntry final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCoreRitualsDifficulty>         Difficulty;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoreRitualsEntry) == 0x000008, "Wrong alignment on FCoreRitualsEntry");
static_assert(sizeof(FCoreRitualsEntry) == 0x000020, "Wrong size on FCoreRitualsEntry");
static_assert(offsetof(FCoreRitualsEntry, Id) == 0x000000, "Member 'FCoreRitualsEntry::Id' has a wrong offset!");
static_assert(offsetof(FCoreRitualsEntry, Difficulty) == 0x000010, "Member 'FCoreRitualsEntry::Difficulty' has a wrong offset!");

// ScriptStruct DeadByDaylight.CoreRitualsContent
// 0x0018 (0x0018 - 0x0000)
struct FCoreRitualsContent final
{
public:
	struct FCoreRitualsTunables                   Config;                                            // 0x0000(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCoreRitualsEntry>              Data;                                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoreRitualsContent) == 0x000008, "Wrong alignment on FCoreRitualsContent");
static_assert(sizeof(FCoreRitualsContent) == 0x000018, "Wrong size on FCoreRitualsContent");
static_assert(offsetof(FCoreRitualsContent, Config) == 0x000000, "Member 'FCoreRitualsContent::Config' has a wrong offset!");
static_assert(offsetof(FCoreRitualsContent, Data) == 0x000008, "Member 'FCoreRitualsContent::Data' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomSoundFXData
// 0x0018 (0x0018 - 0x0000)
struct FCustomSoundFXData final
{
public:
	EAudioCustomizationCategory                   AudioCategory;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SwitchState;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomSoundFXData) == 0x000008, "Wrong alignment on FCustomSoundFXData");
static_assert(sizeof(FCustomSoundFXData) == 0x000018, "Wrong size on FCustomSoundFXData");
static_assert(offsetof(FCustomSoundFXData, AudioCategory) == 0x000000, "Member 'FCustomSoundFXData::AudioCategory' has a wrong offset!");
static_assert(offsetof(FCustomSoundFXData, SwitchState) == 0x000008, "Member 'FCustomSoundFXData::SwitchState' has a wrong offset!");

// ScriptStruct DeadByDaylight.AccessoryLoadingData
// 0x00E8 (0x00E8 - 0x0000)
struct FAccessoryLoadingData final
{
public:
	uint8                                         Pad_0[0xE0];                                       // 0x0000(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAccessory*                             Accessory;                                         // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessoryLoadingData) == 0x000008, "Wrong alignment on FAccessoryLoadingData");
static_assert(sizeof(FAccessoryLoadingData) == 0x0000E8, "Wrong size on FAccessoryLoadingData");
static_assert(offsetof(FAccessoryLoadingData, Accessory) == 0x0000E0, "Member 'FAccessoryLoadingData::Accessory' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaGenericEventUIData
// 0x0010 (0x00F8 - 0x00E8)
struct FAtlantaGenericEventUIData final : public FAtlantaBaseEventsUIData
{
public:
	TArray<struct FAtlantaEventElementUIData>     elementsUIData;                                    // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaGenericEventUIData) == 0x000008, "Wrong alignment on FAtlantaGenericEventUIData");
static_assert(sizeof(FAtlantaGenericEventUIData) == 0x0000F8, "Wrong size on FAtlantaGenericEventUIData");
static_assert(offsetof(FAtlantaGenericEventUIData, elementsUIData) == 0x0000E8, "Member 'FAtlantaGenericEventUIData::elementsUIData' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaKillerSoundDistanceData
// 0x0010 (0x0018 - 0x0008)
struct FAtlantaKillerSoundDistanceData final : public FDBDTableRowBase
{
public:
	float                                         MinRadiusSoundDistance;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadiusSoundDistance;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRangeSoundHeard;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaKillerSoundDistanceData) == 0x000008, "Wrong alignment on FAtlantaKillerSoundDistanceData");
static_assert(sizeof(FAtlantaKillerSoundDistanceData) == 0x000018, "Wrong size on FAtlantaKillerSoundDistanceData");
static_assert(offsetof(FAtlantaKillerSoundDistanceData, MinRadiusSoundDistance) == 0x000008, "Member 'FAtlantaKillerSoundDistanceData::MinRadiusSoundDistance' has a wrong offset!");
static_assert(offsetof(FAtlantaKillerSoundDistanceData, MaxRadiusSoundDistance) == 0x00000C, "Member 'FAtlantaKillerSoundDistanceData::MaxRadiusSoundDistance' has a wrong offset!");
static_assert(offsetof(FAtlantaKillerSoundDistanceData, MinRangeSoundHeard) == 0x000010, "Member 'FAtlantaKillerSoundDistanceData::MinRangeSoundHeard' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaKillerSoundConditionData
// 0x0018 (0x0020 - 0x0008)
struct FAtlantaKillerSoundConditionData final : public FDBDTableRowBase
{
public:
	class FName                                   RTPCAudioID;                                       // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComparisonValue;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKillerSoundComparisonType                    ValueComparisonType;                               // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaKillerSoundConditionData) == 0x000008, "Wrong alignment on FAtlantaKillerSoundConditionData");
static_assert(sizeof(FAtlantaKillerSoundConditionData) == 0x000020, "Wrong size on FAtlantaKillerSoundConditionData");
static_assert(offsetof(FAtlantaKillerSoundConditionData, RTPCAudioID) == 0x000008, "Member 'FAtlantaKillerSoundConditionData::RTPCAudioID' has a wrong offset!");
static_assert(offsetof(FAtlantaKillerSoundConditionData, ComparisonValue) == 0x000014, "Member 'FAtlantaKillerSoundConditionData::ComparisonValue' has a wrong offset!");
static_assert(offsetof(FAtlantaKillerSoundConditionData, ValueComparisonType) == 0x000018, "Member 'FAtlantaKillerSoundConditionData::ValueComparisonType' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaKillerSoundIndicatorData
// 0x0030 (0x0038 - 0x0008)
struct FAtlantaKillerSoundIndicatorData final : public FDBDTableRowBase
{
public:
	float                                         MinRadiusSoundDistance;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadiusSoundDistance;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRangeSoundHeard;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeGlobalSound;                                  // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanDiminishWithDistance;                           // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlantaKillerSoundConditionData> GlobalSoundConditions;                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtlantaKillerSoundConditionData> DiminishWithDistanceConditions;                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaKillerSoundIndicatorData) == 0x000008, "Wrong alignment on FAtlantaKillerSoundIndicatorData");
static_assert(sizeof(FAtlantaKillerSoundIndicatorData) == 0x000038, "Wrong size on FAtlantaKillerSoundIndicatorData");
static_assert(offsetof(FAtlantaKillerSoundIndicatorData, MinRadiusSoundDistance) == 0x000008, "Member 'FAtlantaKillerSoundIndicatorData::MinRadiusSoundDistance' has a wrong offset!");
static_assert(offsetof(FAtlantaKillerSoundIndicatorData, MaxRadiusSoundDistance) == 0x00000C, "Member 'FAtlantaKillerSoundIndicatorData::MaxRadiusSoundDistance' has a wrong offset!");
static_assert(offsetof(FAtlantaKillerSoundIndicatorData, MinRangeSoundHeard) == 0x000010, "Member 'FAtlantaKillerSoundIndicatorData::MinRangeSoundHeard' has a wrong offset!");
static_assert(offsetof(FAtlantaKillerSoundIndicatorData, CanBeGlobalSound) == 0x000014, "Member 'FAtlantaKillerSoundIndicatorData::CanBeGlobalSound' has a wrong offset!");
static_assert(offsetof(FAtlantaKillerSoundIndicatorData, CanDiminishWithDistance) == 0x000015, "Member 'FAtlantaKillerSoundIndicatorData::CanDiminishWithDistance' has a wrong offset!");
static_assert(offsetof(FAtlantaKillerSoundIndicatorData, GlobalSoundConditions) == 0x000018, "Member 'FAtlantaKillerSoundIndicatorData::GlobalSoundConditions' has a wrong offset!");
static_assert(offsetof(FAtlantaKillerSoundIndicatorData, DiminishWithDistanceConditions) == 0x000028, "Member 'FAtlantaKillerSoundIndicatorData::DiminishWithDistanceConditions' has a wrong offset!");

// ScriptStruct DeadByDaylight.TextureReplacerData
// 0x0070 (0x0070 - 0x0000)
struct FTextureReplacerData final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      BaseMaterial;                                      // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ReplacementTexture;                                // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextureParameterName;                              // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExplicitMaterialSlot;                              // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextureReplacerData) == 0x000008, "Wrong alignment on FTextureReplacerData");
static_assert(sizeof(FTextureReplacerData) == 0x000070, "Wrong size on FTextureReplacerData");
static_assert(offsetof(FTextureReplacerData, BaseMaterial) == 0x000000, "Member 'FTextureReplacerData::BaseMaterial' has a wrong offset!");
static_assert(offsetof(FTextureReplacerData, ReplacementTexture) == 0x000030, "Member 'FTextureReplacerData::ReplacementTexture' has a wrong offset!");
static_assert(offsetof(FTextureReplacerData, TextureParameterName) == 0x000060, "Member 'FTextureReplacerData::TextureParameterName' has a wrong offset!");
static_assert(offsetof(FTextureReplacerData, ExplicitMaterialSlot) == 0x00006C, "Member 'FTextureReplacerData::ExplicitMaterialSlot' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomAnimData
// 0x0060 (0x0060 - 0x0000)
struct FCustomAnimData final
{
public:
	TSoftClassPtr<class UClass>                   MenuAnimationBlueprint;                            // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   InGameAnimationBlueprint;                          // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomAnimData) == 0x000008, "Wrong alignment on FCustomAnimData");
static_assert(sizeof(FCustomAnimData) == 0x000060, "Wrong size on FCustomAnimData");
static_assert(offsetof(FCustomAnimData, MenuAnimationBlueprint) == 0x000000, "Member 'FCustomAnimData::MenuAnimationBlueprint' has a wrong offset!");
static_assert(offsetof(FCustomAnimData, InGameAnimationBlueprint) == 0x000030, "Member 'FCustomAnimData::InGameAnimationBlueprint' has a wrong offset!");

// ScriptStruct DeadByDaylight.UnlockSaveStatCondition
// 0x0014 (0x0014 - 0x0000)
struct FUnlockSaveStatCondition final
{
public:
	class FName                                   StatName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueRequired;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isCharacterSpecific;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnlockSaveStatCondition) == 0x000004, "Wrong alignment on FUnlockSaveStatCondition");
static_assert(sizeof(FUnlockSaveStatCondition) == 0x000014, "Wrong size on FUnlockSaveStatCondition");
static_assert(offsetof(FUnlockSaveStatCondition, StatName) == 0x000000, "Member 'FUnlockSaveStatCondition::StatName' has a wrong offset!");
static_assert(offsetof(FUnlockSaveStatCondition, ValueRequired) == 0x00000C, "Member 'FUnlockSaveStatCondition::ValueRequired' has a wrong offset!");
static_assert(offsetof(FUnlockSaveStatCondition, isCharacterSpecific) == 0x000010, "Member 'FUnlockSaveStatCondition::isCharacterSpecific' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationItemData
// 0x0238 (0x0368 - 0x0130)
struct FCustomizationItemData final : public FCustomizationData
{
public:
	ECustomizationCategory                        Category;                                          // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           ItemMesh;                                          // 0x0138(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AnimClass;                                         // 0x0168(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ItemBlueprint;                                     // 0x0198(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMaterialReplacerData>          MaterialsMap;                                      // 0x01C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FConditionalMaterialReplacer           ConditionalMaterialReplacer;                       // 0x01D8(0x0060)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTextureReplacerData>           TexturesMap;                                       // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SkeletalComponentTags;                             // 0x0248(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CosmeticOverrideSemanticTags;                      // 0x0258(0x0020)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CollectionName;                                    // 0x0278(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CollectionDescription;                             // 0x0290(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         PrestigeUlockLevel;                                // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PrestigeUnlockDate;                                // 0x02B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventId;                                           // 0x02C0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharmCategory                                CharmCategory;                                     // 0x02CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBPAttachementSocketData>       SocketAttachements;                                // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUnlockSaveStatCondition>       UnlockingConditions;                               // 0x02E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsInStore;                                         // 0x02F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInNonViolentBuild;                               // 0x02F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableInAtlantaBuild;                         // 0x02F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F3[0x1];                                      // 0x02F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PlatformExclusiveFlag;                             // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCustomSoundFXData>             CustomSFXs;                                        // 0x02F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCustomAnimData                        AnimationData;                                     // 0x0308(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationItemData) == 0x000008, "Wrong alignment on FCustomizationItemData");
static_assert(sizeof(FCustomizationItemData) == 0x000368, "Wrong size on FCustomizationItemData");
static_assert(offsetof(FCustomizationItemData, Category) == 0x000130, "Member 'FCustomizationItemData::Category' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, ItemMesh) == 0x000138, "Member 'FCustomizationItemData::ItemMesh' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, AnimClass) == 0x000168, "Member 'FCustomizationItemData::AnimClass' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, ItemBlueprint) == 0x000198, "Member 'FCustomizationItemData::ItemBlueprint' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, MaterialsMap) == 0x0001C8, "Member 'FCustomizationItemData::MaterialsMap' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, ConditionalMaterialReplacer) == 0x0001D8, "Member 'FCustomizationItemData::ConditionalMaterialReplacer' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, TexturesMap) == 0x000238, "Member 'FCustomizationItemData::TexturesMap' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, SkeletalComponentTags) == 0x000248, "Member 'FCustomizationItemData::SkeletalComponentTags' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, CosmeticOverrideSemanticTags) == 0x000258, "Member 'FCustomizationItemData::CosmeticOverrideSemanticTags' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, CollectionName) == 0x000278, "Member 'FCustomizationItemData::CollectionName' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, CollectionDescription) == 0x000290, "Member 'FCustomizationItemData::CollectionDescription' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, PrestigeUlockLevel) == 0x0002A8, "Member 'FCustomizationItemData::PrestigeUlockLevel' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, PrestigeUnlockDate) == 0x0002B0, "Member 'FCustomizationItemData::PrestigeUnlockDate' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, EventId) == 0x0002C0, "Member 'FCustomizationItemData::EventId' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, CharmCategory) == 0x0002CC, "Member 'FCustomizationItemData::CharmCategory' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, SocketAttachements) == 0x0002D0, "Member 'FCustomizationItemData::SocketAttachements' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, UnlockingConditions) == 0x0002E0, "Member 'FCustomizationItemData::UnlockingConditions' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, IsInStore) == 0x0002F0, "Member 'FCustomizationItemData::IsInStore' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, IsInNonViolentBuild) == 0x0002F1, "Member 'FCustomizationItemData::IsInNonViolentBuild' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, IsAvailableInAtlantaBuild) == 0x0002F2, "Member 'FCustomizationItemData::IsAvailableInAtlantaBuild' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, PlatformExclusiveFlag) == 0x0002F4, "Member 'FCustomizationItemData::PlatformExclusiveFlag' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, CustomSFXs) == 0x0002F8, "Member 'FCustomizationItemData::CustomSFXs' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, AnimationData) == 0x000308, "Member 'FCustomizationItemData::AnimationData' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaMonthlyPassEventUIData
// 0x0040 (0x0128 - 0x00E8)
struct FAtlantaMonthlyPassEventUIData final : public FAtlantaBaseEventsUIData
{
public:
	uint8                                         Pad_E8[0x40];                                      // 0x00E8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaMonthlyPassEventUIData) == 0x000008, "Wrong alignment on FAtlantaMonthlyPassEventUIData");
static_assert(sizeof(FAtlantaMonthlyPassEventUIData) == 0x000128, "Wrong size on FAtlantaMonthlyPassEventUIData");

// ScriptStruct DeadByDaylight.DBDSearchParams
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FDBDSearchParams final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDBDSearchParams) == 0x000008, "Wrong alignment on FDBDSearchParams");
static_assert(sizeof(FDBDSearchParams) == 0x000080, "Wrong size on FDBDSearchParams");

// ScriptStruct DeadByDaylight.SaveDataBase
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSaveDataBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VersionNumber;                                     // 0x0008(0x0004)(ZeroConstructor, SaveGame, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveDataBase) == 0x000008, "Wrong alignment on FSaveDataBase");
static_assert(sizeof(FSaveDataBase) == 0x000010, "Wrong size on FSaveDataBase");
static_assert(offsetof(FSaveDataBase, VersionNumber) == 0x000008, "Member 'FSaveDataBase::VersionNumber' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaNoiseIndicatorDistanceData
// 0x0018 (0x0020 - 0x0008)
struct FAtlantaNoiseIndicatorDistanceData final : public FDBDTableRowBase
{
public:
	class FString                                 Description;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceForNoiseIndicatorToAppear;                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaNoiseIndicatorDistanceData) == 0x000008, "Wrong alignment on FAtlantaNoiseIndicatorDistanceData");
static_assert(sizeof(FAtlantaNoiseIndicatorDistanceData) == 0x000020, "Wrong size on FAtlantaNoiseIndicatorDistanceData");
static_assert(offsetof(FAtlantaNoiseIndicatorDistanceData, Description) == 0x000008, "Member 'FAtlantaNoiseIndicatorDistanceData::Description' has a wrong offset!");
static_assert(offsetof(FAtlantaNoiseIndicatorDistanceData, DistanceForNoiseIndicatorToAppear) == 0x000018, "Member 'FAtlantaNoiseIndicatorDistanceData::DistanceForNoiseIndicatorToAppear' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaOnBoardingData
// 0x0040 (0x0048 - 0x0008)
struct FAtlantaOnBoardingData final : public FDBDTableRowBase
{
public:
	class FName                                   OnBoardingId;                                      // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaOnBoardingData) == 0x000008, "Wrong alignment on FAtlantaOnBoardingData");
static_assert(sizeof(FAtlantaOnBoardingData) == 0x000048, "Wrong size on FAtlantaOnBoardingData");
static_assert(offsetof(FAtlantaOnBoardingData, OnBoardingId) == 0x000008, "Member 'FAtlantaOnBoardingData::OnBoardingId' has a wrong offset!");
static_assert(offsetof(FAtlantaOnBoardingData, Title) == 0x000018, "Member 'FAtlantaOnBoardingData::Title' has a wrong offset!");
static_assert(offsetof(FAtlantaOnBoardingData, Description) == 0x000030, "Member 'FAtlantaOnBoardingData::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIItemWeightTunableRowData
// 0x0010 (0x0018 - 0x0008)
struct FAIItemWeightTunableRowData final : public FDBDTableRowBase
{
public:
	float                                         CountWeight;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyWeight;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConditionalWeight;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIItemWeightTunableRowData) == 0x000008, "Wrong alignment on FAIItemWeightTunableRowData");
static_assert(sizeof(FAIItemWeightTunableRowData) == 0x000018, "Wrong size on FAIItemWeightTunableRowData");
static_assert(offsetof(FAIItemWeightTunableRowData, CountWeight) == 0x000008, "Member 'FAIItemWeightTunableRowData::CountWeight' has a wrong offset!");
static_assert(offsetof(FAIItemWeightTunableRowData, EnergyWeight) == 0x00000C, "Member 'FAIItemWeightTunableRowData::EnergyWeight' has a wrong offset!");
static_assert(offsetof(FAIItemWeightTunableRowData, ConditionalWeight) == 0x000010, "Member 'FAIItemWeightTunableRowData::ConditionalWeight' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedFearMarketItemInstance
// 0x0018 (0x0018 - 0x0000)
struct FLegacySavedFearMarketItemInstance final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodpointConversion;                              // 0x0010(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Purchased;                                         // 0x0014(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacySavedFearMarketItemInstance) == 0x000004, "Wrong alignment on FLegacySavedFearMarketItemInstance");
static_assert(sizeof(FLegacySavedFearMarketItemInstance) == 0x000018, "Wrong size on FLegacySavedFearMarketItemInstance");
static_assert(offsetof(FLegacySavedFearMarketItemInstance, ItemId) == 0x000000, "Member 'FLegacySavedFearMarketItemInstance::ItemId' has a wrong offset!");
static_assert(offsetof(FLegacySavedFearMarketItemInstance, Cost) == 0x00000C, "Member 'FLegacySavedFearMarketItemInstance::Cost' has a wrong offset!");
static_assert(offsetof(FLegacySavedFearMarketItemInstance, BloodpointConversion) == 0x000010, "Member 'FLegacySavedFearMarketItemInstance::BloodpointConversion' has a wrong offset!");
static_assert(offsetof(FLegacySavedFearMarketItemInstance, Purchased) == 0x000014, "Member 'FLegacySavedFearMarketItemInstance::Purchased' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedFearMarketOfferingInstance
// 0x0020 (0x0020 - 0x0000)
struct FLegacySavedFearMarketOfferingInstance final
{
public:
	TArray<struct FLegacySavedFearMarketItemInstance> ObjectsForSale;                                // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FDateTime                              StartTime;                                         // 0x0010(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0018(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedFearMarketOfferingInstance) == 0x000008, "Wrong alignment on FLegacySavedFearMarketOfferingInstance");
static_assert(sizeof(FLegacySavedFearMarketOfferingInstance) == 0x000020, "Wrong size on FLegacySavedFearMarketOfferingInstance");
static_assert(offsetof(FLegacySavedFearMarketOfferingInstance, ObjectsForSale) == 0x000000, "Member 'FLegacySavedFearMarketOfferingInstance::ObjectsForSale' has a wrong offset!");
static_assert(offsetof(FLegacySavedFearMarketOfferingInstance, StartTime) == 0x000010, "Member 'FLegacySavedFearMarketOfferingInstance::StartTime' has a wrong offset!");
static_assert(offsetof(FLegacySavedFearMarketOfferingInstance, EndTime) == 0x000018, "Member 'FLegacySavedFearMarketOfferingInstance::EndTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDConnectionStatus
// 0x0010 (0x0010 - 0x0000)
struct FDBDConnectionStatus final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDBDConnectionStatus) == 0x000008, "Wrong alignment on FDBDConnectionStatus");
static_assert(sizeof(FDBDConnectionStatus) == 0x000010, "Wrong size on FDBDConnectionStatus");
static_assert(offsetof(FDBDConnectionStatus, _gameInstance) == 0x000008, "Member 'FDBDConnectionStatus::_gameInstance' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDFoliageInstance
// 0x004C (0x004C - 0x0000)
struct FDBDFoliageInstance final
{
public:
	int32                                         BaseId;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ProceduralGuid;                                    // 0x0004(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0014(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PreAlignRotation;                                  // 0x002C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DrawScale3D;                                       // 0x0038(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x0044(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Flags;                                             // 0x0048(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDFoliageInstance) == 0x000004, "Wrong alignment on FDBDFoliageInstance");
static_assert(sizeof(FDBDFoliageInstance) == 0x00004C, "Wrong size on FDBDFoliageInstance");
static_assert(offsetof(FDBDFoliageInstance, BaseId) == 0x000000, "Member 'FDBDFoliageInstance::BaseId' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, ProceduralGuid) == 0x000004, "Member 'FDBDFoliageInstance::ProceduralGuid' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, Location) == 0x000014, "Member 'FDBDFoliageInstance::Location' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, Rotation) == 0x000020, "Member 'FDBDFoliageInstance::Rotation' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, PreAlignRotation) == 0x00002C, "Member 'FDBDFoliageInstance::PreAlignRotation' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, DrawScale3D) == 0x000038, "Member 'FDBDFoliageInstance::DrawScale3D' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, ZOffset) == 0x000044, "Member 'FDBDFoliageInstance::ZOffset' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, Flags) == 0x000048, "Member 'FDBDFoliageInstance::Flags' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaTutorialEndReward
// 0x0020 (0x0028 - 0x0008)
struct FAtlantaTutorialEndReward final : public FDBDTableRowBase
{
public:
	int32                                         BloodpointReward;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AuricCellsRewards;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FearTokensReward;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CharactersRewards;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaTutorialEndReward) == 0x000008, "Wrong alignment on FAtlantaTutorialEndReward");
static_assert(sizeof(FAtlantaTutorialEndReward) == 0x000028, "Wrong size on FAtlantaTutorialEndReward");
static_assert(offsetof(FAtlantaTutorialEndReward, BloodpointReward) == 0x000008, "Member 'FAtlantaTutorialEndReward::BloodpointReward' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialEndReward, AuricCellsRewards) == 0x00000C, "Member 'FAtlantaTutorialEndReward::AuricCellsRewards' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialEndReward, FearTokensReward) == 0x000010, "Member 'FAtlantaTutorialEndReward::FearTokensReward' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialEndReward, CharactersRewards) == 0x000018, "Member 'FAtlantaTutorialEndReward::CharactersRewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.PartyMemberUIData
// 0x0030 (0x0030 - 0x0000)
struct FPartyMemberUIData final
{
public:
	bool                                          _isLocalPlayer;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isReady;                                          // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _mirrorId;                                         // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _playerName;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _playerId;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartyMemberUIData) == 0x000008, "Wrong alignment on FPartyMemberUIData");
static_assert(sizeof(FPartyMemberUIData) == 0x000030, "Wrong size on FPartyMemberUIData");
static_assert(offsetof(FPartyMemberUIData, _isLocalPlayer) == 0x000000, "Member 'FPartyMemberUIData::_isLocalPlayer' has a wrong offset!");
static_assert(offsetof(FPartyMemberUIData, _isReady) == 0x000001, "Member 'FPartyMemberUIData::_isReady' has a wrong offset!");
static_assert(offsetof(FPartyMemberUIData, _mirrorId) == 0x000008, "Member 'FPartyMemberUIData::_mirrorId' has a wrong offset!");
static_assert(offsetof(FPartyMemberUIData, _playerName) == 0x000018, "Member 'FPartyMemberUIData::_playerName' has a wrong offset!");
static_assert(offsetof(FPartyMemberUIData, _playerId) == 0x000028, "Member 'FPartyMemberUIData::_playerId' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBD_SoundSpawnerData
// 0x0028 (0x0028 - 0x0000)
struct FDBD_SoundSpawnerData final
{
public:
	TArray<TSoftClassPtr<class UClass>>           TriggerObject;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          TriggerVisualForCamper;                            // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerVisualForSlasher;                           // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ActorToSpawnVisual;                                // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBD_SoundSpawnerData) == 0x000008, "Wrong alignment on FDBD_SoundSpawnerData");
static_assert(sizeof(FDBD_SoundSpawnerData) == 0x000028, "Wrong size on FDBD_SoundSpawnerData");
static_assert(offsetof(FDBD_SoundSpawnerData, TriggerObject) == 0x000000, "Member 'FDBD_SoundSpawnerData::TriggerObject' has a wrong offset!");
static_assert(offsetof(FDBD_SoundSpawnerData, TriggerVisualForCamper) == 0x000010, "Member 'FDBD_SoundSpawnerData::TriggerVisualForCamper' has a wrong offset!");
static_assert(offsetof(FDBD_SoundSpawnerData, TriggerVisualForSlasher) == 0x000011, "Member 'FDBD_SoundSpawnerData::TriggerVisualForSlasher' has a wrong offset!");
static_assert(offsetof(FDBD_SoundSpawnerData, ActorToSpawnVisual) == 0x000018, "Member 'FDBD_SoundSpawnerData::ActorToSpawnVisual' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaTutorialLevelData
// 0x0068 (0x0070 - 0x0008)
struct FAtlantaTutorialLevelData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKillerTutorial;                                  // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaTutorialLevelData) == 0x000008, "Wrong alignment on FAtlantaTutorialLevelData");
static_assert(sizeof(FAtlantaTutorialLevelData) == 0x000070, "Wrong size on FAtlantaTutorialLevelData");
static_assert(offsetof(FAtlantaTutorialLevelData, ID) == 0x000008, "Member 'FAtlantaTutorialLevelData::ID' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialLevelData, Title) == 0x000018, "Member 'FAtlantaTutorialLevelData::Title' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialLevelData, Description) == 0x000030, "Member 'FAtlantaTutorialLevelData::Description' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialLevelData, IconPath) == 0x000048, "Member 'FAtlantaTutorialLevelData::IconPath' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialLevelData, MapName) == 0x000058, "Member 'FAtlantaTutorialLevelData::MapName' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialLevelData, IsKillerTutorial) == 0x000068, "Member 'FAtlantaTutorialLevelData::IsKillerTutorial' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualSetIndex
// 0x0018 (0x0018 - 0x0000)
struct FAtlantaRitualSetIndex final
{
public:
	int32                                         index;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ritualType;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRitualSetIndex) == 0x000008, "Wrong alignment on FAtlantaRitualSetIndex");
static_assert(sizeof(FAtlantaRitualSetIndex) == 0x000018, "Wrong size on FAtlantaRitualSetIndex");
static_assert(offsetof(FAtlantaRitualSetIndex, index) == 0x000000, "Member 'FAtlantaRitualSetIndex::index' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualSetIndex, ritualType) == 0x000008, "Member 'FAtlantaRitualSetIndex::ritualType' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaTutorialNotificationData
// 0x0010 (0x00C0 - 0x00B0)
struct FAtlantaTutorialNotificationData final : public FTutorialNotificationData
{
public:
	TArray<TSoftObjectPtr<class UPaperSprite>>    Textures;                                          // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaTutorialNotificationData) == 0x000008, "Wrong alignment on FAtlantaTutorialNotificationData");
static_assert(sizeof(FAtlantaTutorialNotificationData) == 0x0000C0, "Wrong size on FAtlantaTutorialNotificationData");
static_assert(offsetof(FAtlantaTutorialNotificationData, Textures) == 0x0000B0, "Member 'FAtlantaTutorialNotificationData::Textures' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaTutorialTallyData
// 0x0020 (0x0020 - 0x0000)
struct FAtlantaTutorialTallyData final
{
public:
	bool                                          IsKiller;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstTimeCompleted;                                // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BloodpointsScore;                                  // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AuricCells;                                        // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FearTokens;                                        // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Characters;                                        // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaTutorialTallyData) == 0x000008, "Wrong alignment on FAtlantaTutorialTallyData");
static_assert(sizeof(FAtlantaTutorialTallyData) == 0x000020, "Wrong size on FAtlantaTutorialTallyData");
static_assert(offsetof(FAtlantaTutorialTallyData, IsKiller) == 0x000000, "Member 'FAtlantaTutorialTallyData::IsKiller' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialTallyData, FirstTimeCompleted) == 0x000001, "Member 'FAtlantaTutorialTallyData::FirstTimeCompleted' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialTallyData, BloodpointsScore) == 0x000004, "Member 'FAtlantaTutorialTallyData::BloodpointsScore' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialTallyData, AuricCells) == 0x000008, "Member 'FAtlantaTutorialTallyData::AuricCells' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialTallyData, FearTokens) == 0x00000C, "Member 'FAtlantaTutorialTallyData::FearTokens' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialTallyData, Characters) == 0x000010, "Member 'FAtlantaTutorialTallyData::Characters' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualDifficulty
// 0x000C (0x000C - 0x0000)
struct FAtlantaRitualDifficulty final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayThreshold;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRitualDifficulty) == 0x000004, "Wrong alignment on FAtlantaRitualDifficulty");
static_assert(sizeof(FAtlantaRitualDifficulty) == 0x00000C, "Wrong size on FAtlantaRitualDifficulty");
static_assert(offsetof(FAtlantaRitualDifficulty, Threshold) == 0x000000, "Member 'FAtlantaRitualDifficulty::Threshold' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualDifficulty, Tolerance) == 0x000004, "Member 'FAtlantaRitualDifficulty::Tolerance' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualDifficulty, DisplayThreshold) == 0x000008, "Member 'FAtlantaRitualDifficulty::DisplayThreshold' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualInstance
// 0x0060 (0x0060 - 0x0000)
struct FAtlantaRitualInstance final
{
public:
	class FName                                   RitualKey;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterId;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EDBDScoreTypes>                        TrackedEvents;                                     // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         TrackedGameEvents;                                 // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAtlantaRitualEvaluatorBase*            Evaluator;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAtlantaRitualDifficulty               Difficulty;                                        // 0x0040(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Active;                                            // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ExpiryDate;                                        // 0x0058(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRitualInstance) == 0x000008, "Wrong alignment on FAtlantaRitualInstance");
static_assert(sizeof(FAtlantaRitualInstance) == 0x000060, "Wrong size on FAtlantaRitualInstance");
static_assert(offsetof(FAtlantaRitualInstance, RitualKey) == 0x000000, "Member 'FAtlantaRitualInstance::RitualKey' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualInstance, CharacterId) == 0x00000C, "Member 'FAtlantaRitualInstance::CharacterId' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualInstance, Role) == 0x000010, "Member 'FAtlantaRitualInstance::Role' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualInstance, TrackedEvents) == 0x000018, "Member 'FAtlantaRitualInstance::TrackedEvents' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualInstance, TrackedGameEvents) == 0x000028, "Member 'FAtlantaRitualInstance::TrackedGameEvents' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualInstance, Evaluator) == 0x000038, "Member 'FAtlantaRitualInstance::Evaluator' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualInstance, Difficulty) == 0x000040, "Member 'FAtlantaRitualInstance::Difficulty' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualInstance, Progress) == 0x00004C, "Member 'FAtlantaRitualInstance::Progress' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualInstance, Active) == 0x000050, "Member 'FAtlantaRitualInstance::Active' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualInstance, ExpiryDate) == 0x000058, "Member 'FAtlantaRitualInstance::ExpiryDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualSet
// 0x0038 (0x0038 - 0x0000)
struct FAtlantaRitualSet final
{
public:
	TArray<struct FAtlantaRitualInstance>         Instances;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRewardItem>                    RewardItems;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x18];                                      // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaRitualSet) == 0x000008, "Wrong alignment on FAtlantaRitualSet");
static_assert(sizeof(FAtlantaRitualSet) == 0x000038, "Wrong size on FAtlantaRitualSet");
static_assert(offsetof(FAtlantaRitualSet, Instances) == 0x000000, "Member 'FAtlantaRitualSet::Instances' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualSet, RewardItems) == 0x000010, "Member 'FAtlantaRitualSet::RewardItems' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualSetArray
// 0x0010 (0x0010 - 0x0000)
struct FAtlantaRitualSetArray final
{
public:
	TArray<struct FAtlantaRitualSet>              rituals;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRitualSetArray) == 0x000008, "Wrong alignment on FAtlantaRitualSetArray");
static_assert(sizeof(FAtlantaRitualSetArray) == 0x000010, "Wrong size on FAtlantaRitualSetArray");
static_assert(offsetof(FAtlantaRitualSetArray, rituals) == 0x000000, "Member 'FAtlantaRitualSetArray::rituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualContainer
// 0x0050 (0x0050 - 0x0000)
struct FAtlantaRitualContainer final
{
public:
	TMap<class FString, struct FAtlantaRitualSetArray> RitualsMap;                                   // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRitualContainer) == 0x000008, "Wrong alignment on FAtlantaRitualContainer");
static_assert(sizeof(FAtlantaRitualContainer) == 0x000050, "Wrong size on FAtlantaRitualContainer");
static_assert(offsetof(FAtlantaRitualContainer, RitualsMap) == 0x000000, "Member 'FAtlantaRitualContainer::RitualsMap' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlCookedMapDescription
// 0x0040 (0x0040 - 0x0000)
struct FAtlCookedMapDescription final
{
public:
	class FName                                   ThemeName;                                         // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UWorld>                  MapAsset;                                          // 0x0010(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlCookedMapDescription) == 0x000008, "Wrong alignment on FAtlCookedMapDescription");
static_assert(sizeof(FAtlCookedMapDescription) == 0x000040, "Wrong size on FAtlCookedMapDescription");
static_assert(offsetof(FAtlCookedMapDescription, ThemeName) == 0x000000, "Member 'FAtlCookedMapDescription::ThemeName' has a wrong offset!");
static_assert(offsetof(FAtlCookedMapDescription, MapAsset) == 0x000010, "Member 'FAtlCookedMapDescription::MapAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.AttackEventTypeDetails
// 0x0028 (0x0030 - 0x0008)
struct FAttackEventTypeDetails final : public FDBDTableRowBase
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0008(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackEventType                              AttackEventType;                                   // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeProtective;                                   // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AssociatedCharacter;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackEventTypeDetails) == 0x000008, "Wrong alignment on FAttackEventTypeDetails");
static_assert(sizeof(FAttackEventTypeDetails) == 0x000030, "Wrong size on FAttackEventTypeDetails");
static_assert(offsetof(FAttackEventTypeDetails, GameplayTag) == 0x000008, "Member 'FAttackEventTypeDetails::GameplayTag' has a wrong offset!");
static_assert(offsetof(FAttackEventTypeDetails, AttackEventType) == 0x000014, "Member 'FAttackEventTypeDetails::AttackEventType' has a wrong offset!");
static_assert(offsetof(FAttackEventTypeDetails, CanBeProtective) == 0x000015, "Member 'FAttackEventTypeDetails::CanBeProtective' has a wrong offset!");
static_assert(offsetof(FAttackEventTypeDetails, AssociatedCharacter) == 0x000018, "Member 'FAttackEventTypeDetails::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(FAttackEventTypeDetails, Description) == 0x000020, "Member 'FAttackEventTypeDetails::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.AttackHitResult
// 0x0088 (0x0088 - 0x0000)
struct FAttackHitResult final
{
public:
	class ADBDPlayer*                             Attacker;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             Target;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDBDAttack*                             Attack;                                            // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBasicAttack;                                     // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CosmeticOnly;                                      // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6E];                                      // 0x001A(0x006E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackHitResult) == 0x000008, "Wrong alignment on FAttackHitResult");
static_assert(sizeof(FAttackHitResult) == 0x000088, "Wrong size on FAttackHitResult");
static_assert(offsetof(FAttackHitResult, Attacker) == 0x000000, "Member 'FAttackHitResult::Attacker' has a wrong offset!");
static_assert(offsetof(FAttackHitResult, Target) == 0x000008, "Member 'FAttackHitResult::Target' has a wrong offset!");
static_assert(offsetof(FAttackHitResult, Attack) == 0x000010, "Member 'FAttackHitResult::Attack' has a wrong offset!");
static_assert(offsetof(FAttackHitResult, IsBasicAttack) == 0x000018, "Member 'FAttackHitResult::IsBasicAttack' has a wrong offset!");
static_assert(offsetof(FAttackHitResult, CosmeticOnly) == 0x000019, "Member 'FAttackHitResult::CosmeticOnly' has a wrong offset!");

// ScriptStruct DeadByDaylight.PalletPushSettings
// 0x0002 (0x0002 - 0x0000)
struct FPalletPushSettings final
{
public:
	bool                                          IgnorePlayerExecutingPulldown;                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalletPushSideStrategy                       PalletPushSideStrategy;                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPalletPushSettings) == 0x000001, "Wrong alignment on FPalletPushSettings");
static_assert(sizeof(FPalletPushSettings) == 0x000002, "Wrong size on FPalletPushSettings");
static_assert(offsetof(FPalletPushSettings, IgnorePlayerExecutingPulldown) == 0x000000, "Member 'FPalletPushSettings::IgnorePlayerExecutingPulldown' has a wrong offset!");
static_assert(offsetof(FPalletPushSettings, PalletPushSideStrategy) == 0x000001, "Member 'FPalletPushSettings::PalletPushSideStrategy' has a wrong offset!");

// ScriptStruct DeadByDaylight.MapSoundsToAvoid
// 0x0010 (0x0010 - 0x0000)
struct FMapSoundsToAvoid final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapSoundsToAvoid) == 0x000008, "Wrong alignment on FMapSoundsToAvoid");
static_assert(sizeof(FMapSoundsToAvoid) == 0x000010, "Wrong size on FMapSoundsToAvoid");
static_assert(offsetof(FMapSoundsToAvoid, Component) == 0x000000, "Member 'FMapSoundsToAvoid::Component' has a wrong offset!");

// ScriptStruct DeadByDaylight.AvailableInteractionCalculator
// 0x01C0 (0x01C0 - 0x0000)
struct FAvailableInteractionCalculator final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UInteractionDefinition*>           _interactions;                                     // 0x0048(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x118];                                     // 0x0098(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _fullEvaluationFrequency;                          // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxFramesForFullEvaluation;                       // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _secondsBetweenNullReferenceCleanup;               // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvailableInteractionCalculator) == 0x000008, "Wrong alignment on FAvailableInteractionCalculator");
static_assert(sizeof(FAvailableInteractionCalculator) == 0x0001C0, "Wrong size on FAvailableInteractionCalculator");
static_assert(offsetof(FAvailableInteractionCalculator, _interactions) == 0x000048, "Member 'FAvailableInteractionCalculator::_interactions' has a wrong offset!");
static_assert(offsetof(FAvailableInteractionCalculator, _fullEvaluationFrequency) == 0x0001B0, "Member 'FAvailableInteractionCalculator::_fullEvaluationFrequency' has a wrong offset!");
static_assert(offsetof(FAvailableInteractionCalculator, _maxFramesForFullEvaluation) == 0x0001B4, "Member 'FAvailableInteractionCalculator::_maxFramesForFullEvaluation' has a wrong offset!");
static_assert(offsetof(FAvailableInteractionCalculator, _secondsBetweenNullReferenceCleanup) == 0x0001B8, "Member 'FAvailableInteractionCalculator::_secondsBetweenNullReferenceCleanup' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerLevelTooltipData
// 0x0010 (0x00A8 - 0x0098)
struct FPlayerLevelTooltipData final : public FBaseTooltipData
{
public:
	int32                                         PlayerLevel;                                       // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerPrestige;                                    // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentExperience;                                 // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextLevelExperience;                               // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerLevelTooltipData) == 0x000008, "Wrong alignment on FPlayerLevelTooltipData");
static_assert(sizeof(FPlayerLevelTooltipData) == 0x0000A8, "Wrong size on FPlayerLevelTooltipData");
static_assert(offsetof(FPlayerLevelTooltipData, PlayerLevel) == 0x000098, "Member 'FPlayerLevelTooltipData::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FPlayerLevelTooltipData, PlayerPrestige) == 0x00009C, "Member 'FPlayerLevelTooltipData::PlayerPrestige' has a wrong offset!");
static_assert(offsetof(FPlayerLevelTooltipData, CurrentExperience) == 0x0000A0, "Member 'FPlayerLevelTooltipData::CurrentExperience' has a wrong offset!");
static_assert(offsetof(FPlayerLevelTooltipData, NextLevelExperience) == 0x0000A4, "Member 'FPlayerLevelTooltipData::NextLevelExperience' has a wrong offset!");

// ScriptStruct DeadByDaylight.BackendCinematicsContentData
// 0x0048 (0x0048 - 0x0000)
struct FBackendCinematicsContentData final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AllowSkip;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartDate;                                         // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EndDate;                                           // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBackendCinematicsContentData) == 0x000008, "Wrong alignment on FBackendCinematicsContentData");
static_assert(sizeof(FBackendCinematicsContentData) == 0x000048, "Wrong size on FBackendCinematicsContentData");
static_assert(offsetof(FBackendCinematicsContentData, Id) == 0x000000, "Member 'FBackendCinematicsContentData::Id' has a wrong offset!");
static_assert(offsetof(FBackendCinematicsContentData, AllowSkip) == 0x000010, "Member 'FBackendCinematicsContentData::AllowSkip' has a wrong offset!");
static_assert(offsetof(FBackendCinematicsContentData, StartDate) == 0x000018, "Member 'FBackendCinematicsContentData::StartDate' has a wrong offset!");
static_assert(offsetof(FBackendCinematicsContentData, EndDate) == 0x000030, "Member 'FBackendCinematicsContentData::EndDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.BackendCinematicsContent
// 0x0010 (0x0010 - 0x0000)
struct FBackendCinematicsContent final
{
public:
	TArray<struct FBackendCinematicsContentData>  Cinematics;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FBackendCinematicsContent) == 0x000008, "Wrong alignment on FBackendCinematicsContent");
static_assert(sizeof(FBackendCinematicsContent) == 0x000010, "Wrong size on FBackendCinematicsContent");
static_assert(offsetof(FBackendCinematicsContent, Cinematics) == 0x000000, "Member 'FBackendCinematicsContent::Cinematics' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDQueueTimeInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FDBDQueueTimeInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDBDQueueTimeInfo) == 0x000004, "Wrong alignment on FDBDQueueTimeInfo");
static_assert(sizeof(FDBDQueueTimeInfo) == 0x000018, "Wrong size on FDBDQueueTimeInfo");

// ScriptStruct DeadByDaylight.SavedStatsData
// 0x0014 (0x0014 - 0x0000)
struct FSavedStatsData final
{
public:
	uint32                                        Version;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedStatsData) == 0x000004, "Wrong alignment on FSavedStatsData");
static_assert(sizeof(FSavedStatsData) == 0x000014, "Wrong size on FSavedStatsData");
static_assert(offsetof(FSavedStatsData, Version) == 0x000000, "Member 'FSavedStatsData::Version' has a wrong offset!");
static_assert(offsetof(FSavedStatsData, Name) == 0x000004, "Member 'FSavedStatsData::Name' has a wrong offset!");
static_assert(offsetof(FSavedStatsData, Value) == 0x000010, "Member 'FSavedStatsData::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNodeProperties
// 0x0020 (0x0020 - 0x0000)
struct FBloodwebNodeProperties final
{
public:
	EBloodwebNodeContentType                      ContentType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Tags;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CharacterId;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBloodwebNodeProperties) == 0x000008, "Wrong alignment on FBloodwebNodeProperties");
static_assert(sizeof(FBloodwebNodeProperties) == 0x000020, "Wrong size on FBloodwebNodeProperties");
static_assert(offsetof(FBloodwebNodeProperties, ContentType) == 0x000000, "Member 'FBloodwebNodeProperties::ContentType' has a wrong offset!");
static_assert(offsetof(FBloodwebNodeProperties, Rarity) == 0x000001, "Member 'FBloodwebNodeProperties::Rarity' has a wrong offset!");
static_assert(offsetof(FBloodwebNodeProperties, Tags) == 0x000008, "Member 'FBloodwebNodeProperties::Tags' has a wrong offset!");
static_assert(offsetof(FBloodwebNodeProperties, CharacterId) == 0x000018, "Member 'FBloodwebNodeProperties::CharacterId' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNodeGate
// 0x0000 (0x0008 - 0x0008)
struct FBloodwebNodeGate final : public FDBDTableRowBase
{
};
static_assert(alignof(FBloodwebNodeGate) == 0x000008, "Wrong alignment on FBloodwebNodeGate");
static_assert(sizeof(FBloodwebNodeGate) == 0x000008, "Wrong size on FBloodwebNodeGate");

// ScriptStruct DeadByDaylight.BloodwebChest
// 0x0030 (0x0038 - 0x0008)
struct FBloodwebChest final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventID;                                           // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBloodchestType                               ChestType;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 GivenItemRarity;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebChest) == 0x000008, "Wrong alignment on FBloodwebChest");
static_assert(sizeof(FBloodwebChest) == 0x000038, "Wrong size on FBloodwebChest");
static_assert(offsetof(FBloodwebChest, ID) == 0x000008, "Member 'FBloodwebChest::ID' has a wrong offset!");
static_assert(offsetof(FBloodwebChest, EventID) == 0x000014, "Member 'FBloodwebChest::EventID' has a wrong offset!");
static_assert(offsetof(FBloodwebChest, ChestType) == 0x000020, "Member 'FBloodwebChest::ChestType' has a wrong offset!");
static_assert(offsetof(FBloodwebChest, Rarity) == 0x000021, "Member 'FBloodwebChest::Rarity' has a wrong offset!");
static_assert(offsetof(FBloodwebChest, GivenItemRarity) == 0x000028, "Member 'FBloodwebChest::GivenItemRarity' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNode
// 0x0090 (0x0090 - 0x0000)
struct FBloodwebNode final
{
public:
	struct FBloodwebNodeProperties                Properties;                                        // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FBloodwebNodeGate>              Gates;                                             // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EBloodwebNodeState                            State;                                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NodeID;                                            // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContentId;                                         // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBloodwebChest                         BloodwebChest;                                     // 0x0058(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebNode) == 0x000008, "Wrong alignment on FBloodwebNode");
static_assert(sizeof(FBloodwebNode) == 0x000090, "Wrong size on FBloodwebNode");
static_assert(offsetof(FBloodwebNode, Properties) == 0x000000, "Member 'FBloodwebNode::Properties' has a wrong offset!");
static_assert(offsetof(FBloodwebNode, Gates) == 0x000020, "Member 'FBloodwebNode::Gates' has a wrong offset!");
static_assert(offsetof(FBloodwebNode, State) == 0x000030, "Member 'FBloodwebNode::State' has a wrong offset!");
static_assert(offsetof(FBloodwebNode, NodeID) == 0x000038, "Member 'FBloodwebNode::NodeID' has a wrong offset!");
static_assert(offsetof(FBloodwebNode, ContentId) == 0x000048, "Member 'FBloodwebNode::ContentId' has a wrong offset!");
static_assert(offsetof(FBloodwebNode, BloodwebChest) == 0x000058, "Member 'FBloodwebNode::BloodwebChest' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodWebRingPersistentData
// 0x0010 (0x0010 - 0x0000)
struct FBloodWebRingPersistentData final
{
public:
	TArray<struct FBloodwebNode>                  NodeData;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodWebRingPersistentData) == 0x000008, "Wrong alignment on FBloodWebRingPersistentData");
static_assert(sizeof(FBloodWebRingPersistentData) == 0x000010, "Wrong size on FBloodWebRingPersistentData");
static_assert(offsetof(FBloodWebRingPersistentData, NodeData) == 0x000000, "Member 'FBloodWebRingPersistentData::NodeData' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodWebPersistentData
// 0x0050 (0x0050 - 0x0000)
struct FBloodWebPersistentData final
{
public:
	int32                                         VersionNumber;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBloodWebRingPersistentData>    RingData;                                          // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Paths;                                             // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 EntityCurrentNode;                                 // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              GenerationDate;                                    // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Seed;                                              // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodWebPersistentData) == 0x000008, "Wrong alignment on FBloodWebPersistentData");
static_assert(sizeof(FBloodWebPersistentData) == 0x000050, "Wrong size on FBloodWebPersistentData");
static_assert(offsetof(FBloodWebPersistentData, VersionNumber) == 0x000000, "Member 'FBloodWebPersistentData::VersionNumber' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, Level) == 0x000004, "Member 'FBloodWebPersistentData::Level' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, RingData) == 0x000008, "Member 'FBloodWebPersistentData::RingData' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, Paths) == 0x000018, "Member 'FBloodWebPersistentData::Paths' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, EntityCurrentNode) == 0x000028, "Member 'FBloodWebPersistentData::EntityCurrentNode' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, GenerationDate) == 0x000038, "Member 'FBloodWebPersistentData::GenerationDate' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, Seed) == 0x000040, "Member 'FBloodWebPersistentData::Seed' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSavedInventoryData
// 0x0010 (0x0010 - 0x0000)
struct FCharacterSavedInventoryData final
{
public:
	uint32                                        Version;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSavedInventoryData) == 0x000004, "Wrong alignment on FCharacterSavedInventoryData");
static_assert(sizeof(FCharacterSavedInventoryData) == 0x000010, "Wrong size on FCharacterSavedInventoryData");
static_assert(offsetof(FCharacterSavedInventoryData, Version) == 0x000000, "Member 'FCharacterSavedInventoryData::Version' has a wrong offset!");
static_assert(offsetof(FCharacterSavedInventoryData, Name) == 0x000004, "Member 'FCharacterSavedInventoryData::Name' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerLoadoutData
// 0x0098 (0x0098 - 0x0000)
struct FPlayerLoadoutData final
{
public:
	class FName                                   Item;                                              // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ItemAddOns;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CamperPerks;                                       // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CamperPerkLevels;                                  // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   CamperFavor;                                       // 0x0040(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Power;                                             // 0x004C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PowerAddOns;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SlasherPerks;                                      // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SlasherPerkLevels;                                 // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SlasherFavor;                                      // 0x0088(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerLoadoutData) == 0x000008, "Wrong alignment on FPlayerLoadoutData");
static_assert(sizeof(FPlayerLoadoutData) == 0x000098, "Wrong size on FPlayerLoadoutData");
static_assert(offsetof(FPlayerLoadoutData, Item) == 0x000000, "Member 'FPlayerLoadoutData::Item' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, ItemAddOns) == 0x000010, "Member 'FPlayerLoadoutData::ItemAddOns' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, CamperPerks) == 0x000020, "Member 'FPlayerLoadoutData::CamperPerks' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, CamperPerkLevels) == 0x000030, "Member 'FPlayerLoadoutData::CamperPerkLevels' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, CamperFavor) == 0x000040, "Member 'FPlayerLoadoutData::CamperFavor' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, Power) == 0x00004C, "Member 'FPlayerLoadoutData::Power' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, PowerAddOns) == 0x000058, "Member 'FPlayerLoadoutData::PowerAddOns' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, SlasherPerks) == 0x000068, "Member 'FPlayerLoadoutData::SlasherPerks' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, SlasherPerkLevels) == 0x000078, "Member 'FPlayerLoadoutData::SlasherPerkLevels' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, SlasherFavor) == 0x000088, "Member 'FPlayerLoadoutData::SlasherFavor' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedCharacterLevelData
// 0x0018 (0x0018 - 0x0000)
struct FSavedCharacterLevelData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPerksBeenSelected;                              // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPerkSelectionBeenGenerated;                     // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssignedPerkProperties>        PerkSelection;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedCharacterLevelData) == 0x000008, "Wrong alignment on FSavedCharacterLevelData");
static_assert(sizeof(FSavedCharacterLevelData) == 0x000018, "Wrong size on FSavedCharacterLevelData");
static_assert(offsetof(FSavedCharacterLevelData, Level) == 0x000000, "Member 'FSavedCharacterLevelData::Level' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelData, HasPerksBeenSelected) == 0x000004, "Member 'FSavedCharacterLevelData::HasPerksBeenSelected' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelData, HasPerkSelectionBeenGenerated) == 0x000005, "Member 'FSavedCharacterLevelData::HasPerkSelectionBeenGenerated' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelData, PerkSelection) == 0x000008, "Member 'FSavedCharacterLevelData::PerkSelection' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSavedProfileData
// 0x0190 (0x0190 - 0x0000)
struct FCharacterSavedProfileData final
{
public:
	int32                                         BloodWebLevel;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesConfronted;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDateTime>                      PrestigeEarnedDates;                               // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBloodWebPersistentData                BloodWebData;                                      // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	struct FPlayerLoadoutData                     CharacterLoadoutData;                              // 0x0068(0x0098)(NativeAccessSpecifierPublic)
	struct FEquippedPlayerCustomization           CurrentCustomization;                              // 0x0100(0x0038)(NativeAccessSpecifierPublic)
	TArray<class FName>                           UniquePerksAdded;                                  // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CharacterBloodwebMigrationIsDone;                  // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterSavedInventoryData>   InventoryData;                                     // 0x0150(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSavedCharacterLevelData>       CharacterLevelData;                                // 0x0160(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSavedStatsData>                StatProgression;                                   // 0x0170(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         PrestigeLevel;                                     // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LegacyPrestigeLevel;                               // 0x0184(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CharacterExperience;                               // 0x0188(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterSavedProfileData) == 0x000008, "Wrong alignment on FCharacterSavedProfileData");
static_assert(sizeof(FCharacterSavedProfileData) == 0x000190, "Wrong size on FCharacterSavedProfileData");
static_assert(offsetof(FCharacterSavedProfileData, BloodWebLevel) == 0x000000, "Member 'FCharacterSavedProfileData::BloodWebLevel' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, TimesConfronted) == 0x000004, "Member 'FCharacterSavedProfileData::TimesConfronted' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, PrestigeEarnedDates) == 0x000008, "Member 'FCharacterSavedProfileData::PrestigeEarnedDates' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, BloodWebData) == 0x000018, "Member 'FCharacterSavedProfileData::BloodWebData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, CharacterLoadoutData) == 0x000068, "Member 'FCharacterSavedProfileData::CharacterLoadoutData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, CurrentCustomization) == 0x000100, "Member 'FCharacterSavedProfileData::CurrentCustomization' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, UniquePerksAdded) == 0x000138, "Member 'FCharacterSavedProfileData::UniquePerksAdded' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, CharacterBloodwebMigrationIsDone) == 0x000148, "Member 'FCharacterSavedProfileData::CharacterBloodwebMigrationIsDone' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, InventoryData) == 0x000150, "Member 'FCharacterSavedProfileData::InventoryData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, CharacterLevelData) == 0x000160, "Member 'FCharacterSavedProfileData::CharacterLevelData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, StatProgression) == 0x000170, "Member 'FCharacterSavedProfileData::StatProgression' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, PrestigeLevel) == 0x000180, "Member 'FCharacterSavedProfileData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, LegacyPrestigeLevel) == 0x000184, "Member 'FCharacterSavedProfileData::LegacyPrestigeLevel' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, CharacterExperience) == 0x000188, "Member 'FCharacterSavedProfileData::CharacterExperience' has a wrong offset!");

// ScriptStruct DeadByDaylight.BalanceToolOverrideEntry
// 0x0030 (0x0030 - 0x0000)
struct FBalanceToolOverrideEntry final
{
public:
	class FString                                 DbName;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RowName;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBalanceToolOverrideEntry) == 0x000008, "Wrong alignment on FBalanceToolOverrideEntry");
static_assert(sizeof(FBalanceToolOverrideEntry) == 0x000030, "Wrong size on FBalanceToolOverrideEntry");
static_assert(offsetof(FBalanceToolOverrideEntry, DbName) == 0x000000, "Member 'FBalanceToolOverrideEntry::DbName' has a wrong offset!");
static_assert(offsetof(FBalanceToolOverrideEntry, RowName) == 0x000010, "Member 'FBalanceToolOverrideEntry::RowName' has a wrong offset!");
static_assert(offsetof(FBalanceToolOverrideEntry, Value) == 0x000020, "Member 'FBalanceToolOverrideEntry::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.BalanceToolGameConfig
// 0x0010 (0x0010 - 0x0000)
struct FBalanceToolGameConfig final
{
public:
	TArray<struct FBalanceToolOverrideEntry>      Overrides;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBalanceToolGameConfig) == 0x000008, "Wrong alignment on FBalanceToolGameConfig");
static_assert(sizeof(FBalanceToolGameConfig) == 0x000010, "Wrong size on FBalanceToolGameConfig");
static_assert(offsetof(FBalanceToolGameConfig, Overrides) == 0x000000, "Member 'FBalanceToolGameConfig::Overrides' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDAttackTargetTracker
// 0x00B8 (0x00B8 - 0x0000)
struct FDBDAttackTargetTracker final
{
public:
	bool                                          _useTargetTracking;                                // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatProperty                          _targetSnapDistance;                               // 0x0008(0x0088)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _ownerEyeSocketName;                               // 0x0090(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _targetBoneName;                                   // 0x009C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACharacter>              _trackedTarget;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADBDPlayer>              _owningPlayer;                                     // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDBDAttackTargetTracker) == 0x000008, "Wrong alignment on FDBDAttackTargetTracker");
static_assert(sizeof(FDBDAttackTargetTracker) == 0x0000B8, "Wrong size on FDBDAttackTargetTracker");
static_assert(offsetof(FDBDAttackTargetTracker, _useTargetTracking) == 0x000000, "Member 'FDBDAttackTargetTracker::_useTargetTracking' has a wrong offset!");
static_assert(offsetof(FDBDAttackTargetTracker, _targetSnapDistance) == 0x000008, "Member 'FDBDAttackTargetTracker::_targetSnapDistance' has a wrong offset!");
static_assert(offsetof(FDBDAttackTargetTracker, _ownerEyeSocketName) == 0x000090, "Member 'FDBDAttackTargetTracker::_ownerEyeSocketName' has a wrong offset!");
static_assert(offsetof(FDBDAttackTargetTracker, _targetBoneName) == 0x00009C, "Member 'FDBDAttackTargetTracker::_targetBoneName' has a wrong offset!");
static_assert(offsetof(FDBDAttackTargetTracker, _trackedTarget) == 0x0000A8, "Member 'FDBDAttackTargetTracker::_trackedTarget' has a wrong offset!");
static_assert(offsetof(FDBDAttackTargetTracker, _owningPlayer) == 0x0000B0, "Member 'FDBDAttackTargetTracker::_owningPlayer' has a wrong offset!");

// ScriptStruct DeadByDaylight.BlindPackData
// 0x0000 (0x0168 - 0x0168)
struct FBlindPackData final : public FBaseItemData
{
};
static_assert(alignof(FBlindPackData) == 0x000008, "Wrong alignment on FBlindPackData");
static_assert(sizeof(FBlindPackData) == 0x000168, "Wrong size on FBlindPackData");

// ScriptStruct DeadByDaylight.BlockableReplicatedDatum
// 0x0020 (0x0020 - 0x0000)
struct FBlockableReplicatedDatum final
{
public:
	TArray<TWeakObjectPtr<class UObject>>         Sources;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ADBDPlayer>>      BlockedPlayers;                                    // 0x0010(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockableReplicatedDatum) == 0x000008, "Wrong alignment on FBlockableReplicatedDatum");
static_assert(sizeof(FBlockableReplicatedDatum) == 0x000020, "Wrong size on FBlockableReplicatedDatum");
static_assert(offsetof(FBlockableReplicatedDatum, Sources) == 0x000000, "Member 'FBlockableReplicatedDatum::Sources' has a wrong offset!");
static_assert(offsetof(FBlockableReplicatedDatum, BlockedPlayers) == 0x000010, "Member 'FBlockableReplicatedDatum::BlockedPlayers' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerLevelData
// 0x000C (0x000C - 0x0000)
struct FPlayerLevelData final
{
public:
	int32                                         LevelValue;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeValue;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxXp;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerLevelData) == 0x000004, "Wrong alignment on FPlayerLevelData");
static_assert(sizeof(FPlayerLevelData) == 0x00000C, "Wrong size on FPlayerLevelData");
static_assert(offsetof(FPlayerLevelData, LevelValue) == 0x000000, "Member 'FPlayerLevelData::LevelValue' has a wrong offset!");
static_assert(offsetof(FPlayerLevelData, PrestigeValue) == 0x000004, "Member 'FPlayerLevelData::PrestigeValue' has a wrong offset!");
static_assert(offsetof(FPlayerLevelData, MaxXp) == 0x000008, "Member 'FPlayerLevelData::MaxXp' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodDecal
// 0x006C (0x006C - 0x0000)
struct alignas(0x04) FBloodDecal final
{
public:
	uint8                                         Pad_0[0x6C];                                       // 0x0000(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBloodDecal) == 0x000004, "Wrong alignment on FBloodDecal");
static_assert(sizeof(FBloodDecal) == 0x00006C, "Wrong size on FBloodDecal");

// ScriptStruct DeadByDaylight.PreLevelGenerationModifierProperties
// 0x0018 (0x0020 - 0x0008)
struct FPreLevelGenerationModifierProperties final : public FDBDTableRowBase
{
public:
	class FName                                   ModifierID;                                        // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPreLevelGenerationModifierType               ModifierType;                                      // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EKillerAbilities                              KillerAbiliy;                                      // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModifierValue;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreLevelGenerationModifierProperties) == 0x000008, "Wrong alignment on FPreLevelGenerationModifierProperties");
static_assert(sizeof(FPreLevelGenerationModifierProperties) == 0x000020, "Wrong size on FPreLevelGenerationModifierProperties");
static_assert(offsetof(FPreLevelGenerationModifierProperties, ModifierID) == 0x000008, "Member 'FPreLevelGenerationModifierProperties::ModifierID' has a wrong offset!");
static_assert(offsetof(FPreLevelGenerationModifierProperties, ModifierType) == 0x000014, "Member 'FPreLevelGenerationModifierProperties::ModifierType' has a wrong offset!");
static_assert(offsetof(FPreLevelGenerationModifierProperties, KillerAbiliy) == 0x000015, "Member 'FPreLevelGenerationModifierProperties::KillerAbiliy' has a wrong offset!");
static_assert(offsetof(FPreLevelGenerationModifierProperties, ModifierValue) == 0x000018, "Member 'FPreLevelGenerationModifierProperties::ModifierValue' has a wrong offset!");

// ScriptStruct DeadByDaylight.WebPath
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FWebPath final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWebPath) == 0x000008, "Wrong alignment on FWebPath");
static_assert(sizeof(FWebPath) == 0x000028, "Wrong size on FWebPath");

// ScriptStruct DeadByDaylight.OfferingTriggerPositionData
// 0x0010 (0x0010 - 0x0000)
struct FOfferingTriggerPositionData final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PosX;                                              // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PosY;                                              // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardIndex;                                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingTriggerPositionData) == 0x000004, "Wrong alignment on FOfferingTriggerPositionData");
static_assert(sizeof(FOfferingTriggerPositionData) == 0x000010, "Wrong size on FOfferingTriggerPositionData");
static_assert(offsetof(FOfferingTriggerPositionData, Index) == 0x000000, "Member 'FOfferingTriggerPositionData::Index' has a wrong offset!");
static_assert(offsetof(FOfferingTriggerPositionData, PosX) == 0x000004, "Member 'FOfferingTriggerPositionData::PosX' has a wrong offset!");
static_assert(offsetof(FOfferingTriggerPositionData, PosY) == 0x000008, "Member 'FOfferingTriggerPositionData::PosY' has a wrong offset!");
static_assert(offsetof(FOfferingTriggerPositionData, CardIndex) == 0x00000C, "Member 'FOfferingTriggerPositionData::CardIndex' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodstoreRowUnlockThreshold
// 0x0008 (0x0010 - 0x0008)
struct FBloodstoreRowUnlockThreshold final : public FDBDTableRowBase
{
public:
	int32                                         PreviousRowPurchasedItemsCount;                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBloodstoreRowUnlockThreshold) == 0x000008, "Wrong alignment on FBloodstoreRowUnlockThreshold");
static_assert(sizeof(FBloodstoreRowUnlockThreshold) == 0x000010, "Wrong size on FBloodstoreRowUnlockThreshold");
static_assert(offsetof(FBloodstoreRowUnlockThreshold, PreviousRowPurchasedItemsCount) == 0x000008, "Member 'FBloodstoreRowUnlockThreshold::PreviousRowPurchasedItemsCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorInfoData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FSurvivorInfoData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSurvivorInfoData) == 0x000008, "Wrong alignment on FSurvivorInfoData");
static_assert(sizeof(FSurvivorInfoData) == 0x000038, "Wrong size on FSurvivorInfoData");

// ScriptStruct DeadByDaylight.AtlantaCustomizedHudSettings
// 0x0040 (0x0040 - 0x0000)
struct FAtlantaCustomizedHudSettings final
{
public:
	struct FGameplayTag                           Id;                                                // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              NormalizedOffset;                                  // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RenderOpacity;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Version;                                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OverlapWrapperIds;                                 // 0x0020(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaCustomizedHudSettings) == 0x000008, "Wrong alignment on FAtlantaCustomizedHudSettings");
static_assert(sizeof(FAtlantaCustomizedHudSettings) == 0x000040, "Wrong size on FAtlantaCustomizedHudSettings");
static_assert(offsetof(FAtlantaCustomizedHudSettings, Id) == 0x000000, "Member 'FAtlantaCustomizedHudSettings::Id' has a wrong offset!");
static_assert(offsetof(FAtlantaCustomizedHudSettings, NormalizedOffset) == 0x00000C, "Member 'FAtlantaCustomizedHudSettings::NormalizedOffset' has a wrong offset!");
static_assert(offsetof(FAtlantaCustomizedHudSettings, Scale) == 0x000014, "Member 'FAtlantaCustomizedHudSettings::Scale' has a wrong offset!");
static_assert(offsetof(FAtlantaCustomizedHudSettings, RenderOpacity) == 0x000018, "Member 'FAtlantaCustomizedHudSettings::RenderOpacity' has a wrong offset!");
static_assert(offsetof(FAtlantaCustomizedHudSettings, Version) == 0x00001C, "Member 'FAtlantaCustomizedHudSettings::Version' has a wrong offset!");
static_assert(offsetof(FAtlantaCustomizedHudSettings, OverlapWrapperIds) == 0x000020, "Member 'FAtlantaCustomizedHudSettings::OverlapWrapperIds' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebContentTypePerRingDistribution
// 0x0058 (0x0060 - 0x0008)
struct FBloodwebContentTypePerRingDistribution final : public FDBDTableRowBase
{
public:
	int32                                         PerkPerRingMinCount;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkPerRingMaxCount;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkPerRingWeight;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfferingPerRingMinCount;                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfferingPerRingMaxCount;                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfferingPerRingWeight;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemPerRingMinCount;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemPerRingMaxCount;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemPerRingWeight;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOnPerRingMinCount;                              // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOnPerRingMaxCount;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOnPerRingWeight;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChestPerRingMinCount;                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChestPerRingMaxCount;                              // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChestPerRingWeight;                                // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPackPerRingMinCount;                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPackPerRingMaxCount;                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPackPerRingWeight;                            // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IridiscentShardsPackPerRingMinCount;               // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IridiscentShardsPackPerRingMaxCount;               // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IridiscentShardsPackPerRingWeight;                 // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBloodwebContentTypePerRingDistribution) == 0x000008, "Wrong alignment on FBloodwebContentTypePerRingDistribution");
static_assert(sizeof(FBloodwebContentTypePerRingDistribution) == 0x000060, "Wrong size on FBloodwebContentTypePerRingDistribution");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerkPerRingMinCount) == 0x000008, "Member 'FBloodwebContentTypePerRingDistribution::PerkPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerkPerRingMaxCount) == 0x00000C, "Member 'FBloodwebContentTypePerRingDistribution::PerkPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerkPerRingWeight) == 0x000010, "Member 'FBloodwebContentTypePerRingDistribution::PerkPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, OfferingPerRingMinCount) == 0x000014, "Member 'FBloodwebContentTypePerRingDistribution::OfferingPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, OfferingPerRingMaxCount) == 0x000018, "Member 'FBloodwebContentTypePerRingDistribution::OfferingPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, OfferingPerRingWeight) == 0x00001C, "Member 'FBloodwebContentTypePerRingDistribution::OfferingPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ItemPerRingMinCount) == 0x000020, "Member 'FBloodwebContentTypePerRingDistribution::ItemPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ItemPerRingMaxCount) == 0x000024, "Member 'FBloodwebContentTypePerRingDistribution::ItemPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ItemPerRingWeight) == 0x000028, "Member 'FBloodwebContentTypePerRingDistribution::ItemPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, AddOnPerRingMinCount) == 0x00002C, "Member 'FBloodwebContentTypePerRingDistribution::AddOnPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, AddOnPerRingMaxCount) == 0x000030, "Member 'FBloodwebContentTypePerRingDistribution::AddOnPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, AddOnPerRingWeight) == 0x000034, "Member 'FBloodwebContentTypePerRingDistribution::AddOnPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ChestPerRingMinCount) == 0x000038, "Member 'FBloodwebContentTypePerRingDistribution::ChestPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ChestPerRingMaxCount) == 0x00003C, "Member 'FBloodwebContentTypePerRingDistribution::ChestPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ChestPerRingWeight) == 0x000040, "Member 'FBloodwebContentTypePerRingDistribution::ChestPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerksPackPerRingMinCount) == 0x000044, "Member 'FBloodwebContentTypePerRingDistribution::PerksPackPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerksPackPerRingMaxCount) == 0x000048, "Member 'FBloodwebContentTypePerRingDistribution::PerksPackPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerksPackPerRingWeight) == 0x00004C, "Member 'FBloodwebContentTypePerRingDistribution::PerksPackPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, IridiscentShardsPackPerRingMinCount) == 0x000050, "Member 'FBloodwebContentTypePerRingDistribution::IridiscentShardsPackPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, IridiscentShardsPackPerRingMaxCount) == 0x000054, "Member 'FBloodwebContentTypePerRingDistribution::IridiscentShardsPackPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, IridiscentShardsPackPerRingWeight) == 0x000058, "Member 'FBloodwebContentTypePerRingDistribution::IridiscentShardsPackPerRingWeight' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebCostModifier
// 0x0008 (0x0010 - 0x0008)
struct FBloodwebCostModifier final : public FDBDTableRowBase
{
public:
	EBloodwebNodeContentType                      Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CostModifier;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebCostModifier) == 0x000008, "Wrong alignment on FBloodwebCostModifier");
static_assert(sizeof(FBloodwebCostModifier) == 0x000010, "Wrong size on FBloodwebCostModifier");
static_assert(offsetof(FBloodwebCostModifier, Type) == 0x000008, "Member 'FBloodwebCostModifier::Type' has a wrong offset!");
static_assert(offsetof(FBloodwebCostModifier, CostModifier) == 0x00000C, "Member 'FBloodwebCostModifier::CostModifier' has a wrong offset!");

// ScriptStruct DeadByDaylight.BlockingNode
// 0x0018 (0x0018 - 0x0000)
struct FBlockingNode final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockingCount;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlockingNode) == 0x000008, "Wrong alignment on FBlockingNode");
static_assert(sizeof(FBlockingNode) == 0x000018, "Wrong size on FBlockingNode");
static_assert(offsetof(FBlockingNode, Id) == 0x000000, "Member 'FBlockingNode::Id' has a wrong offset!");
static_assert(offsetof(FBlockingNode, BlockingCount) == 0x000010, "Member 'FBlockingNode::BlockingCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.PostAttackData
// 0x0007 (0x0007 - 0x0000)
struct FPostAttackData final
{
public:
	bool                                          IsOblivious;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKO;                                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExposed;                                         // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPostPhaseWalkAttack;                             // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDownedInDemonMode;                               // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLegionBleedOutAttack;                            // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDemogorgonPounceAttack;                          // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPostAttackData) == 0x000001, "Wrong alignment on FPostAttackData");
static_assert(sizeof(FPostAttackData) == 0x000007, "Wrong size on FPostAttackData");
static_assert(offsetof(FPostAttackData, IsOblivious) == 0x000000, "Member 'FPostAttackData::IsOblivious' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsKO) == 0x000001, "Member 'FPostAttackData::IsKO' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsExposed) == 0x000002, "Member 'FPostAttackData::IsExposed' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsPostPhaseWalkAttack) == 0x000003, "Member 'FPostAttackData::IsPostPhaseWalkAttack' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsDownedInDemonMode) == 0x000004, "Member 'FPostAttackData::IsDownedInDemonMode' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsLegionBleedOutAttack) == 0x000005, "Member 'FPostAttackData::IsLegionBleedOutAttack' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsDemogorgonPounceAttack) == 0x000006, "Member 'FPostAttackData::IsDemogorgonPounceAttack' has a wrong offset!");

// ScriptStruct DeadByDaylight.StaticMeshAutoBatch
// 0x0030 (0x0030 - 0x0000)
struct FStaticMeshAutoBatch final
{
public:
	class UStaticMesh*                            staticMesh;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           staticMeshComponents;                              // 0x0020(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaticMeshAutoBatch) == 0x000008, "Wrong alignment on FStaticMeshAutoBatch");
static_assert(sizeof(FStaticMeshAutoBatch) == 0x000030, "Wrong size on FStaticMeshAutoBatch");
static_assert(offsetof(FStaticMeshAutoBatch, staticMesh) == 0x000000, "Member 'FStaticMeshAutoBatch::staticMesh' has a wrong offset!");
static_assert(offsetof(FStaticMeshAutoBatch, staticMeshComponents) == 0x000020, "Member 'FStaticMeshAutoBatch::staticMeshComponents' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharmDropdown
// 0x000E (0x0010 - 0x0002)
struct FCharmDropdown final : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharmId;                                           // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharmDropdown) == 0x000004, "Wrong alignment on FCharmDropdown");
static_assert(sizeof(FCharmDropdown) == 0x000010, "Wrong size on FCharmDropdown");
static_assert(offsetof(FCharmDropdown, CharmId) == 0x000004, "Member 'FCharmDropdown::CharmId' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRitualPossibleCharacters
// 0x0030 (0x0030 - 0x0000)
struct FDailyRitualPossibleCharacters final
{
public:
	TArray<int32>                                 CharacterIDs;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           Roles;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           SelectOneCharacterFromRoles;                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRitualPossibleCharacters) == 0x000008, "Wrong alignment on FDailyRitualPossibleCharacters");
static_assert(sizeof(FDailyRitualPossibleCharacters) == 0x000030, "Wrong size on FDailyRitualPossibleCharacters");
static_assert(offsetof(FDailyRitualPossibleCharacters, CharacterIDs) == 0x000000, "Member 'FDailyRitualPossibleCharacters::CharacterIDs' has a wrong offset!");
static_assert(offsetof(FDailyRitualPossibleCharacters, Roles) == 0x000010, "Member 'FDailyRitualPossibleCharacters::Roles' has a wrong offset!");
static_assert(offsetof(FDailyRitualPossibleCharacters, SelectOneCharacterFromRoles) == 0x000020, "Member 'FDailyRitualPossibleCharacters::SelectOneCharacterFromRoles' has a wrong offset!");

// ScriptStruct DeadByDaylight.MaterialOriginalState
// 0x0018 (0x0018 - 0x0000)
struct FMaterialOriginalState final
{
public:
	class UMeshComponent*                         MeshWithChangedMaterials;                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             OriginalMaterial;                                  // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialOriginalState) == 0x000008, "Wrong alignment on FMaterialOriginalState");
static_assert(sizeof(FMaterialOriginalState) == 0x000018, "Wrong size on FMaterialOriginalState");
static_assert(offsetof(FMaterialOriginalState, MeshWithChangedMaterials) == 0x000000, "Member 'FMaterialOriginalState::MeshWithChangedMaterials' has a wrong offset!");
static_assert(offsetof(FMaterialOriginalState, OriginalMaterial) == 0x000008, "Member 'FMaterialOriginalState::OriginalMaterial' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChargeData
// 0x0010 (0x0010 - 0x0000)
struct FChargeData final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeAmount;                                      // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BypassSkillCheckFail;                              // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOneTimeIncrease;                                 // 0x000D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChargeData) == 0x000008, "Wrong alignment on FChargeData");
static_assert(sizeof(FChargeData) == 0x000010, "Wrong size on FChargeData");
static_assert(offsetof(FChargeData, Instigator) == 0x000000, "Member 'FChargeData::Instigator' has a wrong offset!");
static_assert(offsetof(FChargeData, ChargeAmount) == 0x000008, "Member 'FChargeData::ChargeAmount' has a wrong offset!");
static_assert(offsetof(FChargeData, BypassSkillCheckFail) == 0x00000C, "Member 'FChargeData::BypassSkillCheckFail' has a wrong offset!");
static_assert(offsetof(FChargeData, IsOneTimeIncrease) == 0x00000D, "Member 'FChargeData::IsOneTimeIncrease' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContentPerWebDistribution
// 0x0010 (0x0010 - 0x0000)
struct FContentPerWebDistribution final
{
public:
	int32                                         CumulativeWeight;                                  // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCount;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContentPerWebDistribution) == 0x000004, "Wrong alignment on FContentPerWebDistribution");
static_assert(sizeof(FContentPerWebDistribution) == 0x000010, "Wrong size on FContentPerWebDistribution");
static_assert(offsetof(FContentPerWebDistribution, CumulativeWeight) == 0x000000, "Member 'FContentPerWebDistribution::CumulativeWeight' has a wrong offset!");
static_assert(offsetof(FContentPerWebDistribution, Weight) == 0x000004, "Member 'FContentPerWebDistribution::Weight' has a wrong offset!");
static_assert(offsetof(FContentPerWebDistribution, MinCount) == 0x000008, "Member 'FContentPerWebDistribution::MinCount' has a wrong offset!");
static_assert(offsetof(FContentPerWebDistribution, MaxCount) == 0x00000C, "Member 'FContentPerWebDistribution::MaxCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRitualInstance
// 0x0078 (0x0078 - 0x0000)
struct FDailyRitualInstance final
{
public:
	class FString                                 RitualId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EDBDScoreTypes>                        TrackedEvents;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   TrackedGameEvents;                                 // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CharacterIDs;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           Roles;                                             // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threshold;                                         // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayThreshold;                                  // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpReward;                                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Active;                                            // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTemporary;                                       // 0x0065(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DateAssigned;                                      // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URitualEvaluatorBase*                   Evaluator;                                         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRitualInstance) == 0x000008, "Wrong alignment on FDailyRitualInstance");
static_assert(sizeof(FDailyRitualInstance) == 0x000078, "Wrong size on FDailyRitualInstance");
static_assert(offsetof(FDailyRitualInstance, RitualId) == 0x000000, "Member 'FDailyRitualInstance::RitualId' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, TrackedEvents) == 0x000010, "Member 'FDailyRitualInstance::TrackedEvents' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, TrackedGameEvents) == 0x000020, "Member 'FDailyRitualInstance::TrackedGameEvents' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, CharacterIDs) == 0x000030, "Member 'FDailyRitualInstance::CharacterIDs' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Roles) == 0x000040, "Member 'FDailyRitualInstance::Roles' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Progress) == 0x000050, "Member 'FDailyRitualInstance::Progress' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Threshold) == 0x000054, "Member 'FDailyRitualInstance::Threshold' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Tolerance) == 0x000058, "Member 'FDailyRitualInstance::Tolerance' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, DisplayThreshold) == 0x00005C, "Member 'FDailyRitualInstance::DisplayThreshold' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, ExpReward) == 0x000060, "Member 'FDailyRitualInstance::ExpReward' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Active) == 0x000064, "Member 'FDailyRitualInstance::Active' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, IsTemporary) == 0x000065, "Member 'FDailyRitualInstance::IsTemporary' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, DateAssigned) == 0x000068, "Member 'FDailyRitualInstance::DateAssigned' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Evaluator) == 0x000070, "Member 'FDailyRitualInstance::Evaluator' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContentPerRingDistribution
// 0x0030 (0x0030 - 0x0000)
struct FContentPerRingDistribution final
{
public:
	TArray<int32>                                 WeightList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MinCountList;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MaxCountList;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContentPerRingDistribution) == 0x000008, "Wrong alignment on FContentPerRingDistribution");
static_assert(sizeof(FContentPerRingDistribution) == 0x000030, "Wrong size on FContentPerRingDistribution");
static_assert(offsetof(FContentPerRingDistribution, WeightList) == 0x000000, "Member 'FContentPerRingDistribution::WeightList' has a wrong offset!");
static_assert(offsetof(FContentPerRingDistribution, MinCountList) == 0x000010, "Member 'FContentPerRingDistribution::MinCountList' has a wrong offset!");
static_assert(offsetof(FContentPerRingDistribution, MaxCountList) == 0x000020, "Member 'FContentPerRingDistribution::MaxCountList' has a wrong offset!");

// ScriptStruct DeadByDaylight.RarityPerWebDistribution
// 0x000C (0x000C - 0x0000)
struct FRarityPerWebDistribution final
{
public:
	int32                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCount;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRarityPerWebDistribution) == 0x000004, "Wrong alignment on FRarityPerWebDistribution");
static_assert(sizeof(FRarityPerWebDistribution) == 0x00000C, "Wrong size on FRarityPerWebDistribution");
static_assert(offsetof(FRarityPerWebDistribution, Weight) == 0x000000, "Member 'FRarityPerWebDistribution::Weight' has a wrong offset!");
static_assert(offsetof(FRarityPerWebDistribution, MinCount) == 0x000004, "Member 'FRarityPerWebDistribution::MinCount' has a wrong offset!");
static_assert(offsetof(FRarityPerWebDistribution, MaxCount) == 0x000008, "Member 'FRarityPerWebDistribution::MaxCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.LevelUpDetails
// 0x0050 (0x0058 - 0x0008)
struct FLevelUpDetails final : public FDBDTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prestige;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AssociatedCharacter;                               // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelUpDetails) == 0x000008, "Wrong alignment on FLevelUpDetails");
static_assert(sizeof(FLevelUpDetails) == 0x000058, "Wrong size on FLevelUpDetails");
static_assert(offsetof(FLevelUpDetails, Level) == 0x000008, "Member 'FLevelUpDetails::Level' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, Prestige) == 0x00000C, "Member 'FLevelUpDetails::Prestige' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, Title) == 0x000010, "Member 'FLevelUpDetails::Title' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, Description) == 0x000028, "Member 'FLevelUpDetails::Description' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, ItemId) == 0x000040, "Member 'FLevelUpDetails::ItemId' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, ItemType) == 0x00004C, "Member 'FLevelUpDetails::ItemType' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, AssociatedCharacter) == 0x000050, "Member 'FLevelUpDetails::AssociatedCharacter' has a wrong offset!");

// ScriptStruct DeadByDaylight.RarityPerRingDistribution
// 0x0030 (0x0030 - 0x0000)
struct FRarityPerRingDistribution final
{
public:
	TArray<int32>                                 WeightList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MinCountList;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MaxCountList;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRarityPerRingDistribution) == 0x000008, "Wrong alignment on FRarityPerRingDistribution");
static_assert(sizeof(FRarityPerRingDistribution) == 0x000030, "Wrong size on FRarityPerRingDistribution");
static_assert(offsetof(FRarityPerRingDistribution, WeightList) == 0x000000, "Member 'FRarityPerRingDistribution::WeightList' has a wrong offset!");
static_assert(offsetof(FRarityPerRingDistribution, MinCountList) == 0x000010, "Member 'FRarityPerRingDistribution::MinCountList' has a wrong offset!");
static_assert(offsetof(FRarityPerRingDistribution, MaxCountList) == 0x000020, "Member 'FRarityPerRingDistribution::MaxCountList' has a wrong offset!");

// ScriptStruct DeadByDaylight.AccessNode
// 0x0018 (0x0018 - 0x0000)
struct FAccessNode final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessCost;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAccessNode) == 0x000008, "Wrong alignment on FAccessNode");
static_assert(sizeof(FAccessNode) == 0x000018, "Wrong size on FAccessNode");
static_assert(offsetof(FAccessNode, Id) == 0x000000, "Member 'FAccessNode::Id' has a wrong offset!");
static_assert(offsetof(FAccessNode, AccessCost) == 0x000010, "Member 'FAccessNode::AccessCost' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugLoadoutPerk
// 0x0014 (0x0014 - 0x0000)
struct FDebugLoadoutPerk final
{
public:
	struct FPerkDropdown                          PerkDropdown;                                      // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         PerkLevel;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugLoadoutPerk) == 0x000004, "Wrong alignment on FDebugLoadoutPerk");
static_assert(sizeof(FDebugLoadoutPerk) == 0x000014, "Wrong size on FDebugLoadoutPerk");
static_assert(offsetof(FDebugLoadoutPerk, PerkDropdown) == 0x000000, "Member 'FDebugLoadoutPerk::PerkDropdown' has a wrong offset!");
static_assert(offsetof(FDebugLoadoutPerk, PerkLevel) == 0x000010, "Member 'FDebugLoadoutPerk::PerkLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugLoadoutAddon
// 0x0010 (0x0010 - 0x0000)
struct FDebugLoadoutAddon final
{
public:
	struct FAddonDropdown                         AddonDropdown;                                     // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugLoadoutAddon) == 0x000004, "Wrong alignment on FDebugLoadoutAddon");
static_assert(sizeof(FDebugLoadoutAddon) == 0x000010, "Wrong size on FDebugLoadoutAddon");
static_assert(offsetof(FDebugLoadoutAddon, AddonDropdown) == 0x000000, "Member 'FDebugLoadoutAddon::AddonDropdown' has a wrong offset!");

// ScriptStruct DeadByDaylight.SlasherLoadout
// 0x0080 (0x0080 - 0x0000)
struct FSlasherLoadout final
{
public:
	TArray<struct FDebugLoadoutPerk>              Perks;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDebugLoadoutAddon>             PowerAddonIDs;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCharacterCustomizationDropdown        Slasher;                                           // 0x0020(0x005C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlasherLoadout) == 0x000008, "Wrong alignment on FSlasherLoadout");
static_assert(sizeof(FSlasherLoadout) == 0x000080, "Wrong size on FSlasherLoadout");
static_assert(offsetof(FSlasherLoadout, Perks) == 0x000000, "Member 'FSlasherLoadout::Perks' has a wrong offset!");
static_assert(offsetof(FSlasherLoadout, PowerAddonIDs) == 0x000010, "Member 'FSlasherLoadout::PowerAddonIDs' has a wrong offset!");
static_assert(offsetof(FSlasherLoadout, Slasher) == 0x000020, "Member 'FSlasherLoadout::Slasher' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNodeCost
// 0x0008 (0x0010 - 0x0008)
struct FBloodwebNodeCost final : public FDBDTableRowBase
{
public:
	EItemRarity                                   Rarity;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebNodeCost) == 0x000008, "Wrong alignment on FBloodwebNodeCost");
static_assert(sizeof(FBloodwebNodeCost) == 0x000010, "Wrong size on FBloodwebNodeCost");
static_assert(offsetof(FBloodwebNodeCost, Rarity) == 0x000008, "Member 'FBloodwebNodeCost::Rarity' has a wrong offset!");
static_assert(offsetof(FBloodwebNodeCost, Cost) == 0x00000C, "Member 'FBloodwebNodeCost::Cost' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNodeRarityCost
// 0x0008 (0x0010 - 0x0008)
struct FBloodwebNodeRarityCost final : public FDBDTableRowBase
{
public:
	EItemRarity                                   Rarity;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebNodeRarityCost) == 0x000008, "Wrong alignment on FBloodwebNodeRarityCost");
static_assert(sizeof(FBloodwebNodeRarityCost) == 0x000010, "Wrong size on FBloodwebNodeRarityCost");
static_assert(offsetof(FBloodwebNodeRarityCost, Rarity) == 0x000008, "Member 'FBloodwebNodeRarityCost::Rarity' has a wrong offset!");
static_assert(offsetof(FBloodwebNodeRarityCost, Cost) == 0x00000C, "Member 'FBloodwebNodeRarityCost::Cost' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDCustomizationToolData
// 0x0E18 (0x0E18 - 0x0000)
struct FDBDCustomizationToolData final
{
public:
	struct FCustomizationItemData                 Head;                                              // 0x0000(0x0368)(Edit, NativeAccessSpecifierPublic)
	struct FCustomizationItemData                 Torso;                                             // 0x0368(0x0368)(Edit, NativeAccessSpecifierPublic)
	struct FCustomizationItemData                 Leg;                                               // 0x06D0(0x0368)(Edit, NativeAccessSpecifierPublic)
	struct FCustomizationItemData                 Bodies;                                            // 0x0A38(0x0368)(Edit, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0DA0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RoleName;                                          // 0x0DB0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          BaseSkeleton;                                      // 0x0DC0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MaskTexture;                                       // 0x0DC8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimationToPlay;                                   // 0x0DD0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrHeadDLC;                                        // 0x0DD8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrTorsoDLC;                                       // 0x0DE8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrLegDLC;                                         // 0x0DF8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrBodiesDLC;                                      // 0x0E08(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDCustomizationToolData) == 0x000008, "Wrong alignment on FDBDCustomizationToolData");
static_assert(sizeof(FDBDCustomizationToolData) == 0x000E18, "Wrong size on FDBDCustomizationToolData");
static_assert(offsetof(FDBDCustomizationToolData, Head) == 0x000000, "Member 'FDBDCustomizationToolData::Head' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, Torso) == 0x000368, "Member 'FDBDCustomizationToolData::Torso' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, Leg) == 0x0006D0, "Member 'FDBDCustomizationToolData::Leg' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, Bodies) == 0x000A38, "Member 'FDBDCustomizationToolData::Bodies' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, CharacterName) == 0x000DA0, "Member 'FDBDCustomizationToolData::CharacterName' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, RoleName) == 0x000DB0, "Member 'FDBDCustomizationToolData::RoleName' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, BaseSkeleton) == 0x000DC0, "Member 'FDBDCustomizationToolData::BaseSkeleton' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, MaskTexture) == 0x000DC8, "Member 'FDBDCustomizationToolData::MaskTexture' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, AnimationToPlay) == 0x000DD0, "Member 'FDBDCustomizationToolData::AnimationToPlay' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, StrHeadDLC) == 0x000DD8, "Member 'FDBDCustomizationToolData::StrHeadDLC' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, StrTorsoDLC) == 0x000DE8, "Member 'FDBDCustomizationToolData::StrTorsoDLC' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, StrLegDLC) == 0x000DF8, "Member 'FDBDCustomizationToolData::StrLegDLC' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, StrBodiesDLC) == 0x000E08, "Member 'FDBDCustomizationToolData::StrBodiesDLC' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNodesPerRingDistribution
// 0x0008 (0x0010 - 0x0008)
struct FBloodwebNodesPerRingDistribution final : public FDBDTableRowBase
{
public:
	int32                                         MinCount;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebNodesPerRingDistribution) == 0x000008, "Wrong alignment on FBloodwebNodesPerRingDistribution");
static_assert(sizeof(FBloodwebNodesPerRingDistribution) == 0x000010, "Wrong size on FBloodwebNodesPerRingDistribution");
static_assert(offsetof(FBloodwebNodesPerRingDistribution, MinCount) == 0x000008, "Member 'FBloodwebNodesPerRingDistribution::MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebNodesPerRingDistribution, MaxCount) == 0x00000C, "Member 'FBloodwebNodesPerRingDistribution::MaxCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemIdDropdown
// 0x000E (0x0010 - 0x0002)
struct FItemIdDropdown final : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemID;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemIdDropdown) == 0x000004, "Wrong alignment on FItemIdDropdown");
static_assert(sizeof(FItemIdDropdown) == 0x000010, "Wrong size on FItemIdDropdown");
static_assert(offsetof(FItemIdDropdown, ItemID) == 0x000004, "Member 'FItemIdDropdown::ItemID' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebPrestigeModifiers
// 0x0020 (0x0028 - 0x0008)
struct FBloodwebPrestigeModifiers final : public FDBDTableRowBase
{
public:
	float                                         CommonItemProbabilityModifier;                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UncommonItemProbabilityModifier;                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RareItemProbabilityModifier;                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VeryRareItemProbabilityModifier;                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltraRareItemProbabilityModifier;                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArtifactItemProbabilityModifier;                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpectralItemProbabilityModifier;                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegendaryItemProbabilityModifier;                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebPrestigeModifiers) == 0x000008, "Wrong alignment on FBloodwebPrestigeModifiers");
static_assert(sizeof(FBloodwebPrestigeModifiers) == 0x000028, "Wrong size on FBloodwebPrestigeModifiers");
static_assert(offsetof(FBloodwebPrestigeModifiers, CommonItemProbabilityModifier) == 0x000008, "Member 'FBloodwebPrestigeModifiers::CommonItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, UncommonItemProbabilityModifier) == 0x00000C, "Member 'FBloodwebPrestigeModifiers::UncommonItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, RareItemProbabilityModifier) == 0x000010, "Member 'FBloodwebPrestigeModifiers::RareItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, VeryRareItemProbabilityModifier) == 0x000014, "Member 'FBloodwebPrestigeModifiers::VeryRareItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, UltraRareItemProbabilityModifier) == 0x000018, "Member 'FBloodwebPrestigeModifiers::UltraRareItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, ArtifactItemProbabilityModifier) == 0x00001C, "Member 'FBloodwebPrestigeModifiers::ArtifactItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, SpectralItemProbabilityModifier) == 0x000020, "Member 'FBloodwebPrestigeModifiers::SpectralItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, LegendaryItemProbabilityModifier) == 0x000024, "Member 'FBloodwebPrestigeModifiers::LegendaryItemProbabilityModifier' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameEventForwarderInfo
// 0x0020 (0x0020 - 0x0000)
struct FGameEventForwarderInfo final
{
public:
	TArray<struct FGameplayTag>                   GameEventsToRegister;                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ForwardedEvent;                                    // 0x0010(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameEventForwarderInfo) == 0x000008, "Wrong alignment on FGameEventForwarderInfo");
static_assert(sizeof(FGameEventForwarderInfo) == 0x000020, "Wrong size on FGameEventForwarderInfo");
static_assert(offsetof(FGameEventForwarderInfo, GameEventsToRegister) == 0x000000, "Member 'FGameEventForwarderInfo::GameEventsToRegister' has a wrong offset!");
static_assert(offsetof(FGameEventForwarderInfo, ForwardedEvent) == 0x000010, "Member 'FGameEventForwarderInfo::ForwardedEvent' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebProgressionValue
// 0x00E8 (0x00F0 - 0x0008)
struct FBloodwebProgressionValue final : public FDBDTableRowBase
{
public:
	int32                                         InnerRingNodeCount;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingNodeCount;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingNodeCount;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Common_MinCount;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Common_MaxCount;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Uncommon_MinCount;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Uncommon_MaxCount;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rare_MinCount;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rare_MaxCount;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRare_MinCount;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRare_MaxCount;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRare_MinCount;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRare_MaxCount;                                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Artifact_MinCount;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Artifact_MaxCount;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spectral_MinCount;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spectral_MaxCount;                                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEvent_MinCount;                             // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEvent_MaxCount;                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Legendary_MinCount;                                // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Legendary_MaxCount;                                // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingCommonItemProbability;                    // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingCommonItemProbability;                   // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingCommonItemProbability;                    // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUncommonItemProbability;                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUncommonItemProbability;                 // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUncommonItemProbability;                  // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingRareItemProbability;                      // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingRareItemProbability;                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingRareItemProbability;                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingVeryRareItemProbability;                  // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingVeryRareItemProbability;                 // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingVeryRareItemProbability;                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUltraRareItemProbability;                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUltraRareItemProbability;                // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUltraRareItemProbability;                 // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingArtifactItemProbability;                  // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingArtifactItemProbability;                 // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingArtifactItemProbability;                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSpectralItemProbability;                  // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSpectralItemProbability;                 // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSpectralItemProbability;                  // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSpecialEventItemProbability;              // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSpecialEventItemProbability;             // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSpecialEventItemProbability;              // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingLegendaryItemProbability;                 // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingLegendaryItemProbability;                // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingLegendaryItemProbability;                 // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingEpicItemProbability;                      // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingEpicItemProbability;                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingEpicItemProbability;                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSuperEpicItemProbability;                 // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSuperEpicItemProbability;                // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSuperEpicItemProbability;                 // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUltraEpicItemProbability;                 // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUltraEpicItemProbability;                // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUltraEpicItemProbability;                 // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityStartingRound;                               // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebProgressionValue) == 0x000008, "Wrong alignment on FBloodwebProgressionValue");
static_assert(sizeof(FBloodwebProgressionValue) == 0x0000F0, "Wrong size on FBloodwebProgressionValue");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingNodeCount) == 0x000008, "Member 'FBloodwebProgressionValue::InnerRingNodeCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingNodeCount) == 0x00000C, "Member 'FBloodwebProgressionValue::MiddleRingNodeCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingNodeCount) == 0x000010, "Member 'FBloodwebProgressionValue::OuterRingNodeCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Common_MinCount) == 0x000014, "Member 'FBloodwebProgressionValue::Common_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Common_MaxCount) == 0x000018, "Member 'FBloodwebProgressionValue::Common_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Uncommon_MinCount) == 0x00001C, "Member 'FBloodwebProgressionValue::Uncommon_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Uncommon_MaxCount) == 0x000020, "Member 'FBloodwebProgressionValue::Uncommon_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Rare_MinCount) == 0x000024, "Member 'FBloodwebProgressionValue::Rare_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Rare_MaxCount) == 0x000028, "Member 'FBloodwebProgressionValue::Rare_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, VeryRare_MinCount) == 0x00002C, "Member 'FBloodwebProgressionValue::VeryRare_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, VeryRare_MaxCount) == 0x000030, "Member 'FBloodwebProgressionValue::VeryRare_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, UltraRare_MinCount) == 0x000034, "Member 'FBloodwebProgressionValue::UltraRare_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, UltraRare_MaxCount) == 0x000038, "Member 'FBloodwebProgressionValue::UltraRare_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Artifact_MinCount) == 0x00003C, "Member 'FBloodwebProgressionValue::Artifact_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Artifact_MaxCount) == 0x000040, "Member 'FBloodwebProgressionValue::Artifact_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Spectral_MinCount) == 0x000044, "Member 'FBloodwebProgressionValue::Spectral_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Spectral_MaxCount) == 0x000048, "Member 'FBloodwebProgressionValue::Spectral_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, SpecialEvent_MinCount) == 0x00004C, "Member 'FBloodwebProgressionValue::SpecialEvent_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, SpecialEvent_MaxCount) == 0x000050, "Member 'FBloodwebProgressionValue::SpecialEvent_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Legendary_MinCount) == 0x000054, "Member 'FBloodwebProgressionValue::Legendary_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Legendary_MaxCount) == 0x000058, "Member 'FBloodwebProgressionValue::Legendary_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingCommonItemProbability) == 0x00005C, "Member 'FBloodwebProgressionValue::InnerRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingCommonItemProbability) == 0x000060, "Member 'FBloodwebProgressionValue::MiddleRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingCommonItemProbability) == 0x000064, "Member 'FBloodwebProgressionValue::OuterRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingUncommonItemProbability) == 0x000068, "Member 'FBloodwebProgressionValue::InnerRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingUncommonItemProbability) == 0x00006C, "Member 'FBloodwebProgressionValue::MiddleRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingUncommonItemProbability) == 0x000070, "Member 'FBloodwebProgressionValue::OuterRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingRareItemProbability) == 0x000074, "Member 'FBloodwebProgressionValue::InnerRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingRareItemProbability) == 0x000078, "Member 'FBloodwebProgressionValue::MiddleRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingRareItemProbability) == 0x00007C, "Member 'FBloodwebProgressionValue::OuterRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingVeryRareItemProbability) == 0x000080, "Member 'FBloodwebProgressionValue::InnerRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingVeryRareItemProbability) == 0x000084, "Member 'FBloodwebProgressionValue::MiddleRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingVeryRareItemProbability) == 0x000088, "Member 'FBloodwebProgressionValue::OuterRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingUltraRareItemProbability) == 0x00008C, "Member 'FBloodwebProgressionValue::InnerRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingUltraRareItemProbability) == 0x000090, "Member 'FBloodwebProgressionValue::MiddleRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingUltraRareItemProbability) == 0x000094, "Member 'FBloodwebProgressionValue::OuterRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingArtifactItemProbability) == 0x000098, "Member 'FBloodwebProgressionValue::InnerRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingArtifactItemProbability) == 0x00009C, "Member 'FBloodwebProgressionValue::MiddleRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingArtifactItemProbability) == 0x0000A0, "Member 'FBloodwebProgressionValue::OuterRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingSpectralItemProbability) == 0x0000A4, "Member 'FBloodwebProgressionValue::InnerRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingSpectralItemProbability) == 0x0000A8, "Member 'FBloodwebProgressionValue::MiddleRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingSpectralItemProbability) == 0x0000AC, "Member 'FBloodwebProgressionValue::OuterRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingSpecialEventItemProbability) == 0x0000B0, "Member 'FBloodwebProgressionValue::InnerRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingSpecialEventItemProbability) == 0x0000B4, "Member 'FBloodwebProgressionValue::MiddleRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingSpecialEventItemProbability) == 0x0000B8, "Member 'FBloodwebProgressionValue::OuterRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingLegendaryItemProbability) == 0x0000BC, "Member 'FBloodwebProgressionValue::InnerRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingLegendaryItemProbability) == 0x0000C0, "Member 'FBloodwebProgressionValue::MiddleRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingLegendaryItemProbability) == 0x0000C4, "Member 'FBloodwebProgressionValue::OuterRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingEpicItemProbability) == 0x0000C8, "Member 'FBloodwebProgressionValue::InnerRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingEpicItemProbability) == 0x0000CC, "Member 'FBloodwebProgressionValue::MiddleRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingEpicItemProbability) == 0x0000D0, "Member 'FBloodwebProgressionValue::OuterRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingSuperEpicItemProbability) == 0x0000D4, "Member 'FBloodwebProgressionValue::InnerRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingSuperEpicItemProbability) == 0x0000D8, "Member 'FBloodwebProgressionValue::MiddleRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingSuperEpicItemProbability) == 0x0000DC, "Member 'FBloodwebProgressionValue::OuterRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingUltraEpicItemProbability) == 0x0000E0, "Member 'FBloodwebProgressionValue::InnerRingUltraEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingUltraEpicItemProbability) == 0x0000E4, "Member 'FBloodwebProgressionValue::MiddleRingUltraEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingUltraEpicItemProbability) == 0x0000E8, "Member 'FBloodwebProgressionValue::OuterRingUltraEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, EntityStartingRound) == 0x0000EC, "Member 'FBloodwebProgressionValue::EntityStartingRound' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebRarityPerRingDistribution
// 0x0090 (0x0098 - 0x0008)
struct FBloodwebRarityPerRingDistribution final : public FDBDTableRowBase
{
public:
	int32                                         CommonMinCount;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CommonMaxCount;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CommonWeight;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UncommonMinCount;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UncommonMaxCount;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UncommonWeight;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareMinCount;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareMaxCount;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareWeight;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRareMinCount;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRareMaxCount;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRareWeight;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRareMinCount;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRareMaxCount;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRareWeight;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArtefactMinCount;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArtefactMaxCount;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArtefactWeight;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpectralMinCount;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpectralMaxCount;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpectralWeight;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEventMinCount;                              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEventMaxCount;                              // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEventWeight;                                // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegendaryMinCount;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegendaryMaxCount;                                 // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegendaryWeight;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EpicMinCount;                                      // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EpicMaxCount;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EpicWeight;                                        // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperEpicMinCount;                                 // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperEpicMaxCount;                                 // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperEpicWeight;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraEpicMinCount;                                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraEpicMaxCount;                                 // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraEpicWeight;                                   // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebRarityPerRingDistribution) == 0x000008, "Wrong alignment on FBloodwebRarityPerRingDistribution");
static_assert(sizeof(FBloodwebRarityPerRingDistribution) == 0x000098, "Wrong size on FBloodwebRarityPerRingDistribution");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, CommonMinCount) == 0x000008, "Member 'FBloodwebRarityPerRingDistribution::CommonMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, CommonMaxCount) == 0x00000C, "Member 'FBloodwebRarityPerRingDistribution::CommonMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, CommonWeight) == 0x000010, "Member 'FBloodwebRarityPerRingDistribution::CommonWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UncommonMinCount) == 0x000014, "Member 'FBloodwebRarityPerRingDistribution::UncommonMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UncommonMaxCount) == 0x000018, "Member 'FBloodwebRarityPerRingDistribution::UncommonMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UncommonWeight) == 0x00001C, "Member 'FBloodwebRarityPerRingDistribution::UncommonWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, RareMinCount) == 0x000020, "Member 'FBloodwebRarityPerRingDistribution::RareMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, RareMaxCount) == 0x000024, "Member 'FBloodwebRarityPerRingDistribution::RareMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, RareWeight) == 0x000028, "Member 'FBloodwebRarityPerRingDistribution::RareWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, VeryRareMinCount) == 0x00002C, "Member 'FBloodwebRarityPerRingDistribution::VeryRareMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, VeryRareMaxCount) == 0x000030, "Member 'FBloodwebRarityPerRingDistribution::VeryRareMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, VeryRareWeight) == 0x000034, "Member 'FBloodwebRarityPerRingDistribution::VeryRareWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraRareMinCount) == 0x000038, "Member 'FBloodwebRarityPerRingDistribution::UltraRareMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraRareMaxCount) == 0x00003C, "Member 'FBloodwebRarityPerRingDistribution::UltraRareMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraRareWeight) == 0x000040, "Member 'FBloodwebRarityPerRingDistribution::UltraRareWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, ArtefactMinCount) == 0x000044, "Member 'FBloodwebRarityPerRingDistribution::ArtefactMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, ArtefactMaxCount) == 0x000048, "Member 'FBloodwebRarityPerRingDistribution::ArtefactMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, ArtefactWeight) == 0x00004C, "Member 'FBloodwebRarityPerRingDistribution::ArtefactWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpectralMinCount) == 0x000050, "Member 'FBloodwebRarityPerRingDistribution::SpectralMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpectralMaxCount) == 0x000054, "Member 'FBloodwebRarityPerRingDistribution::SpectralMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpectralWeight) == 0x000058, "Member 'FBloodwebRarityPerRingDistribution::SpectralWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpecialEventMinCount) == 0x00005C, "Member 'FBloodwebRarityPerRingDistribution::SpecialEventMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpecialEventMaxCount) == 0x000060, "Member 'FBloodwebRarityPerRingDistribution::SpecialEventMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpecialEventWeight) == 0x000064, "Member 'FBloodwebRarityPerRingDistribution::SpecialEventWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, LegendaryMinCount) == 0x000068, "Member 'FBloodwebRarityPerRingDistribution::LegendaryMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, LegendaryMaxCount) == 0x00006C, "Member 'FBloodwebRarityPerRingDistribution::LegendaryMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, LegendaryWeight) == 0x000070, "Member 'FBloodwebRarityPerRingDistribution::LegendaryWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, EpicMinCount) == 0x000074, "Member 'FBloodwebRarityPerRingDistribution::EpicMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, EpicMaxCount) == 0x000078, "Member 'FBloodwebRarityPerRingDistribution::EpicMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, EpicWeight) == 0x00007C, "Member 'FBloodwebRarityPerRingDistribution::EpicWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SuperEpicMinCount) == 0x000080, "Member 'FBloodwebRarityPerRingDistribution::SuperEpicMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SuperEpicMaxCount) == 0x000084, "Member 'FBloodwebRarityPerRingDistribution::SuperEpicMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SuperEpicWeight) == 0x000088, "Member 'FBloodwebRarityPerRingDistribution::SuperEpicWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraEpicMinCount) == 0x00008C, "Member 'FBloodwebRarityPerRingDistribution::UltraEpicMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraEpicMaxCount) == 0x000090, "Member 'FBloodwebRarityPerRingDistribution::UltraEpicMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraEpicWeight) == 0x000094, "Member 'FBloodwebRarityPerRingDistribution::UltraEpicWeight' has a wrong offset!");

// ScriptStruct DeadByDaylight.EACClientInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FEACClientInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEACClientInfo) == 0x000008, "Wrong alignment on FEACClientInfo");
static_assert(sizeof(FEACClientInfo) == 0x000028, "Wrong size on FEACClientInfo");

// ScriptStruct DeadByDaylight.DBDPerPlatformFloat
// 0x0004 (0x0004 - 0x0000)
struct FDBDPerPlatformFloat final
{
public:
	struct FPerPlatformFloat                      Value;                                             // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDPerPlatformFloat) == 0x000004, "Wrong alignment on FDBDPerPlatformFloat");
static_assert(sizeof(FDBDPerPlatformFloat) == 0x000004, "Wrong size on FDBDPerPlatformFloat");
static_assert(offsetof(FDBDPerPlatformFloat, Value) == 0x000000, "Member 'FDBDPerPlatformFloat::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDPerPlatformInt
// 0x0004 (0x0004 - 0x0000)
struct FDBDPerPlatformInt final
{
public:
	struct FPerPlatformInt                        Value;                                             // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDPerPlatformInt) == 0x000004, "Wrong alignment on FDBDPerPlatformInt");
static_assert(sizeof(FDBDPerPlatformInt) == 0x000004, "Wrong size on FDBDPerPlatformInt");
static_assert(offsetof(FDBDPerPlatformInt, Value) == 0x000000, "Member 'FDBDPerPlatformInt::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.BonusPointEventsItemData
// 0x00A0 (0x00A0 - 0x0000)
struct FBonusPointEventsItemData final
{
public:
	class FString                                 EventTitle;                                        // 0x0000(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EventDescription;                                  // 0x0010(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EventDescription_IsSet;                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        EventType;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        Multiplier;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 StartTime;                                         // 0x0030(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EndTime;                                           // 0x0040(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBonusPointEventsItemData) == 0x000008, "Wrong alignment on FBonusPointEventsItemData");
static_assert(sizeof(FBonusPointEventsItemData) == 0x0000A0, "Wrong size on FBonusPointEventsItemData");
static_assert(offsetof(FBonusPointEventsItemData, EventTitle) == 0x000000, "Member 'FBonusPointEventsItemData::EventTitle' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, EventDescription) == 0x000010, "Member 'FBonusPointEventsItemData::EventDescription' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, EventDescription_IsSet) == 0x000020, "Member 'FBonusPointEventsItemData::EventDescription_IsSet' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, EventType) == 0x000024, "Member 'FBonusPointEventsItemData::EventType' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, Multiplier) == 0x000028, "Member 'FBonusPointEventsItemData::Multiplier' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, StartTime) == 0x000030, "Member 'FBonusPointEventsItemData::StartTime' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, EndTime) == 0x000040, "Member 'FBonusPointEventsItemData::EndTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.BonusPointEventsData
// 0x0010 (0x0010 - 0x0000)
struct FBonusPointEventsData final
{
public:
	TArray<struct FBonusPointEventsItemData>      BonusPointEvents;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBonusPointEventsData) == 0x000008, "Wrong alignment on FBonusPointEventsData");
static_assert(sizeof(FBonusPointEventsData) == 0x000010, "Wrong size on FBonusPointEventsData");
static_assert(offsetof(FBonusPointEventsData, BonusPointEvents) == 0x000000, "Member 'FBonusPointEventsData::BonusPointEvents' has a wrong offset!");

// ScriptStruct DeadByDaylight.EmblemProgressionDescriptionByQuality
// 0x0020 (0x0020 - 0x0000)
struct FEmblemProgressionDescriptionByQuality final
{
public:
	EEmblemQuality                                EmblemQuality;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmblemProgressionDescriptionByQuality) == 0x000008, "Wrong alignment on FEmblemProgressionDescriptionByQuality");
static_assert(sizeof(FEmblemProgressionDescriptionByQuality) == 0x000020, "Wrong size on FEmblemProgressionDescriptionByQuality");
static_assert(offsetof(FEmblemProgressionDescriptionByQuality, EmblemQuality) == 0x000000, "Member 'FEmblemProgressionDescriptionByQuality::EmblemQuality' has a wrong offset!");
static_assert(offsetof(FEmblemProgressionDescriptionByQuality, Description) == 0x000008, "Member 'FEmblemProgressionDescriptionByQuality::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.BorderElements
// 0x0018 (0x0018 - 0x0000)
struct FBorderElements final
{
public:
	EDirection                                    Direction;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorSpawner*>                  Elements;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBorderElements) == 0x000008, "Wrong alignment on FBorderElements");
static_assert(sizeof(FBorderElements) == 0x000018, "Wrong size on FBorderElements");
static_assert(offsetof(FBorderElements, Direction) == 0x000000, "Member 'FBorderElements::Direction' has a wrong offset!");
static_assert(offsetof(FBorderElements, Elements) == 0x000008, "Member 'FBorderElements::Elements' has a wrong offset!");

// ScriptStruct DeadByDaylight.BotMatchConfig
// 0x0020 (0x0020 - 0x0000)
struct FBotMatchConfig final
{
public:
	TArray<class FString>                         DSPlatformSBM;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         DSPlatformTutorialBotMatch;                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotMatchConfig) == 0x000008, "Wrong alignment on FBotMatchConfig");
static_assert(sizeof(FBotMatchConfig) == 0x000020, "Wrong size on FBotMatchConfig");
static_assert(offsetof(FBotMatchConfig, DSPlatformSBM) == 0x000000, "Member 'FBotMatchConfig::DSPlatformSBM' has a wrong offset!");
static_assert(offsetof(FBotMatchConfig, DSPlatformTutorialBotMatch) == 0x000010, "Member 'FBotMatchConfig::DSPlatformTutorialBotMatch' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedPlayerLoadoutData
// 0x0098 (0x0098 - 0x0000)
struct FLegacySavedPlayerLoadoutData final
{
public:
	class FName                                   Item;                                              // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ItemAddOns;                                        // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           CamperPerks;                                       // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<int32>                                 CamperPerkLevels;                                  // 0x0030(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FName                                   CamperFavor;                                       // 0x0040(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Power;                                             // 0x004C(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PowerAddOns;                                       // 0x0058(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           SlasherPerks;                                      // 0x0068(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<int32>                                 SlasherPerkLevels;                                 // 0x0078(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FName                                   SlasherFavor;                                      // 0x0088(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacySavedPlayerLoadoutData) == 0x000008, "Wrong alignment on FLegacySavedPlayerLoadoutData");
static_assert(sizeof(FLegacySavedPlayerLoadoutData) == 0x000098, "Wrong size on FLegacySavedPlayerLoadoutData");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, Item) == 0x000000, "Member 'FLegacySavedPlayerLoadoutData::Item' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, ItemAddOns) == 0x000010, "Member 'FLegacySavedPlayerLoadoutData::ItemAddOns' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, CamperPerks) == 0x000020, "Member 'FLegacySavedPlayerLoadoutData::CamperPerks' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, CamperPerkLevels) == 0x000030, "Member 'FLegacySavedPlayerLoadoutData::CamperPerkLevels' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, CamperFavor) == 0x000040, "Member 'FLegacySavedPlayerLoadoutData::CamperFavor' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, Power) == 0x00004C, "Member 'FLegacySavedPlayerLoadoutData::Power' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, PowerAddOns) == 0x000058, "Member 'FLegacySavedPlayerLoadoutData::PowerAddOns' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, SlasherPerks) == 0x000068, "Member 'FLegacySavedPlayerLoadoutData::SlasherPerks' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, SlasherPerkLevels) == 0x000078, "Member 'FLegacySavedPlayerLoadoutData::SlasherPerkLevels' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, SlasherFavor) == 0x000088, "Member 'FLegacySavedPlayerLoadoutData::SlasherFavor' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodwebNodeProperties
// 0x0018 (0x0018 - 0x0000)
struct FLegacySavedBloodwebNodeProperties final
{
public:
	EBloodwebNodeContentType                      ContentType;                                       // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0001(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Tags;                                              // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodwebNodeProperties) == 0x000008, "Wrong alignment on FLegacySavedBloodwebNodeProperties");
static_assert(sizeof(FLegacySavedBloodwebNodeProperties) == 0x000018, "Wrong size on FLegacySavedBloodwebNodeProperties");
static_assert(offsetof(FLegacySavedBloodwebNodeProperties, ContentType) == 0x000000, "Member 'FLegacySavedBloodwebNodeProperties::ContentType' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeProperties, Rarity) == 0x000001, "Member 'FLegacySavedBloodwebNodeProperties::Rarity' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeProperties, Tags) == 0x000008, "Member 'FLegacySavedBloodwebNodeProperties::Tags' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodwebChest
// 0x0030 (0x0030 - 0x0000)
struct FLegacySavedBloodwebChest final
{
public:
	class FName                                   ID;                                                // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventID;                                           // 0x000C(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0018(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 GivenItemRarity;                                   // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodwebChest) == 0x000008, "Wrong alignment on FLegacySavedBloodwebChest");
static_assert(sizeof(FLegacySavedBloodwebChest) == 0x000030, "Wrong size on FLegacySavedBloodwebChest");
static_assert(offsetof(FLegacySavedBloodwebChest, ID) == 0x000000, "Member 'FLegacySavedBloodwebChest::ID' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebChest, EventID) == 0x00000C, "Member 'FLegacySavedBloodwebChest::EventID' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebChest, Rarity) == 0x000018, "Member 'FLegacySavedBloodwebChest::Rarity' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebChest, GivenItemRarity) == 0x000020, "Member 'FLegacySavedBloodwebChest::GivenItemRarity' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodwebNode
// 0x0080 (0x0080 - 0x0000)
struct FLegacySavedBloodwebNode final
{
public:
	struct FLegacySavedBloodwebNodeProperties     Properties;                                        // 0x0000(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FLegacySavedBloodwebNodeGate>   Gates;                                             // 0x0018(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	EBloodwebNodeState                            State;                                             // 0x0028(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NodeID;                                            // 0x0030(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContentId;                                         // 0x0040(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacySavedBloodwebChest              BloodwebChest;                                     // 0x0050(0x0030)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodwebNode) == 0x000008, "Wrong alignment on FLegacySavedBloodwebNode");
static_assert(sizeof(FLegacySavedBloodwebNode) == 0x000080, "Wrong size on FLegacySavedBloodwebNode");
static_assert(offsetof(FLegacySavedBloodwebNode, Properties) == 0x000000, "Member 'FLegacySavedBloodwebNode::Properties' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNode, Gates) == 0x000018, "Member 'FLegacySavedBloodwebNode::Gates' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNode, State) == 0x000028, "Member 'FLegacySavedBloodwebNode::State' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNode, NodeID) == 0x000030, "Member 'FLegacySavedBloodwebNode::NodeID' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNode, ContentId) == 0x000040, "Member 'FLegacySavedBloodwebNode::ContentId' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNode, BloodwebChest) == 0x000050, "Member 'FLegacySavedBloodwebNode::BloodwebChest' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodWebRingPersistentData
// 0x0010 (0x0010 - 0x0000)
struct FLegacySavedBloodWebRingPersistentData final
{
public:
	TArray<struct FLegacySavedBloodwebNode>       NodeData;                                          // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodWebRingPersistentData) == 0x000008, "Wrong alignment on FLegacySavedBloodWebRingPersistentData");
static_assert(sizeof(FLegacySavedBloodWebRingPersistentData) == 0x000010, "Wrong size on FLegacySavedBloodWebRingPersistentData");
static_assert(offsetof(FLegacySavedBloodWebRingPersistentData, NodeData) == 0x000000, "Member 'FLegacySavedBloodWebRingPersistentData::NodeData' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodWebPersistentData
// 0x0040 (0x0040 - 0x0000)
struct FLegacySavedBloodWebPersistentData final
{
public:
	int32                                         VersionNumber;                                     // 0x0000(0x0004)(ZeroConstructor, SaveGame, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLegacySavedBloodWebRingPersistentData> RingData;                                  // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           Paths;                                             // 0x0018(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FString                                 EntityCurrentNode;                                 // 0x0028(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              GenerationDate;                                    // 0x0038(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodWebPersistentData) == 0x000008, "Wrong alignment on FLegacySavedBloodWebPersistentData");
static_assert(sizeof(FLegacySavedBloodWebPersistentData) == 0x000040, "Wrong size on FLegacySavedBloodWebPersistentData");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, VersionNumber) == 0x000000, "Member 'FLegacySavedBloodWebPersistentData::VersionNumber' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, Level) == 0x000004, "Member 'FLegacySavedBloodWebPersistentData::Level' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, RingData) == 0x000008, "Member 'FLegacySavedBloodWebPersistentData::RingData' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, Paths) == 0x000018, "Member 'FLegacySavedBloodWebPersistentData::Paths' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, EntityCurrentNode) == 0x000028, "Member 'FLegacySavedBloodWebPersistentData::EntityCurrentNode' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, GenerationDate) == 0x000038, "Member 'FLegacySavedBloodWebPersistentData::GenerationDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacyCharacterSavedInventoryData
// 0x0018 (0x0018 - 0x0000)
struct FLegacyCharacterSavedInventoryData final
{
public:
	uint32                                        Version;                                           // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TimeObtainedSinceEpoch;                            // 0x0010(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyCharacterSavedInventoryData) == 0x000008, "Wrong alignment on FLegacyCharacterSavedInventoryData");
static_assert(sizeof(FLegacyCharacterSavedInventoryData) == 0x000018, "Wrong size on FLegacyCharacterSavedInventoryData");
static_assert(offsetof(FLegacyCharacterSavedInventoryData, Version) == 0x000000, "Member 'FLegacyCharacterSavedInventoryData::Version' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedInventoryData, Name) == 0x000004, "Member 'FLegacyCharacterSavedInventoryData::Name' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedInventoryData, TimeObtainedSinceEpoch) == 0x000010, "Member 'FLegacyCharacterSavedInventoryData::TimeObtainedSinceEpoch' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacyCharacterSavedProfileData
// 0x0130 (0x0130 - 0x0000)
struct FLegacyCharacterSavedProfileData final
{
public:
	int32                                         VersionNumber;                                     // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodPoints;                                       // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodWebLevel;                                     // 0x0008(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeLevel;                                     // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesConfronted;                                   // 0x0010(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDateTime>                      PrestigeDates;                                     // 0x0018(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodWebData;                                      // 0x0028(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedPlayerLoadoutData          CharacterLoadoutData;                              // 0x0068(0x0098)(SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           Inventory;                                         // 0x0100(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FLegacyCharacterSavedInventoryData> InventoryData;                                 // 0x0110(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           CurrentCustomization;                              // 0x0120(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyCharacterSavedProfileData) == 0x000008, "Wrong alignment on FLegacyCharacterSavedProfileData");
static_assert(sizeof(FLegacyCharacterSavedProfileData) == 0x000130, "Wrong size on FLegacyCharacterSavedProfileData");
static_assert(offsetof(FLegacyCharacterSavedProfileData, VersionNumber) == 0x000000, "Member 'FLegacyCharacterSavedProfileData::VersionNumber' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, BloodPoints) == 0x000004, "Member 'FLegacyCharacterSavedProfileData::BloodPoints' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, BloodWebLevel) == 0x000008, "Member 'FLegacyCharacterSavedProfileData::BloodWebLevel' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, PrestigeLevel) == 0x00000C, "Member 'FLegacyCharacterSavedProfileData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, TimesConfronted) == 0x000010, "Member 'FLegacyCharacterSavedProfileData::TimesConfronted' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, PrestigeDates) == 0x000018, "Member 'FLegacyCharacterSavedProfileData::PrestigeDates' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, BloodWebData) == 0x000028, "Member 'FLegacyCharacterSavedProfileData::BloodWebData' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, CharacterLoadoutData) == 0x000068, "Member 'FLegacyCharacterSavedProfileData::CharacterLoadoutData' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, Inventory) == 0x000100, "Member 'FLegacyCharacterSavedProfileData::Inventory' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, InventoryData) == 0x000110, "Member 'FLegacyCharacterSavedProfileData::InventoryData' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, CurrentCustomization) == 0x000120, "Member 'FLegacyCharacterSavedProfileData::CurrentCustomization' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedDailyRitualInstance
// 0x0078 (0x0078 - 0x0000)
struct FLegacySavedDailyRitualInstance final
{
public:
	class FName                                   RitualKey;                                         // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 CharacterIDs;                                      // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           Roles;                                             // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threshold;                                         // 0x0034(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0038(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayThreshold;                                  // 0x003C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpReward;                                         // 0x0040(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Active;                                            // 0x0044(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Rewarded;                                          // 0x0045(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StateChanged;                                      // 0x0046(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DateAssigned;                                      // 0x0048(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbGameElapsed;                                     // 0x0050(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EDBDScoreTypes>                        TrackedEvents;                                     // 0x0058(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   TrackedGameEvents;                                 // 0x0068(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLegacySavedDailyRitualInstance) == 0x000008, "Wrong alignment on FLegacySavedDailyRitualInstance");
static_assert(sizeof(FLegacySavedDailyRitualInstance) == 0x000078, "Wrong size on FLegacySavedDailyRitualInstance");
static_assert(offsetof(FLegacySavedDailyRitualInstance, RitualKey) == 0x000000, "Member 'FLegacySavedDailyRitualInstance::RitualKey' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, CharacterIDs) == 0x000010, "Member 'FLegacySavedDailyRitualInstance::CharacterIDs' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Roles) == 0x000020, "Member 'FLegacySavedDailyRitualInstance::Roles' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Progress) == 0x000030, "Member 'FLegacySavedDailyRitualInstance::Progress' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Threshold) == 0x000034, "Member 'FLegacySavedDailyRitualInstance::Threshold' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Tolerance) == 0x000038, "Member 'FLegacySavedDailyRitualInstance::Tolerance' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, DisplayThreshold) == 0x00003C, "Member 'FLegacySavedDailyRitualInstance::DisplayThreshold' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, ExpReward) == 0x000040, "Member 'FLegacySavedDailyRitualInstance::ExpReward' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Active) == 0x000044, "Member 'FLegacySavedDailyRitualInstance::Active' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Rewarded) == 0x000045, "Member 'FLegacySavedDailyRitualInstance::Rewarded' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, StateChanged) == 0x000046, "Member 'FLegacySavedDailyRitualInstance::StateChanged' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, DateAssigned) == 0x000048, "Member 'FLegacySavedDailyRitualInstance::DateAssigned' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, NbGameElapsed) == 0x000050, "Member 'FLegacySavedDailyRitualInstance::NbGameElapsed' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, TrackedEvents) == 0x000058, "Member 'FLegacySavedDailyRitualInstance::TrackedEvents' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, TrackedGameEvents) == 0x000068, "Member 'FLegacySavedDailyRitualInstance::TrackedGameEvents' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedDailyRitualContainer
// 0x0018 (0x0018 - 0x0000)
struct FLegacySavedDailyRitualContainer final
{
public:
	struct FDateTime                              LastRitualReceivedDate;                            // 0x0000(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLegacySavedDailyRitualInstance> Rituals;                                          // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedDailyRitualContainer) == 0x000008, "Wrong alignment on FLegacySavedDailyRitualContainer");
static_assert(sizeof(FLegacySavedDailyRitualContainer) == 0x000018, "Wrong size on FLegacySavedDailyRitualContainer");
static_assert(offsetof(FLegacySavedDailyRitualContainer, LastRitualReceivedDate) == 0x000000, "Member 'FLegacySavedDailyRitualContainer::LastRitualReceivedDate' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualContainer, Rituals) == 0x000008, "Member 'FLegacySavedDailyRitualContainer::Rituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacyPlayerSavedProfileDataLocal
// 0x0180 (0x0180 - 0x0000)
struct FLegacyPlayerSavedProfileDataLocal final
{
public:
	int32                                         Tokens;                                            // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Offerings;                                         // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          FirstTimePlaying;                                  // 0x0018(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenKillerTutorialEndReward;               // 0x0019(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenSurvivorTutorialEndReward;             // 0x001A(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Wins;                                              // 0x001C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Losses;                                            // 0x0020(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FLegacyCharacterSavedProfileData> CharacterData;                              // 0x0028(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	uint64                                        CurrentSeasonTicks;                                // 0x0078(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLegacySavedDailyRitualContainer       DailyRituals;                                      // 0x0080(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedFearMarketOfferingInstance FearMarket;                                        // 0x0098(0x0020)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedPlayerLoadoutData          LastConnectedLoadout;                              // 0x00B8(0x0098)(SaveGame, NativeAccessSpecifierPublic)
	int32                                         LastConnectedCharacterIndex;                       // 0x0150(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DisconnectPenaltyTime;                             // 0x0158(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _bloodpoints;                                      // 0x0160(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _bonusBloodpoints;                                 // 0x0164(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _unclampedBloodpoints;                             // 0x0168(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _fearTokens;                                       // 0x016C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              _ongoingGameTime;                                  // 0x0170(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _fearTokensMigrated;                               // 0x0178(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyPlayerSavedProfileDataLocal) == 0x000008, "Wrong alignment on FLegacyPlayerSavedProfileDataLocal");
static_assert(sizeof(FLegacyPlayerSavedProfileDataLocal) == 0x000180, "Wrong size on FLegacyPlayerSavedProfileDataLocal");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, Tokens) == 0x000000, "Member 'FLegacyPlayerSavedProfileDataLocal::Tokens' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, Offerings) == 0x000008, "Member 'FLegacyPlayerSavedProfileDataLocal::Offerings' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, FirstTimePlaying) == 0x000018, "Member 'FLegacyPlayerSavedProfileDataLocal::FirstTimePlaying' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, HasBeenGivenKillerTutorialEndReward) == 0x000019, "Member 'FLegacyPlayerSavedProfileDataLocal::HasBeenGivenKillerTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, HasBeenGivenSurvivorTutorialEndReward) == 0x00001A, "Member 'FLegacyPlayerSavedProfileDataLocal::HasBeenGivenSurvivorTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, Wins) == 0x00001C, "Member 'FLegacyPlayerSavedProfileDataLocal::Wins' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, Losses) == 0x000020, "Member 'FLegacyPlayerSavedProfileDataLocal::Losses' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, CharacterData) == 0x000028, "Member 'FLegacyPlayerSavedProfileDataLocal::CharacterData' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, CurrentSeasonTicks) == 0x000078, "Member 'FLegacyPlayerSavedProfileDataLocal::CurrentSeasonTicks' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, DailyRituals) == 0x000080, "Member 'FLegacyPlayerSavedProfileDataLocal::DailyRituals' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, FearMarket) == 0x000098, "Member 'FLegacyPlayerSavedProfileDataLocal::FearMarket' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, LastConnectedLoadout) == 0x0000B8, "Member 'FLegacyPlayerSavedProfileDataLocal::LastConnectedLoadout' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, LastConnectedCharacterIndex) == 0x000150, "Member 'FLegacyPlayerSavedProfileDataLocal::LastConnectedCharacterIndex' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, DisconnectPenaltyTime) == 0x000158, "Member 'FLegacyPlayerSavedProfileDataLocal::DisconnectPenaltyTime' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _bloodpoints) == 0x000160, "Member 'FLegacyPlayerSavedProfileDataLocal::_bloodpoints' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _bonusBloodpoints) == 0x000164, "Member 'FLegacyPlayerSavedProfileDataLocal::_bonusBloodpoints' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _unclampedBloodpoints) == 0x000168, "Member 'FLegacyPlayerSavedProfileDataLocal::_unclampedBloodpoints' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _fearTokens) == 0x00016C, "Member 'FLegacyPlayerSavedProfileDataLocal::_fearTokens' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _ongoingGameTime) == 0x000170, "Member 'FLegacyPlayerSavedProfileDataLocal::_ongoingGameTime' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _fearTokensMigrated) == 0x000178, "Member 'FLegacyPlayerSavedProfileDataLocal::_fearTokensMigrated' has a wrong offset!");

// ScriptStruct DeadByDaylight.BundleData
// 0x00D0 (0x00D0 - 0x0000)
struct FBundleData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemUIData                            UIData;                                            // 0x0010(0x00C0)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBundleData) == 0x000008, "Wrong alignment on FBundleData");
static_assert(sizeof(FBundleData) == 0x0000D0, "Wrong size on FBundleData");
static_assert(offsetof(FBundleData, ID) == 0x000000, "Member 'FBundleData::ID' has a wrong offset!");
static_assert(offsetof(FBundleData, UIData) == 0x000010, "Member 'FBundleData::UIData' has a wrong offset!");

// ScriptStruct DeadByDaylight.CameraAttachment
// 0x0018 (0x0018 - 0x0000)
struct FCameraAttachment final
{
public:
	class USceneComponent*                        Parent;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraAttachment) == 0x000008, "Wrong alignment on FCameraAttachment");
static_assert(sizeof(FCameraAttachment) == 0x000018, "Wrong size on FCameraAttachment");
static_assert(offsetof(FCameraAttachment, Parent) == 0x000000, "Member 'FCameraAttachment::Parent' has a wrong offset!");

// ScriptStruct DeadByDaylight.SharedAuthenticationTokenInformation
// 0x0030 (0x0030 - 0x0000)
struct FSharedAuthenticationTokenInformation final
{
public:
	class FString                                 LoginProvider;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuthToken;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TokenType;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSharedAuthenticationTokenInformation) == 0x000008, "Wrong alignment on FSharedAuthenticationTokenInformation");
static_assert(sizeof(FSharedAuthenticationTokenInformation) == 0x000030, "Wrong size on FSharedAuthenticationTokenInformation");
static_assert(offsetof(FSharedAuthenticationTokenInformation, LoginProvider) == 0x000000, "Member 'FSharedAuthenticationTokenInformation::LoginProvider' has a wrong offset!");
static_assert(offsetof(FSharedAuthenticationTokenInformation, AuthToken) == 0x000010, "Member 'FSharedAuthenticationTokenInformation::AuthToken' has a wrong offset!");
static_assert(offsetof(FSharedAuthenticationTokenInformation, TokenType) == 0x000020, "Member 'FSharedAuthenticationTokenInformation::TokenType' has a wrong offset!");

// ScriptStruct DeadByDaylight.CamperDamageResult
// 0x0060 (0x0060 - 0x0000)
struct FCamperDamageResult final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamageSource;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             DamagePlayerOwner;                                 // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayModifierContainer*             KOPreventedSource;                                 // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCamperDamageResult) == 0x000008, "Wrong alignment on FCamperDamageResult");
static_assert(sizeof(FCamperDamageResult) == 0x000060, "Wrong size on FCamperDamageResult");
static_assert(offsetof(FCamperDamageResult, DamageSource) == 0x000010, "Member 'FCamperDamageResult::DamageSource' has a wrong offset!");
static_assert(offsetof(FCamperDamageResult, DamagePlayerOwner) == 0x000018, "Member 'FCamperDamageResult::DamagePlayerOwner' has a wrong offset!");
static_assert(offsetof(FCamperDamageResult, KOPreventedSource) == 0x000028, "Member 'FCamperDamageResult::KOPreventedSource' has a wrong offset!");

// ScriptStruct DeadByDaylight.ManagedMaterialGroup
// 0x0030 (0x0030 - 0x0000)
struct FManagedMaterialGroup final
{
public:
	class UObject*                                Source;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Group;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             Condition;                                         // 0x0018(0x0014)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManagedMaterialGroup) == 0x000008, "Wrong alignment on FManagedMaterialGroup");
static_assert(sizeof(FManagedMaterialGroup) == 0x000030, "Wrong size on FManagedMaterialGroup");
static_assert(offsetof(FManagedMaterialGroup, Source) == 0x000000, "Member 'FManagedMaterialGroup::Source' has a wrong offset!");
static_assert(offsetof(FManagedMaterialGroup, Group) == 0x000008, "Member 'FManagedMaterialGroup::Group' has a wrong offset!");
static_assert(offsetof(FManagedMaterialGroup, Condition) == 0x000018, "Member 'FManagedMaterialGroup::Condition' has a wrong offset!");

// ScriptStruct DeadByDaylight.EmblemProgressionID
// 0x0030 (0x0030 - 0x0000)
struct FEmblemProgressionID final
{
public:
	EEmblemProgressionType                        EmblemProgressionType;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DefaultDescription;                                // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FEmblemProgressionDescriptionByQuality> DescriptionsByQuality;                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmblemProgressionID) == 0x000008, "Wrong alignment on FEmblemProgressionID");
static_assert(sizeof(FEmblemProgressionID) == 0x000030, "Wrong size on FEmblemProgressionID");
static_assert(offsetof(FEmblemProgressionID, EmblemProgressionType) == 0x000000, "Member 'FEmblemProgressionID::EmblemProgressionType' has a wrong offset!");
static_assert(offsetof(FEmblemProgressionID, DefaultDescription) == 0x000008, "Member 'FEmblemProgressionID::DefaultDescription' has a wrong offset!");
static_assert(offsetof(FEmblemProgressionID, DescriptionsByQuality) == 0x000020, "Member 'FEmblemProgressionID::DescriptionsByQuality' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDEmblemDefinition
// 0x00A8 (0x00B0 - 0x0008)
struct FDBDEmblemDefinition final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           Roles;                                             // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CustomEmblem;                                      // 0x0058(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         IconFilePaths;                                     // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EEmblemEvaluation                             EmblemEvaluation;                                  // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEmblemProgressionID>           EmblemProgressionData;                             // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDEmblemDefinition) == 0x000008, "Wrong alignment on FDBDEmblemDefinition");
static_assert(sizeof(FDBDEmblemDefinition) == 0x0000B0, "Wrong size on FDBDEmblemDefinition");
static_assert(offsetof(FDBDEmblemDefinition, ID) == 0x000008, "Member 'FDBDEmblemDefinition::ID' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, Name) == 0x000018, "Member 'FDBDEmblemDefinition::Name' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, Description) == 0x000030, "Member 'FDBDEmblemDefinition::Description' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, Roles) == 0x000048, "Member 'FDBDEmblemDefinition::Roles' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, CustomEmblem) == 0x000058, "Member 'FDBDEmblemDefinition::CustomEmblem' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, IconFilePaths) == 0x000088, "Member 'FDBDEmblemDefinition::IconFilePaths' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, EmblemEvaluation) == 0x000098, "Member 'FDBDEmblemDefinition::EmblemEvaluation' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, Enabled) == 0x000099, "Member 'FDBDEmblemDefinition::Enabled' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, EmblemProgressionData) == 0x0000A0, "Member 'FDBDEmblemDefinition::EmblemProgressionData' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterAnimationDropdown
// 0x0014 (0x0020 - 0x000C)
struct FCharacterAnimationDropdown final : public FRoleItemCategoryDropdown
{
public:
	bool                                          IncludeAllAnimations;                              // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAnimBP;                                          // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimAsset;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnimationDropdown) == 0x000008, "Wrong alignment on FCharacterAnimationDropdown");
static_assert(sizeof(FCharacterAnimationDropdown) == 0x000020, "Wrong size on FCharacterAnimationDropdown");
static_assert(offsetof(FCharacterAnimationDropdown, IncludeAllAnimations) == 0x00000C, "Member 'FCharacterAnimationDropdown::IncludeAllAnimations' has a wrong offset!");
static_assert(offsetof(FCharacterAnimationDropdown, IsAnimBP) == 0x00000D, "Member 'FCharacterAnimationDropdown::IsAnimBP' has a wrong offset!");
static_assert(offsetof(FCharacterAnimationDropdown, AnimAsset) == 0x000010, "Member 'FCharacterAnimationDropdown::AnimAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.StreamVideoUIData
// 0x00E0 (0x00E0 - 0x0000)
struct alignas(0x10) FStreamVideoUIData final
{
public:
	class FString                                 VideoURL;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Language;                                          // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAudio;                                          // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xB];                                       // 0x0021(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZOrderWidget;                                      // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   StreamVideoWidgetAsset;                            // 0x0030(0x0030)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMediaPlayer>            MediaPlayerAsset;                                  // 0x0060(0x0030)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x50];                                      // 0x0090(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStreamVideoUIData) == 0x000010, "Wrong alignment on FStreamVideoUIData");
static_assert(sizeof(FStreamVideoUIData) == 0x0000E0, "Wrong size on FStreamVideoUIData");
static_assert(offsetof(FStreamVideoUIData, VideoURL) == 0x000000, "Member 'FStreamVideoUIData::VideoURL' has a wrong offset!");
static_assert(offsetof(FStreamVideoUIData, Language) == 0x000010, "Member 'FStreamVideoUIData::Language' has a wrong offset!");
static_assert(offsetof(FStreamVideoUIData, HasAudio) == 0x000020, "Member 'FStreamVideoUIData::HasAudio' has a wrong offset!");
static_assert(offsetof(FStreamVideoUIData, ZOrderWidget) == 0x00002C, "Member 'FStreamVideoUIData::ZOrderWidget' has a wrong offset!");
static_assert(offsetof(FStreamVideoUIData, StreamVideoWidgetAsset) == 0x000030, "Member 'FStreamVideoUIData::StreamVideoWidgetAsset' has a wrong offset!");
static_assert(offsetof(FStreamVideoUIData, MediaPlayerAsset) == 0x000060, "Member 'FStreamVideoUIData::MediaPlayerAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterCustomizationDataTable
// 0x0038 (0x0040 - 0x0008)
struct FCharacterCustomizationDataTable final : public FDBDTableRowBase
{
public:
	int32                                         CharacterIndex;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              CustomizationStoreDB;                              // 0x0010(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCustomizationDataTable) == 0x000008, "Wrong alignment on FCharacterCustomizationDataTable");
static_assert(sizeof(FCharacterCustomizationDataTable) == 0x000040, "Wrong size on FCharacterCustomizationDataTable");
static_assert(offsetof(FCharacterCustomizationDataTable, CharacterIndex) == 0x000008, "Member 'FCharacterCustomizationDataTable::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDataTable, CustomizationStoreDB) == 0x000010, "Member 'FCharacterCustomizationDataTable::CustomizationStoreDB' has a wrong offset!");

// ScriptStruct DeadByDaylight.PromoPackContentTypeData
// 0x0060 (0x0060 - 0x0000)
struct FPromoPackContentTypeData final
{
public:
	TSoftClassPtr<class UClass>                   CorrespondingWidget;                               // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ContentTypeIcon;                                   // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPromoPackContentTypeData) == 0x000008, "Wrong alignment on FPromoPackContentTypeData");
static_assert(sizeof(FPromoPackContentTypeData) == 0x000060, "Wrong size on FPromoPackContentTypeData");
static_assert(offsetof(FPromoPackContentTypeData, CorrespondingWidget) == 0x000000, "Member 'FPromoPackContentTypeData::CorrespondingWidget' has a wrong offset!");
static_assert(offsetof(FPromoPackContentTypeData, ContentTypeIcon) == 0x000030, "Member 'FPromoPackContentTypeData::ContentTypeIcon' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterCustomizationPresetsList
// 0x0018 (0x0018 - 0x0000)
struct FCharacterCustomizationPresetsList final
{
public:
	int32                                         CharacterId;                                       // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivePreset;                                      // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterCustomizationPreset>  Presets;                                           // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCustomizationPresetsList) == 0x000008, "Wrong alignment on FCharacterCustomizationPresetsList");
static_assert(sizeof(FCharacterCustomizationPresetsList) == 0x000018, "Wrong size on FCharacterCustomizationPresetsList");
static_assert(offsetof(FCharacterCustomizationPresetsList, CharacterId) == 0x000000, "Member 'FCharacterCustomizationPresetsList::CharacterId' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationPresetsList, ActivePreset) == 0x000004, "Member 'FCharacterCustomizationPresetsList::ActivePreset' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationPresetsList, Presets) == 0x000008, "Member 'FCharacterCustomizationPresetsList::Presets' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventObjectiveData
// 0x00E0 (0x00E0 - 0x0000)
struct FSpecialEventObjectiveData final
{
public:
	class FName                                   ObjectiveId;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectiveFrameLabel;                               // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CompletedTitle;                                    // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CompletedDescription;                              // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   RewardId;                                          // 0x0090(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LockedRewardGenericIconPath;                       // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UnlockedRewardGenericIconPath;                     // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StatName;                                          // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Sections;                                          // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxValue;                                          // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventObjectiveData) == 0x000008, "Wrong alignment on FSpecialEventObjectiveData");
static_assert(sizeof(FSpecialEventObjectiveData) == 0x0000E0, "Wrong size on FSpecialEventObjectiveData");
static_assert(offsetof(FSpecialEventObjectiveData, ObjectiveId) == 0x000000, "Member 'FSpecialEventObjectiveData::ObjectiveId' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, Title) == 0x000010, "Member 'FSpecialEventObjectiveData::Title' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, Description) == 0x000028, "Member 'FSpecialEventObjectiveData::Description' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, IconPath) == 0x000040, "Member 'FSpecialEventObjectiveData::IconPath' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, ObjectiveFrameLabel) == 0x000050, "Member 'FSpecialEventObjectiveData::ObjectiveFrameLabel' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, CompletedTitle) == 0x000060, "Member 'FSpecialEventObjectiveData::CompletedTitle' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, CompletedDescription) == 0x000078, "Member 'FSpecialEventObjectiveData::CompletedDescription' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, RewardId) == 0x000090, "Member 'FSpecialEventObjectiveData::RewardId' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, LockedRewardGenericIconPath) == 0x0000A0, "Member 'FSpecialEventObjectiveData::LockedRewardGenericIconPath' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, UnlockedRewardGenericIconPath) == 0x0000B0, "Member 'FSpecialEventObjectiveData::UnlockedRewardGenericIconPath' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, PlayerRole) == 0x0000C0, "Member 'FSpecialEventObjectiveData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, StatName) == 0x0000C8, "Member 'FSpecialEventObjectiveData::StatName' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, Sections) == 0x0000D8, "Member 'FSpecialEventObjectiveData::Sections' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, MaxValue) == 0x0000DC, "Member 'FSpecialEventObjectiveData::MaxValue' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterDescription
// 0x0228 (0x0230 - 0x0008)
struct FCharacterDescription final : public FDBDTableRowBase
{
public:
	int32                                         CharacterIndex;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterDifficulty                          Difficulty;                                        // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   BackStory;                                         // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Biography;                                         // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   IconFilePath;                                      // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HudIcon;                                           // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackgroundImagePath;                               // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomizedMeshPart>            CustomizationDescription;                          // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ChapterDlcId;                                      // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AdditionalDlcIds;                                  // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          AvailableIfDlcInstalled;                           // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DebugName;                                         // 0x00B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInChunk0;                                        // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableInNonViolentBuild;                      // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableInAtlantaBuild;                         // 0x00C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3[0x1];                                       // 0x00C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PlatformExclusiveFlag;                             // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GamePawn;                                          // 0x00C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MenuPawn;                                          // 0x00F8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultItem;                                       // 0x0128(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGender                                       Gender;                                            // 0x0134(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EKillerAbilities>                      KillerAbilities;                                   // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataTableProxy                        TunableDB;                                         // 0x0148(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EKillerHeight                                 KillerHeight;                                      // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlideShowDescription                  SlideShowDescriptions;                             // 0x0190(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          HideStoreCustomizations;                           // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CustomizationCategories;                           // 0x0200(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	class FString                                 CharacterId;                                       // 0x0210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterDescription) == 0x000008, "Wrong alignment on FCharacterDescription");
static_assert(sizeof(FCharacterDescription) == 0x000230, "Wrong size on FCharacterDescription");
static_assert(offsetof(FCharacterDescription, CharacterIndex) == 0x000008, "Member 'FCharacterDescription::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, Role) == 0x00000C, "Member 'FCharacterDescription::Role' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, Difficulty) == 0x00000D, "Member 'FCharacterDescription::Difficulty' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, DisplayName) == 0x000010, "Member 'FCharacterDescription::DisplayName' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, BackStory) == 0x000028, "Member 'FCharacterDescription::BackStory' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, Biography) == 0x000040, "Member 'FCharacterDescription::Biography' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, IconFilePath) == 0x000058, "Member 'FCharacterDescription::IconFilePath' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, HudIcon) == 0x000068, "Member 'FCharacterDescription::HudIcon' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, BackgroundImagePath) == 0x000070, "Member 'FCharacterDescription::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, CustomizationDescription) == 0x000080, "Member 'FCharacterDescription::CustomizationDescription' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, ChapterDlcId) == 0x000090, "Member 'FCharacterDescription::ChapterDlcId' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, AdditionalDlcIds) == 0x0000A0, "Member 'FCharacterDescription::AdditionalDlcIds' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, AvailableIfDlcInstalled) == 0x0000B0, "Member 'FCharacterDescription::AvailableIfDlcInstalled' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, DebugName) == 0x0000B4, "Member 'FCharacterDescription::DebugName' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, IsInChunk0) == 0x0000C0, "Member 'FCharacterDescription::IsInChunk0' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, IsAvailableInNonViolentBuild) == 0x0000C1, "Member 'FCharacterDescription::IsAvailableInNonViolentBuild' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, IsAvailableInAtlantaBuild) == 0x0000C2, "Member 'FCharacterDescription::IsAvailableInAtlantaBuild' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, PlatformExclusiveFlag) == 0x0000C4, "Member 'FCharacterDescription::PlatformExclusiveFlag' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, GamePawn) == 0x0000C8, "Member 'FCharacterDescription::GamePawn' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, MenuPawn) == 0x0000F8, "Member 'FCharacterDescription::MenuPawn' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, DefaultItem) == 0x000128, "Member 'FCharacterDescription::DefaultItem' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, Gender) == 0x000134, "Member 'FCharacterDescription::Gender' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, KillerAbilities) == 0x000138, "Member 'FCharacterDescription::KillerAbilities' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, TunableDB) == 0x000148, "Member 'FCharacterDescription::TunableDB' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, KillerHeight) == 0x000188, "Member 'FCharacterDescription::KillerHeight' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, SlideShowDescriptions) == 0x000190, "Member 'FCharacterDescription::SlideShowDescriptions' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, HideStoreCustomizations) == 0x0001F8, "Member 'FCharacterDescription::HideStoreCustomizations' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, CustomizationCategories) == 0x000200, "Member 'FCharacterDescription::CustomizationCategories' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, CharacterId) == 0x000210, "Member 'FCharacterDescription::CharacterId' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorHookTimer
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FSurvivorHookTimer final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSurvivorHookTimer) == 0x000008, "Wrong alignment on FSurvivorHookTimer");
static_assert(sizeof(FSurvivorHookTimer) == 0x000038, "Wrong size on FSurvivorHookTimer");

// ScriptStruct DeadByDaylight.CharacterDescriptionOverride
// 0x00C8 (0x00D0 - 0x0008)
struct FCharacterDescriptionOverride final : public FDBDTableRowBase
{
public:
	TArray<class FName>                           RequiredItemIds;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   DisplayNameOverride;                               // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              HudIconOverride;                                   // 0x0030(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MenuBlueprint;                                     // 0x0060(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GameBlueprint;                                     // 0x0090(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconFilePathOverride;                              // 0x00C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterDescriptionOverride) == 0x000008, "Wrong alignment on FCharacterDescriptionOverride");
static_assert(sizeof(FCharacterDescriptionOverride) == 0x0000D0, "Wrong size on FCharacterDescriptionOverride");
static_assert(offsetof(FCharacterDescriptionOverride, RequiredItemIds) == 0x000008, "Member 'FCharacterDescriptionOverride::RequiredItemIds' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, DisplayNameOverride) == 0x000018, "Member 'FCharacterDescriptionOverride::DisplayNameOverride' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, HudIconOverride) == 0x000030, "Member 'FCharacterDescriptionOverride::HudIconOverride' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, MenuBlueprint) == 0x000060, "Member 'FCharacterDescriptionOverride::MenuBlueprint' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, GameBlueprint) == 0x000090, "Member 'FCharacterDescriptionOverride::GameBlueprint' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, IconFilePathOverride) == 0x0000C0, "Member 'FCharacterDescriptionOverride::IconFilePathOverride' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerAttributesData
// 0x000C (0x000C - 0x0000)
struct FKillerAttributesData final
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TerrorRadius;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKillerHeight                                 Height;                                            // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillerAttributesData) == 0x000004, "Wrong alignment on FKillerAttributesData");
static_assert(sizeof(FKillerAttributesData) == 0x00000C, "Wrong size on FKillerAttributesData");
static_assert(offsetof(FKillerAttributesData, Speed) == 0x000000, "Member 'FKillerAttributesData::Speed' has a wrong offset!");
static_assert(offsetof(FKillerAttributesData, TerrorRadius) == 0x000004, "Member 'FKillerAttributesData::TerrorRadius' has a wrong offset!");
static_assert(offsetof(FKillerAttributesData, Height) == 0x000008, "Member 'FKillerAttributesData::Height' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterInfoData
// 0x02D8 (0x02D8 - 0x0000)
struct FCharacterInfoData final
{
public:
	struct FCharacterSlotData                     SlotData;                                          // 0x0000(0x0180)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTeachableData>                 TeachablePerksData;                                // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FInventorySlotData                     PowerData;                                         // 0x01A0(0x0128)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FKillerAttributesData                  killerAttributesData;                              // 0x02C8(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsKiller;                                          // 0x02D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x02D5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D6[0x2];                                      // 0x02D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterInfoData) == 0x000008, "Wrong alignment on FCharacterInfoData");
static_assert(sizeof(FCharacterInfoData) == 0x0002D8, "Wrong size on FCharacterInfoData");
static_assert(offsetof(FCharacterInfoData, SlotData) == 0x000000, "Member 'FCharacterInfoData::SlotData' has a wrong offset!");
static_assert(offsetof(FCharacterInfoData, Description) == 0x000180, "Member 'FCharacterInfoData::Description' has a wrong offset!");
static_assert(offsetof(FCharacterInfoData, TeachablePerksData) == 0x000190, "Member 'FCharacterInfoData::TeachablePerksData' has a wrong offset!");
static_assert(offsetof(FCharacterInfoData, PowerData) == 0x0001A0, "Member 'FCharacterInfoData::PowerData' has a wrong offset!");
static_assert(offsetof(FCharacterInfoData, killerAttributesData) == 0x0002C8, "Member 'FCharacterInfoData::killerAttributesData' has a wrong offset!");
static_assert(offsetof(FCharacterInfoData, IsKiller) == 0x0002D4, "Member 'FCharacterInfoData::IsKiller' has a wrong offset!");
static_assert(offsetof(FCharacterInfoData, IsEnabled) == 0x0002D5, "Member 'FCharacterInfoData::IsEnabled' has a wrong offset!");

// ScriptStruct DeadByDaylight.VaultData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FVaultData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVaultData) == 0x000008, "Wrong alignment on FVaultData");
static_assert(sizeof(FVaultData) == 0x000038, "Wrong size on FVaultData");

// ScriptStruct DeadByDaylight.CharacterLoadoutPresetsList
// 0x0018 (0x0018 - 0x0000)
struct FCharacterLoadoutPresetsList final
{
public:
	int32                                         CharacterId;                                       // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivePreset;                                      // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterLoadoutPreset>        Presets;                                           // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterLoadoutPresetsList) == 0x000008, "Wrong alignment on FCharacterLoadoutPresetsList");
static_assert(sizeof(FCharacterLoadoutPresetsList) == 0x000018, "Wrong size on FCharacterLoadoutPresetsList");
static_assert(offsetof(FCharacterLoadoutPresetsList, CharacterId) == 0x000000, "Member 'FCharacterLoadoutPresetsList::CharacterId' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPresetsList, ActivePreset) == 0x000004, "Member 'FCharacterLoadoutPresetsList::ActivePreset' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPresetsList, Presets) == 0x000008, "Member 'FCharacterLoadoutPresetsList::Presets' has a wrong offset!");

// ScriptStruct DeadByDaylight.RoleGenderViewSetting
// 0x0038 (0x0038 - 0x0000)
struct FRoleGenderViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleDropdown                          RoleDropdown;                                      // 0x000C(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EGender                                       Gender;                                            // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenshotViewSetting                 Settings;                                          // 0x0010(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoleGenderViewSetting) == 0x000004, "Wrong alignment on FRoleGenderViewSetting");
static_assert(sizeof(FRoleGenderViewSetting) == 0x000038, "Wrong size on FRoleGenderViewSetting");
static_assert(offsetof(FRoleGenderViewSetting, Label) == 0x000000, "Member 'FRoleGenderViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FRoleGenderViewSetting, RoleDropdown) == 0x00000C, "Member 'FRoleGenderViewSetting::RoleDropdown' has a wrong offset!");
static_assert(offsetof(FRoleGenderViewSetting, Gender) == 0x00000E, "Member 'FRoleGenderViewSetting::Gender' has a wrong offset!");
static_assert(offsetof(FRoleGenderViewSetting, Settings) == 0x000010, "Member 'FRoleGenderViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoadoutPresetListId
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FLoadoutPresetListId final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadoutPresetListId) == 0x000004, "Wrong alignment on FLoadoutPresetListId");
static_assert(sizeof(FLoadoutPresetListId) == 0x000008, "Wrong size on FLoadoutPresetListId");

// ScriptStruct DeadByDaylight.CharacterToolItemData
// 0x0010 (0x0010 - 0x0000)
struct FCharacterToolItemData final
{
public:
	ECharacterToolItemType                        _type;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _id;                                               // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCharacterToolItemData) == 0x000004, "Wrong alignment on FCharacterToolItemData");
static_assert(sizeof(FCharacterToolItemData) == 0x000010, "Wrong size on FCharacterToolItemData");
static_assert(offsetof(FCharacterToolItemData, _type) == 0x000000, "Member 'FCharacterToolItemData::_type' has a wrong offset!");
static_assert(offsetof(FCharacterToolItemData, _id) == 0x000004, "Member 'FCharacterToolItemData::_id' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterToolData
// 0x0080 (0x0080 - 0x0000)
struct FCharacterToolData final
{
public:
	EPlayerRole                                   Role;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterId;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutfitId;                                          // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharmId;                                           // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorHead;                                      // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorTorso;                                     // 0x002C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorLegs;                                      // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerHead;                                        // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerBody;                                        // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerWeapon;                                      // 0x005C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAnimBP;                                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimAsset;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterToolData) == 0x000008, "Wrong alignment on FCharacterToolData");
static_assert(sizeof(FCharacterToolData) == 0x000080, "Wrong size on FCharacterToolData");
static_assert(offsetof(FCharacterToolData, Role) == 0x000000, "Member 'FCharacterToolData::Role' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, CharacterId) == 0x000004, "Member 'FCharacterToolData::CharacterId' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, OutfitId) == 0x000008, "Member 'FCharacterToolData::OutfitId' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, CharmId) == 0x000014, "Member 'FCharacterToolData::CharmId' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, SurvivorHead) == 0x000020, "Member 'FCharacterToolData::SurvivorHead' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, SurvivorTorso) == 0x00002C, "Member 'FCharacterToolData::SurvivorTorso' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, SurvivorLegs) == 0x000038, "Member 'FCharacterToolData::SurvivorLegs' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, KillerHead) == 0x000044, "Member 'FCharacterToolData::KillerHead' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, KillerBody) == 0x000050, "Member 'FCharacterToolData::KillerBody' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, KillerWeapon) == 0x00005C, "Member 'FCharacterToolData::KillerWeapon' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, IsAnimBP) == 0x000068, "Member 'FCharacterToolData::IsAnimBP' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, AnimAsset) == 0x000070, "Member 'FCharacterToolData::AnimAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharmAttacherAnimationTweak
// 0x0020 (0x0020 - 0x0000)
struct FCharmAttacherAnimationTweak final
{
public:
	struct FVector                                AttachPointTranslation;                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AttachPointRotation;                               // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ConstraintType;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicTweakingFloat;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharmAttacherAnimationTweak) == 0x000004, "Wrong alignment on FCharmAttacherAnimationTweak");
static_assert(sizeof(FCharmAttacherAnimationTweak) == 0x000020, "Wrong size on FCharmAttacherAnimationTweak");
static_assert(offsetof(FCharmAttacherAnimationTweak, AttachPointTranslation) == 0x000000, "Member 'FCharmAttacherAnimationTweak::AttachPointTranslation' has a wrong offset!");
static_assert(offsetof(FCharmAttacherAnimationTweak, AttachPointRotation) == 0x00000C, "Member 'FCharmAttacherAnimationTweak::AttachPointRotation' has a wrong offset!");
static_assert(offsetof(FCharmAttacherAnimationTweak, ConstraintType) == 0x000018, "Member 'FCharmAttacherAnimationTweak::ConstraintType' has a wrong offset!");
static_assert(offsetof(FCharmAttacherAnimationTweak, MagicTweakingFloat) == 0x00001C, "Member 'FCharmAttacherAnimationTweak::MagicTweakingFloat' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionItemParameters
// 0x0028 (0x0028 - 0x0000)
struct FShopTransactionItemParameters final
{
public:
	int32                                         itemAmount;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 itemName;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 itemType;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionItemParameters) == 0x000008, "Wrong alignment on FShopTransactionItemParameters");
static_assert(sizeof(FShopTransactionItemParameters) == 0x000028, "Wrong size on FShopTransactionItemParameters");
static_assert(offsetof(FShopTransactionItemParameters, itemAmount) == 0x000000, "Member 'FShopTransactionItemParameters::itemAmount' has a wrong offset!");
static_assert(offsetof(FShopTransactionItemParameters, itemName) == 0x000008, "Member 'FShopTransactionItemParameters::itemName' has a wrong offset!");
static_assert(offsetof(FShopTransactionItemParameters, itemType) == 0x000018, "Member 'FShopTransactionItemParameters::itemType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionItem
// 0x0028 (0x0028 - 0x0000)
struct FShopTransactionItem final
{
public:
	struct FShopTransactionItemParameters         item;                                              // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionItem) == 0x000008, "Wrong alignment on FShopTransactionItem");
static_assert(sizeof(FShopTransactionItem) == 0x000028, "Wrong size on FShopTransactionItem");
static_assert(offsetof(FShopTransactionItem, item) == 0x000000, "Member 'FShopTransactionItem::item' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionProducts
// 0x0020 (0x0020 - 0x0000)
struct FShopTransactionProducts final
{
public:
	TArray<struct FShopTransactionVirtualCurrency> virtualCurrencies;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FShopTransactionItem>           items;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionProducts) == 0x000008, "Wrong alignment on FShopTransactionProducts");
static_assert(sizeof(FShopTransactionProducts) == 0x000020, "Wrong size on FShopTransactionProducts");
static_assert(offsetof(FShopTransactionProducts, virtualCurrencies) == 0x000000, "Member 'FShopTransactionProducts::virtualCurrencies' has a wrong offset!");
static_assert(offsetof(FShopTransactionProducts, items) == 0x000010, "Member 'FShopTransactionProducts::items' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharmSlot
// 0x00B0 (0x00B0 - 0x0000)
struct FCharmSlot final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CharmAttacherClass;                                // 0x0008(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharmAttacherAnimationTweak           DefaultAnimationTweak;                             // 0x0038(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCharmAttacherAnimationTweak> AnimationTweakByTag;                      // 0x0058(0x0050)(Edit, NativeAccessSpecifierPublic)
	class ACharmAttacher*                         CharmAttacherSpawned;                              // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharmSlot) == 0x000008, "Wrong alignment on FCharmSlot");
static_assert(sizeof(FCharmSlot) == 0x0000B0, "Wrong size on FCharmSlot");
static_assert(offsetof(FCharmSlot, SlotIndex) == 0x000000, "Member 'FCharmSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(FCharmSlot, CharmAttacherClass) == 0x000008, "Member 'FCharmSlot::CharmAttacherClass' has a wrong offset!");
static_assert(offsetof(FCharmSlot, DefaultAnimationTweak) == 0x000038, "Member 'FCharmSlot::DefaultAnimationTweak' has a wrong offset!");
static_assert(offsetof(FCharmSlot, AnimationTweakByTag) == 0x000058, "Member 'FCharmSlot::AnimationTweakByTag' has a wrong offset!");
static_assert(offsetof(FCharmSlot, CharmAttacherSpawned) == 0x0000A8, "Member 'FCharmSlot::CharmAttacherSpawned' has a wrong offset!");

// ScriptStruct DeadByDaylight.Cinematic
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FCinematic final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCinematic) == 0x000008, "Wrong alignment on FCinematic");
static_assert(sizeof(FCinematic) == 0x000058, "Wrong size on FCinematic");

// ScriptStruct DeadByDaylight.MaterialMapForClip
// 0x0010 (0x0018 - 0x0008)
struct FMaterialMapForClip final : public FDBDTableRowBase
{
public:
	class UMaterialInterface*                     SrcMaterial;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DstMaterial;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialMapForClip) == 0x000008, "Wrong alignment on FMaterialMapForClip");
static_assert(sizeof(FMaterialMapForClip) == 0x000018, "Wrong size on FMaterialMapForClip");
static_assert(offsetof(FMaterialMapForClip, SrcMaterial) == 0x000008, "Member 'FMaterialMapForClip::SrcMaterial' has a wrong offset!");
static_assert(offsetof(FMaterialMapForClip, DstMaterial) == 0x000010, "Member 'FMaterialMapForClip::DstMaterial' has a wrong offset!");

// ScriptStruct DeadByDaylight.CombinedSpecialEventData
// 0x02F0 (0x02F0 - 0x0000)
struct alignas(0x08) FCombinedSpecialEventData final
{
public:
	uint8                                         Pad_0[0x2F0];                                      // 0x0000(0x02F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCombinedSpecialEventData) == 0x000008, "Wrong alignment on FCombinedSpecialEventData");
static_assert(sizeof(FCombinedSpecialEventData) == 0x0002F0, "Wrong size on FCombinedSpecialEventData");

// ScriptStruct DeadByDaylight.WeightedItem
// 0x0038 (0x0038 - 0x0000)
struct FWeightedItem final
{
public:
	TSoftClassPtr<class UClass>                   Element;                                           // 0x0000(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightedItem) == 0x000008, "Wrong alignment on FWeightedItem");
static_assert(sizeof(FWeightedItem) == 0x000038, "Wrong size on FWeightedItem");
static_assert(offsetof(FWeightedItem, Element) == 0x000000, "Member 'FWeightedItem::Element' has a wrong offset!");
static_assert(offsetof(FWeightedItem, Weight) == 0x000030, "Member 'FWeightedItem::Weight' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContentScheduleData
// 0x0020 (0x0020 - 0x0000)
struct FContentScheduleData final
{
public:
	TArray<struct FContentScheduleRecord>         Schedule;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContentScheduleData) == 0x000008, "Wrong alignment on FContentScheduleData");
static_assert(sizeof(FContentScheduleData) == 0x000020, "Wrong size on FContentScheduleData");
static_assert(offsetof(FContentScheduleData, Schedule) == 0x000000, "Member 'FContentScheduleData::Schedule' has a wrong offset!");

// ScriptStruct DeadByDaylight.TallyScorePipsData
// 0x0030 (0x0030 - 0x0000)
struct FTallyScorePipsData final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PipThresholds;                                     // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FEmblemSlotData>                Scores;                                            // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         PipsDelta;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasher;                                         // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCustomMatch;                                     // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTallyScorePipsData) == 0x000008, "Wrong alignment on FTallyScorePipsData");
static_assert(sizeof(FTallyScorePipsData) == 0x000030, "Wrong size on FTallyScorePipsData");
static_assert(offsetof(FTallyScorePipsData, Threshold) == 0x000000, "Member 'FTallyScorePipsData::Threshold' has a wrong offset!");
static_assert(offsetof(FTallyScorePipsData, PipThresholds) == 0x000008, "Member 'FTallyScorePipsData::PipThresholds' has a wrong offset!");
static_assert(offsetof(FTallyScorePipsData, Scores) == 0x000018, "Member 'FTallyScorePipsData::Scores' has a wrong offset!");
static_assert(offsetof(FTallyScorePipsData, PipsDelta) == 0x000028, "Member 'FTallyScorePipsData::PipsDelta' has a wrong offset!");
static_assert(offsetof(FTallyScorePipsData, IsSlasher) == 0x00002C, "Member 'FTallyScorePipsData::IsSlasher' has a wrong offset!");
static_assert(offsetof(FTallyScorePipsData, IsCustomMatch) == 0x00002D, "Member 'FTallyScorePipsData::IsCustomMatch' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContextEventData
// 0x0068 (0x0068 - 0x0000)
struct FContextEventData final
{
public:
	class FString                                 ContextGroupName;                                  // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ContextGroupUid;                                   // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PreviousContextName;                               // 0x0018(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PreviousContextUid;                                // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentContextName;                                // 0x0030(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CurrentContextUid;                                 // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NextContextName;                                   // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NextContextUid;                                    // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContextEventData) == 0x000008, "Wrong alignment on FContextEventData");
static_assert(sizeof(FContextEventData) == 0x000068, "Wrong size on FContextEventData");
static_assert(offsetof(FContextEventData, ContextGroupName) == 0x000000, "Member 'FContextEventData::ContextGroupName' has a wrong offset!");
static_assert(offsetof(FContextEventData, ContextGroupUid) == 0x000010, "Member 'FContextEventData::ContextGroupUid' has a wrong offset!");
static_assert(offsetof(FContextEventData, PreviousContextName) == 0x000018, "Member 'FContextEventData::PreviousContextName' has a wrong offset!");
static_assert(offsetof(FContextEventData, PreviousContextUid) == 0x000028, "Member 'FContextEventData::PreviousContextUid' has a wrong offset!");
static_assert(offsetof(FContextEventData, CurrentContextName) == 0x000030, "Member 'FContextEventData::CurrentContextName' has a wrong offset!");
static_assert(offsetof(FContextEventData, CurrentContextUid) == 0x000040, "Member 'FContextEventData::CurrentContextUid' has a wrong offset!");
static_assert(offsetof(FContextEventData, NextContextName) == 0x000048, "Member 'FContextEventData::NextContextName' has a wrong offset!");
static_assert(offsetof(FContextEventData, NextContextUid) == 0x000058, "Member 'FContextEventData::NextContextUid' has a wrong offset!");
static_assert(offsetof(FContextEventData, Timestamp) == 0x000060, "Member 'FContextEventData::Timestamp' has a wrong offset!");

// ScriptStruct DeadByDaylight.PromoPackData
// 0x0100 (0x0108 - 0x0008)
struct FPromoPackData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPaperSprite>            PromoPackIcon;                                     // 0x0018(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemUIData                            UIData;                                            // 0x0048(0x00C0)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPromoPackData) == 0x000008, "Wrong alignment on FPromoPackData");
static_assert(sizeof(FPromoPackData) == 0x000108, "Wrong size on FPromoPackData");
static_assert(offsetof(FPromoPackData, ID) == 0x000008, "Member 'FPromoPackData::ID' has a wrong offset!");
static_assert(offsetof(FPromoPackData, PromoPackIcon) == 0x000018, "Member 'FPromoPackData::PromoPackIcon' has a wrong offset!");
static_assert(offsetof(FPromoPackData, UIData) == 0x000048, "Member 'FPromoPackData::UIData' has a wrong offset!");

// ScriptStruct DeadByDaylight.PrestigeRewardStruct
// 0x0018 (0x0018 - 0x0000)
struct FPrestigeRewardStruct final
{
public:
	class FString                                 RewardId;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPrestigeRewardType                           RewardType;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RewardPerkLevel;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrestigeRewardStruct) == 0x000008, "Wrong alignment on FPrestigeRewardStruct");
static_assert(sizeof(FPrestigeRewardStruct) == 0x000018, "Wrong size on FPrestigeRewardStruct");
static_assert(offsetof(FPrestigeRewardStruct, RewardId) == 0x000000, "Member 'FPrestigeRewardStruct::RewardId' has a wrong offset!");
static_assert(offsetof(FPrestigeRewardStruct, RewardType) == 0x000010, "Member 'FPrestigeRewardStruct::RewardType' has a wrong offset!");
static_assert(offsetof(FPrestigeRewardStruct, RewardPerkLevel) == 0x000014, "Member 'FPrestigeRewardStruct::RewardPerkLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.PrestigeRewardData
// 0x0050 (0x0058 - 0x0008)
struct FPrestigeRewardData final : public FDBDTableRowBase
{
public:
	int32                                         AssociatedCharacter;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeLevel;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrestigeRewardStruct                  Rewards[0x3];                                      // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrestigeRewardData) == 0x000008, "Wrong alignment on FPrestigeRewardData");
static_assert(sizeof(FPrestigeRewardData) == 0x000058, "Wrong size on FPrestigeRewardData");
static_assert(offsetof(FPrestigeRewardData, AssociatedCharacter) == 0x000008, "Member 'FPrestigeRewardData::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(FPrestigeRewardData, PrestigeLevel) == 0x00000C, "Member 'FPrestigeRewardData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FPrestigeRewardData, Rewards) == 0x000010, "Member 'FPrestigeRewardData::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.CurrencyUIData
// 0x0070 (0x0078 - 0x0008)
struct FCurrencyUIData final : public FDBDTableRowBase
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            CurrencyColorTheme;                                // 0x0050(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyUIData) == 0x000008, "Wrong alignment on FCurrencyUIData");
static_assert(sizeof(FCurrencyUIData) == 0x000078, "Wrong size on FCurrencyUIData");
static_assert(offsetof(FCurrencyUIData, CurrencyType) == 0x000008, "Member 'FCurrencyUIData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCurrencyUIData, Description) == 0x000010, "Member 'FCurrencyUIData::Description' has a wrong offset!");
static_assert(offsetof(FCurrencyUIData, DisplayName) == 0x000028, "Member 'FCurrencyUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FCurrencyUIData, IconPath) == 0x000040, "Member 'FCurrencyUIData::IconPath' has a wrong offset!");
static_assert(offsetof(FCurrencyUIData, CurrencyColorTheme) == 0x000050, "Member 'FCurrencyUIData::CurrencyColorTheme' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventPeriod
// 0x0040 (0x0040 - 0x0000)
struct FEventPeriod final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartDate;                                         // 0x0010(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EndDate;                                           // 0x0020(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventPeriod) == 0x000008, "Wrong alignment on FEventPeriod");
static_assert(sizeof(FEventPeriod) == 0x000040, "Wrong size on FEventPeriod");
static_assert(offsetof(FEventPeriod, Id) == 0x000000, "Member 'FEventPeriod::Id' has a wrong offset!");
static_assert(offsetof(FEventPeriod, StartDate) == 0x000010, "Member 'FEventPeriod::StartDate' has a wrong offset!");
static_assert(offsetof(FEventPeriod, EndDate) == 0x000020, "Member 'FEventPeriod::EndDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationItemDropdown
// 0x000E (0x0010 - 0x0002)
struct FCustomizationItemDropdown final : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemID;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationItemDropdown) == 0x000004, "Wrong alignment on FCustomizationItemDropdown");
static_assert(sizeof(FCustomizationItemDropdown) == 0x000010, "Wrong size on FCustomizationItemDropdown");
static_assert(offsetof(FCustomizationItemDropdown, ItemID) == 0x000004, "Member 'FCustomizationItemDropdown::ItemID' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationTooltipData
// 0x01D8 (0x0270 - 0x0098)
struct FCustomizationTooltipData final : public FBaseTooltipData
{
public:
	uint8                                         Pad_98[0x1D8];                                     // 0x0098(0x01D8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationTooltipData) == 0x000008, "Wrong alignment on FCustomizationTooltipData");
static_assert(sizeof(FCustomizationTooltipData) == 0x000270, "Wrong size on FCustomizationTooltipData");

// ScriptStruct DeadByDaylight.StatusViewSource
// 0x002C (0x002C - 0x0000)
struct FStatusViewSource final
{
public:
	class FName                                   _sourceID;                                         // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _remainingTime;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _percentageFill;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _level;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInventoryItemType                            _sourceType;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _sourceIconIndex;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _sourceLevel;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVisuallyInfinite;                               // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusViewSource) == 0x000004, "Wrong alignment on FStatusViewSource");
static_assert(sizeof(FStatusViewSource) == 0x00002C, "Wrong size on FStatusViewSource");
static_assert(offsetof(FStatusViewSource, _sourceID) == 0x000000, "Member 'FStatusViewSource::_sourceID' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _isActive) == 0x00000C, "Member 'FStatusViewSource::_isActive' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _remainingTime) == 0x000010, "Member 'FStatusViewSource::_remainingTime' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _percentageFill) == 0x000014, "Member 'FStatusViewSource::_percentageFill' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _level) == 0x000018, "Member 'FStatusViewSource::_level' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _sourceType) == 0x00001C, "Member 'FStatusViewSource::_sourceType' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _sourceIconIndex) == 0x000020, "Member 'FStatusViewSource::_sourceIconIndex' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _sourceLevel) == 0x000024, "Member 'FStatusViewSource::_sourceLevel' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _isVisuallyInfinite) == 0x000028, "Member 'FStatusViewSource::_isVisuallyInfinite' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemVfxLoadingData
// 0x0010 (0x0010 - 0x0000)
struct FItemVfxLoadingData final
{
public:
	class AItemVfx*                               ItemVfx;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemVfxLoadingData) == 0x000008, "Wrong alignment on FItemVfxLoadingData");
static_assert(sizeof(FItemVfxLoadingData) == 0x000010, "Wrong size on FItemVfxLoadingData");
static_assert(offsetof(FItemVfxLoadingData, ItemVfx) == 0x000000, "Member 'FItemVfxLoadingData::ItemVfx' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuadrantSpawnItem
// 0x0018 (0x0018 - 0x0000)
struct FQuadrantSpawnItem final
{
public:
	EQuadrantSpawnType                            Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeightedItem>                  Elements;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuadrantSpawnItem) == 0x000008, "Wrong alignment on FQuadrantSpawnItem");
static_assert(sizeof(FQuadrantSpawnItem) == 0x000018, "Wrong size on FQuadrantSpawnItem");
static_assert(offsetof(FQuadrantSpawnItem, Type) == 0x000000, "Member 'FQuadrantSpawnItem::Type' has a wrong offset!");
static_assert(offsetof(FQuadrantSpawnItem, Elements) == 0x000008, "Member 'FQuadrantSpawnItem::Elements' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuadrantSpawnCategories
// 0x0020 (0x0020 - 0x0000)
struct FQuadrantSpawnCategories final
{
public:
	class FName                                   QuadrantSpawnTag;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuadrantSpawnItem>             Items;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuadrantSpawnCategories) == 0x000008, "Wrong alignment on FQuadrantSpawnCategories");
static_assert(sizeof(FQuadrantSpawnCategories) == 0x000020, "Wrong size on FQuadrantSpawnCategories");
static_assert(offsetof(FQuadrantSpawnCategories, QuadrantSpawnTag) == 0x000000, "Member 'FQuadrantSpawnCategories::QuadrantSpawnTag' has a wrong offset!");
static_assert(offsetof(FQuadrantSpawnCategories, Items) == 0x000010, "Member 'FQuadrantSpawnCategories::Items' has a wrong offset!");

// ScriptStruct DeadByDaylight.HudEditorDragFromParentAxisLimit
// 0x0014 (0x0014 - 0x0000)
struct FHudEditorDragFromParentAxisLimit final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHudEditorDragAxisOption                      AxisOption;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDragDistance;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleMinDragDistanceWithParent;                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDragDistance;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleMaxDragDistanceWithParent;                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHudEditorDragFromParentAxisLimit) == 0x000004, "Wrong alignment on FHudEditorDragFromParentAxisLimit");
static_assert(sizeof(FHudEditorDragFromParentAxisLimit) == 0x000014, "Wrong size on FHudEditorDragFromParentAxisLimit");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, Enable) == 0x000000, "Member 'FHudEditorDragFromParentAxisLimit::Enable' has a wrong offset!");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, AxisOption) == 0x000001, "Member 'FHudEditorDragFromParentAxisLimit::AxisOption' has a wrong offset!");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, MinDragDistance) == 0x000004, "Member 'FHudEditorDragFromParentAxisLimit::MinDragDistance' has a wrong offset!");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, ScaleMinDragDistanceWithParent) == 0x000008, "Member 'FHudEditorDragFromParentAxisLimit::ScaleMinDragDistanceWithParent' has a wrong offset!");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, MaxDragDistance) == 0x00000C, "Member 'FHudEditorDragFromParentAxisLimit::MaxDragDistance' has a wrong offset!");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, ScaleMaxDragDistanceWithParent) == 0x000010, "Member 'FHudEditorDragFromParentAxisLimit::ScaleMaxDragDistanceWithParent' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRewardData
// 0x0040 (0x0040 - 0x0000)
struct FDailyRewardData final
{
public:
	EAtlantaRewardType                            RewardType;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrencyAmount;                                    // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentIconPath;                                    // 0x0018(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemName;                                          // 0x0028(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMarkedSpecial;                                   // 0x003C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   ItemRarity;                                        // 0x003D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUMGDailyRewardWidgetState                    State;                                             // 0x003E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDailyRewardData) == 0x000008, "Wrong alignment on FDailyRewardData");
static_assert(sizeof(FDailyRewardData) == 0x000040, "Wrong size on FDailyRewardData");
static_assert(offsetof(FDailyRewardData, RewardType) == 0x000000, "Member 'FDailyRewardData::RewardType' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, CurrencyAmount) == 0x000004, "Member 'FDailyRewardData::CurrencyAmount' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, IconPath) == 0x000008, "Member 'FDailyRewardData::IconPath' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, ParentIconPath) == 0x000018, "Member 'FDailyRewardData::ParentIconPath' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, ItemName) == 0x000028, "Member 'FDailyRewardData::ItemName' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, Index) == 0x000038, "Member 'FDailyRewardData::Index' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, IsMarkedSpecial) == 0x00003C, "Member 'FDailyRewardData::IsMarkedSpecial' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, ItemRarity) == 0x00003D, "Member 'FDailyRewardData::ItemRarity' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, State) == 0x00003E, "Member 'FDailyRewardData::State' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRewardCalendarData
// 0x0030 (0x0030 - 0x0000)
struct FDailyRewardCalendarData final
{
public:
	TArray<struct FDailyRewardData>               DailyRewardList;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         CurrentlyActiveDailyRewardIndex;                   // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              CalendarStartDate;                                 // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CalendarExpirationDate;                            // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSet;                                             // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDailyRewardCalendarData) == 0x000008, "Wrong alignment on FDailyRewardCalendarData");
static_assert(sizeof(FDailyRewardCalendarData) == 0x000030, "Wrong size on FDailyRewardCalendarData");
static_assert(offsetof(FDailyRewardCalendarData, DailyRewardList) == 0x000000, "Member 'FDailyRewardCalendarData::DailyRewardList' has a wrong offset!");
static_assert(offsetof(FDailyRewardCalendarData, CurrentlyActiveDailyRewardIndex) == 0x000010, "Member 'FDailyRewardCalendarData::CurrentlyActiveDailyRewardIndex' has a wrong offset!");
static_assert(offsetof(FDailyRewardCalendarData, CalendarStartDate) == 0x000018, "Member 'FDailyRewardCalendarData::CalendarStartDate' has a wrong offset!");
static_assert(offsetof(FDailyRewardCalendarData, CalendarExpirationDate) == 0x000020, "Member 'FDailyRewardCalendarData::CalendarExpirationDate' has a wrong offset!");
static_assert(offsetof(FDailyRewardCalendarData, IsSet) == 0x000028, "Member 'FDailyRewardCalendarData::IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpawnPopulationHandler
// 0x00C8 (0x00C8 - 0x0000)
struct FSpawnPopulationHandler final
{
public:
	uint8                                         Pad_0[0xB8];                                       // 0x0000(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                _allAvailableSpawners;                             // 0x00B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSpawnPopulationHandler) == 0x000008, "Wrong alignment on FSpawnPopulationHandler");
static_assert(sizeof(FSpawnPopulationHandler) == 0x0000C8, "Wrong size on FSpawnPopulationHandler");
static_assert(offsetof(FSpawnPopulationHandler, _allAvailableSpawners) == 0x0000B8, "Member 'FSpawnPopulationHandler::_allAvailableSpawners' has a wrong offset!");

// ScriptStruct DeadByDaylight.MapMeshToAkAudioEvent
// 0x0040 (0x0040 - 0x0000)
struct FMapMeshToAkAudioEvent final
{
public:
	TSoftObjectPtr<class UStaticMesh>             Mesh;                                              // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SoundEvent;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBetweenEvents;                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBetweenObject;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapMeshToAkAudioEvent) == 0x000008, "Wrong alignment on FMapMeshToAkAudioEvent");
static_assert(sizeof(FMapMeshToAkAudioEvent) == 0x000040, "Wrong size on FMapMeshToAkAudioEvent");
static_assert(offsetof(FMapMeshToAkAudioEvent, Mesh) == 0x000000, "Member 'FMapMeshToAkAudioEvent::Mesh' has a wrong offset!");
static_assert(offsetof(FMapMeshToAkAudioEvent, SoundEvent) == 0x000030, "Member 'FMapMeshToAkAudioEvent::SoundEvent' has a wrong offset!");
static_assert(offsetof(FMapMeshToAkAudioEvent, MinDelayBetweenEvents) == 0x000038, "Member 'FMapMeshToAkAudioEvent::MinDelayBetweenEvents' has a wrong offset!");
static_assert(offsetof(FMapMeshToAkAudioEvent, MinDelayBetweenObject) == 0x00003C, "Member 'FMapMeshToAkAudioEvent::MinDelayBetweenObject' has a wrong offset!");

// ScriptStruct DeadByDaylight.AICamperDodgeTunableRowData
// 0x0038 (0x0040 - 0x0008)
struct FAICamperDodgeTunableRowData final : public FDBDTableRowBase
{
public:
	int32                                         CharacterId;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	EAIDodgeType                                  BestDodgeType;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequireInSight;                                    // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequireAttackState;                                // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackPlusSurvivorHalfWidth;                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldOfView;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAICamperDodgeTunableRowData) == 0x000008, "Wrong alignment on FAICamperDodgeTunableRowData");
static_assert(sizeof(FAICamperDodgeTunableRowData) == 0x000040, "Wrong size on FAICamperDodgeTunableRowData");
static_assert(offsetof(FAICamperDodgeTunableRowData, CharacterId) == 0x000008, "Member 'FAICamperDodgeTunableRowData::CharacterId' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, Description) == 0x000010, "Member 'FAICamperDodgeTunableRowData::Description' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, BestDodgeType) == 0x000028, "Member 'FAICamperDodgeTunableRowData::BestDodgeType' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, RequireInSight) == 0x000029, "Member 'FAICamperDodgeTunableRowData::RequireInSight' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, RequireAttackState) == 0x00002A, "Member 'FAICamperDodgeTunableRowData::RequireAttackState' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, Duration) == 0x00002C, "Member 'FAICamperDodgeTunableRowData::Duration' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, Range) == 0x000030, "Member 'FAICamperDodgeTunableRowData::Range' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, AttackPlusSurvivorHalfWidth) == 0x000034, "Member 'FAICamperDodgeTunableRowData::AttackPlusSurvivorHalfWidth' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, FieldOfView) == 0x000038, "Member 'FAICamperDodgeTunableRowData::FieldOfView' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIDifficultyTunableRowData
// 0x0010 (0x0018 - 0x0008)
struct FAIDifficultyTunableRowData final : public FDBDTableRowBase
{
public:
	float                                         VeryEasy;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Easy;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Medium;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hard;                                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDifficultyTunableRowData) == 0x000008, "Wrong alignment on FAIDifficultyTunableRowData");
static_assert(sizeof(FAIDifficultyTunableRowData) == 0x000018, "Wrong size on FAIDifficultyTunableRowData");
static_assert(offsetof(FAIDifficultyTunableRowData, VeryEasy) == 0x000008, "Member 'FAIDifficultyTunableRowData::VeryEasy' has a wrong offset!");
static_assert(offsetof(FAIDifficultyTunableRowData, Easy) == 0x00000C, "Member 'FAIDifficultyTunableRowData::Easy' has a wrong offset!");
static_assert(offsetof(FAIDifficultyTunableRowData, Medium) == 0x000010, "Member 'FAIDifficultyTunableRowData::Medium' has a wrong offset!");
static_assert(offsetof(FAIDifficultyTunableRowData, Hard) == 0x000014, "Member 'FAIDifficultyTunableRowData::Hard' has a wrong offset!");

// ScriptStruct DeadByDaylight.EmblemQualityImages
// 0x0120 (0x0120 - 0x0000)
struct FEmblemQualityImages final
{
public:
	struct FSlateBrush                            HighlightImage;                                    // 0x0000(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            DarkImage;                                         // 0x0090(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmblemQualityImages) == 0x000008, "Wrong alignment on FEmblemQualityImages");
static_assert(sizeof(FEmblemQualityImages) == 0x000120, "Wrong size on FEmblemQualityImages");
static_assert(offsetof(FEmblemQualityImages, HighlightImage) == 0x000000, "Member 'FEmblemQualityImages::HighlightImage' has a wrong offset!");
static_assert(offsetof(FEmblemQualityImages, DarkImage) == 0x000090, "Member 'FEmblemQualityImages::DarkImage' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualDefinition
// 0x0060 (0x0068 - 0x0008)
struct FAtlantaRitualDefinition final : public FDBDTableRowBase
{
public:
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Texture;                                           // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRitualDefinition) == 0x000008, "Wrong alignment on FAtlantaRitualDefinition");
static_assert(sizeof(FAtlantaRitualDefinition) == 0x000068, "Wrong size on FAtlantaRitualDefinition");
static_assert(offsetof(FAtlantaRitualDefinition, DisplayName) == 0x000008, "Member 'FAtlantaRitualDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualDefinition, Description) == 0x000020, "Member 'FAtlantaRitualDefinition::Description' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualDefinition, Texture) == 0x000038, "Member 'FAtlantaRitualDefinition::Texture' has a wrong offset!");

// ScriptStruct DeadByDaylight.AuthenticationInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAuthenticationInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAuthenticationInfo) == 0x000008, "Wrong alignment on FAuthenticationInfo");
static_assert(sizeof(FAuthenticationInfo) == 0x000018, "Wrong size on FAuthenticationInfo");

// ScriptStruct DeadByDaylight.PerMeshInstancingData
// 0x0190 (0x0190 - 0x0000)
struct FPerMeshInstancingData final
{
public:
	TMap<uint32, class UInstancedStaticMeshComponent*> gpuCulling_hashToInstancedMeshes;             // 0x0000(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<uint32, class UInstancedStaticMeshComponent*> gpuCullingSwap_hashToInstancedMeshes;         // 0x0050(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<uint32, class UInstancedStaticMeshComponent*> hism_hashToInstancedMeshes;                   // 0x00A0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0xA0];                                      // 0x00F0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerMeshInstancingData) == 0x000008, "Wrong alignment on FPerMeshInstancingData");
static_assert(sizeof(FPerMeshInstancingData) == 0x000190, "Wrong size on FPerMeshInstancingData");
static_assert(offsetof(FPerMeshInstancingData, gpuCulling_hashToInstancedMeshes) == 0x000000, "Member 'FPerMeshInstancingData::gpuCulling_hashToInstancedMeshes' has a wrong offset!");
static_assert(offsetof(FPerMeshInstancingData, gpuCullingSwap_hashToInstancedMeshes) == 0x000050, "Member 'FPerMeshInstancingData::gpuCullingSwap_hashToInstancedMeshes' has a wrong offset!");
static_assert(offsetof(FPerMeshInstancingData, hism_hashToInstancedMeshes) == 0x0000A0, "Member 'FPerMeshInstancingData::hism_hashToInstancedMeshes' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuadrantInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FQuadrantInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuadrantInfo) == 0x000008, "Wrong alignment on FQuadrantInfo");
static_assert(sizeof(FQuadrantInfo) == 0x000020, "Wrong size on FQuadrantInfo");

// ScriptStruct DeadByDaylight.WebNode
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FWebNode final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWebNode) == 0x000008, "Wrong alignment on FWebNode");
static_assert(sizeof(FWebNode) == 0x000028, "Wrong size on FWebNode");

// ScriptStruct DeadByDaylight.SpawnInfo
// 0x0040 (0x0040 - 0x0000)
struct FSpawnInfo final
{
public:
	class UClass*                                 ActorClass;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnInfo) == 0x000010, "Wrong alignment on FSpawnInfo");
static_assert(sizeof(FSpawnInfo) == 0x000040, "Wrong size on FSpawnInfo");
static_assert(offsetof(FSpawnInfo, ActorClass) == 0x000000, "Member 'FSpawnInfo::ActorClass' has a wrong offset!");
static_assert(offsetof(FSpawnInfo, Transform) == 0x000010, "Member 'FSpawnInfo::Transform' has a wrong offset!");

// ScriptStruct DeadByDaylight.AffectedMaterialAndVariant
// 0x0010 (0x0010 - 0x0000)
struct FAffectedMaterialAndVariant final
{
public:
	class UMaterialInterface*                     AffectedMaterial;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialVariant;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAffectedMaterialAndVariant) == 0x000008, "Wrong alignment on FAffectedMaterialAndVariant");
static_assert(sizeof(FAffectedMaterialAndVariant) == 0x000010, "Wrong size on FAffectedMaterialAndVariant");
static_assert(offsetof(FAffectedMaterialAndVariant, AffectedMaterial) == 0x000000, "Member 'FAffectedMaterialAndVariant::AffectedMaterial' has a wrong offset!");
static_assert(offsetof(FAffectedMaterialAndVariant, MaterialVariant) == 0x000008, "Member 'FAffectedMaterialAndVariant::MaterialVariant' has a wrong offset!");

// ScriptStruct DeadByDaylight.RevealOptions
// 0x0018 (0x0018 - 0x0000)
struct FRevealOptions final
{
public:
	bool                                          IsUnaffectedByBlindness;                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOutlineAlwaysVisible;                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnaffectedByFadeout;                             // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorToTestRangeFrom;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRevealOptions) == 0x000008, "Wrong alignment on FRevealOptions");
static_assert(sizeof(FRevealOptions) == 0x000018, "Wrong size on FRevealOptions");
static_assert(offsetof(FRevealOptions, IsUnaffectedByBlindness) == 0x000000, "Member 'FRevealOptions::IsUnaffectedByBlindness' has a wrong offset!");
static_assert(offsetof(FRevealOptions, IsOutlineAlwaysVisible) == 0x000001, "Member 'FRevealOptions::IsOutlineAlwaysVisible' has a wrong offset!");
static_assert(offsetof(FRevealOptions, IsUnaffectedByFadeout) == 0x000002, "Member 'FRevealOptions::IsUnaffectedByFadeout' has a wrong offset!");
static_assert(offsetof(FRevealOptions, Duration) == 0x000004, "Member 'FRevealOptions::Duration' has a wrong offset!");
static_assert(offsetof(FRevealOptions, Range) == 0x000008, "Member 'FRevealOptions::Range' has a wrong offset!");
static_assert(offsetof(FRevealOptions, ActorToTestRangeFrom) == 0x000010, "Member 'FRevealOptions::ActorToTestRangeFrom' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotDebuggingAction
// 0x0001 (0x0001 - 0x0000)
struct FScreenshotDebuggingAction final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotDebuggingAction) == 0x000001, "Wrong alignment on FScreenshotDebuggingAction");
static_assert(sizeof(FScreenshotDebuggingAction) == 0x000001, "Wrong size on FScreenshotDebuggingAction");
static_assert(offsetof(FScreenshotDebuggingAction, Enabled) == 0x000000, "Member 'FScreenshotDebuggingAction::Enabled' has a wrong offset!");

// ScriptStruct DeadByDaylight.ConsoleUserSettings
// 0x00D0 (0x00D0 - 0x0000)
struct FConsoleUserSettings final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputActionKeyMapping>         ActionMappings;                                    // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>           AxisMappings;                                      // 0x0018(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	int32                                         MenuScaleFactor;                                   // 0x0028(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HudScaleFactor;                                    // 0x002C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillCheckScaleFactor;                             // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LargeText;                                         // 0x0034(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BloodwebInteractionBehaviour;                      // 0x0035(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TerrorRadiusVisualFeedback;                        // 0x0036(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Gamma;                                             // 0x0038(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HUDPlayerNamesVisibility;                          // 0x003C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HUDScoreEventsVisibility;                          // 0x003D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HUDKillerHookCountVisibility;                      // 0x003E(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SurvivorSpecificPingIcon;                          // 0x003F(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LegacyPrestigePortraits;                           // 0x0040(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChallengeProgression;                              // 0x0041(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChallengeCompletion;                               // 0x0042(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MainVolume;                                        // 0x0044(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MenuMusicVolume;                                   // 0x0048(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseHeadphones;                                     // 0x004C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MuteOnFocusLost;                                   // 0x004D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HapticsVibrationPS5;                               // 0x004E(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KillerMouseSensitivity;                            // 0x0050(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SurvivorMouseSensitivity;                          // 0x0054(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillerControllerSensitivity;                       // 0x0058(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SurvivorControllerSensitivity;                     // 0x005C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertY;                                           // 0x0060(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SurvivorInvertY;                                   // 0x0061(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KillerToggleInteractions;                          // 0x0062(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SurvivorToggleInteractions;                        // 0x0063(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SprintToCancel;                                    // 0x0064(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HighestWeightSeenNews;                             // 0x0068(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAtlantaCustomizedHuds;                          // 0x006C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAtlantaSurvivorQuickTurn;                       // 0x006D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAtlantaKillerQuickTurn;                         // 0x006E(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F[0x1];                                       // 0x006F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlantaCustomizedHudSettings>  AtlantaCustomizedHuds;                             // 0x0070(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          HasAcceptedCrossplayPopup;                         // 0x0080(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAcceptedProgressionSystemInfoPopup;             // 0x0081(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAcceptedCrossProgressionPopup;                  // 0x0082(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83[0x5];                                       // 0x0083(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBonusTierTooltipVisibility            BonusTierTooltipVisibility;                        // 0x0088(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	class FString                                 PartyPrivacyState;                                 // 0x00A0(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorBlindMode;                                    // 0x00B0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorBlindModeIntensity;                           // 0x00B4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BeginnerMode;                                      // 0x00B8(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Subtitles;                                         // 0x00B9(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubtitlesBackgroundOpacity;                        // 0x00BC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubtitlesSize;                                     // 0x00C0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAnonymousMode;                                   // 0x00C4(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideYourName;                                      // 0x00C5(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideOtherNames;                                    // 0x00C6(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HiddenMatchmakingDelay;                            // 0x00C7(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAcceptedHapticsVibrationPopup;                  // 0x00C8(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConsoleUserSettings) == 0x000008, "Wrong alignment on FConsoleUserSettings");
static_assert(sizeof(FConsoleUserSettings) == 0x0000D0, "Wrong size on FConsoleUserSettings");
static_assert(offsetof(FConsoleUserSettings, ActionMappings) == 0x000008, "Member 'FConsoleUserSettings::ActionMappings' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, AxisMappings) == 0x000018, "Member 'FConsoleUserSettings::AxisMappings' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, MenuScaleFactor) == 0x000028, "Member 'FConsoleUserSettings::MenuScaleFactor' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HudScaleFactor) == 0x00002C, "Member 'FConsoleUserSettings::HudScaleFactor' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SkillCheckScaleFactor) == 0x000030, "Member 'FConsoleUserSettings::SkillCheckScaleFactor' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, LargeText) == 0x000034, "Member 'FConsoleUserSettings::LargeText' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, BloodwebInteractionBehaviour) == 0x000035, "Member 'FConsoleUserSettings::BloodwebInteractionBehaviour' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, TerrorRadiusVisualFeedback) == 0x000036, "Member 'FConsoleUserSettings::TerrorRadiusVisualFeedback' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, Gamma) == 0x000038, "Member 'FConsoleUserSettings::Gamma' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HUDPlayerNamesVisibility) == 0x00003C, "Member 'FConsoleUserSettings::HUDPlayerNamesVisibility' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HUDScoreEventsVisibility) == 0x00003D, "Member 'FConsoleUserSettings::HUDScoreEventsVisibility' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HUDKillerHookCountVisibility) == 0x00003E, "Member 'FConsoleUserSettings::HUDKillerHookCountVisibility' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SurvivorSpecificPingIcon) == 0x00003F, "Member 'FConsoleUserSettings::SurvivorSpecificPingIcon' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, LegacyPrestigePortraits) == 0x000040, "Member 'FConsoleUserSettings::LegacyPrestigePortraits' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, ChallengeProgression) == 0x000041, "Member 'FConsoleUserSettings::ChallengeProgression' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, ChallengeCompletion) == 0x000042, "Member 'FConsoleUserSettings::ChallengeCompletion' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, MainVolume) == 0x000044, "Member 'FConsoleUserSettings::MainVolume' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, MenuMusicVolume) == 0x000048, "Member 'FConsoleUserSettings::MenuMusicVolume' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, UseHeadphones) == 0x00004C, "Member 'FConsoleUserSettings::UseHeadphones' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, MuteOnFocusLost) == 0x00004D, "Member 'FConsoleUserSettings::MuteOnFocusLost' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HapticsVibrationPS5) == 0x00004E, "Member 'FConsoleUserSettings::HapticsVibrationPS5' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, KillerMouseSensitivity) == 0x000050, "Member 'FConsoleUserSettings::KillerMouseSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SurvivorMouseSensitivity) == 0x000054, "Member 'FConsoleUserSettings::SurvivorMouseSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, KillerControllerSensitivity) == 0x000058, "Member 'FConsoleUserSettings::KillerControllerSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SurvivorControllerSensitivity) == 0x00005C, "Member 'FConsoleUserSettings::SurvivorControllerSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, InvertY) == 0x000060, "Member 'FConsoleUserSettings::InvertY' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SurvivorInvertY) == 0x000061, "Member 'FConsoleUserSettings::SurvivorInvertY' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, KillerToggleInteractions) == 0x000062, "Member 'FConsoleUserSettings::KillerToggleInteractions' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SurvivorToggleInteractions) == 0x000063, "Member 'FConsoleUserSettings::SurvivorToggleInteractions' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SprintToCancel) == 0x000064, "Member 'FConsoleUserSettings::SprintToCancel' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HighestWeightSeenNews) == 0x000068, "Member 'FConsoleUserSettings::HighestWeightSeenNews' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, UseAtlantaCustomizedHuds) == 0x00006C, "Member 'FConsoleUserSettings::UseAtlantaCustomizedHuds' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, UseAtlantaSurvivorQuickTurn) == 0x00006D, "Member 'FConsoleUserSettings::UseAtlantaSurvivorQuickTurn' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, UseAtlantaKillerQuickTurn) == 0x00006E, "Member 'FConsoleUserSettings::UseAtlantaKillerQuickTurn' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, AtlantaCustomizedHuds) == 0x000070, "Member 'FConsoleUserSettings::AtlantaCustomizedHuds' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HasAcceptedCrossplayPopup) == 0x000080, "Member 'FConsoleUserSettings::HasAcceptedCrossplayPopup' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HasAcceptedProgressionSystemInfoPopup) == 0x000081, "Member 'FConsoleUserSettings::HasAcceptedProgressionSystemInfoPopup' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HasAcceptedCrossProgressionPopup) == 0x000082, "Member 'FConsoleUserSettings::HasAcceptedCrossProgressionPopup' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, BonusTierTooltipVisibility) == 0x000088, "Member 'FConsoleUserSettings::BonusTierTooltipVisibility' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, PartyPrivacyState) == 0x0000A0, "Member 'FConsoleUserSettings::PartyPrivacyState' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, ColorBlindMode) == 0x0000B0, "Member 'FConsoleUserSettings::ColorBlindMode' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, ColorBlindModeIntensity) == 0x0000B4, "Member 'FConsoleUserSettings::ColorBlindModeIntensity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, BeginnerMode) == 0x0000B8, "Member 'FConsoleUserSettings::BeginnerMode' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, Subtitles) == 0x0000B9, "Member 'FConsoleUserSettings::Subtitles' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SubtitlesBackgroundOpacity) == 0x0000BC, "Member 'FConsoleUserSettings::SubtitlesBackgroundOpacity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SubtitlesSize) == 0x0000C0, "Member 'FConsoleUserSettings::SubtitlesSize' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, IsAnonymousMode) == 0x0000C4, "Member 'FConsoleUserSettings::IsAnonymousMode' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HideYourName) == 0x0000C5, "Member 'FConsoleUserSettings::HideYourName' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HideOtherNames) == 0x0000C6, "Member 'FConsoleUserSettings::HideOtherNames' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HiddenMatchmakingDelay) == 0x0000C7, "Member 'FConsoleUserSettings::HiddenMatchmakingDelay' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HasAcceptedHapticsVibrationPopup) == 0x0000C8, "Member 'FConsoleUserSettings::HasAcceptedHapticsVibrationPopup' has a wrong offset!");

// ScriptStruct DeadByDaylight.CurrencyConversion
// 0x0050 (0x0050 - 0x0000)
struct FCurrencyConversion final
{
public:
	TMap<ECurrencyType, float>                    AmountInOtherCurrency;                             // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyConversion) == 0x000008, "Wrong alignment on FCurrencyConversion");
static_assert(sizeof(FCurrencyConversion) == 0x000050, "Wrong size on FCurrencyConversion");
static_assert(offsetof(FCurrencyConversion, AmountInOtherCurrency) == 0x000000, "Member 'FCurrencyConversion::AmountInOtherCurrency' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRitualContainer
// 0x0028 (0x0028 - 0x0000)
struct FDailyRitualContainer final
{
public:
	struct FDateTime                              LastRitualReceivedDate;                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastRitualPopupDate;                               // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastRitualDismissedDate;                           // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDailyRitualInstance>           Rituals;                                           // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRitualContainer) == 0x000008, "Wrong alignment on FDailyRitualContainer");
static_assert(sizeof(FDailyRitualContainer) == 0x000028, "Wrong size on FDailyRitualContainer");
static_assert(offsetof(FDailyRitualContainer, LastRitualReceivedDate) == 0x000000, "Member 'FDailyRitualContainer::LastRitualReceivedDate' has a wrong offset!");
static_assert(offsetof(FDailyRitualContainer, LastRitualPopupDate) == 0x000008, "Member 'FDailyRitualContainer::LastRitualPopupDate' has a wrong offset!");
static_assert(offsetof(FDailyRitualContainer, LastRitualDismissedDate) == 0x000010, "Member 'FDailyRitualContainer::LastRitualDismissedDate' has a wrong offset!");
static_assert(offsetof(FDailyRitualContainer, Rituals) == 0x000018, "Member 'FDailyRitualContainer::Rituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionItemProducts
// 0x0010 (0x0010 - 0x0000)
struct FShopTransactionItemProducts final
{
public:
	TArray<struct FShopTransactionItem>           items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionItemProducts) == 0x000008, "Wrong alignment on FShopTransactionItemProducts");
static_assert(sizeof(FShopTransactionItemProducts) == 0x000010, "Wrong size on FShopTransactionItemProducts");
static_assert(offsetof(FShopTransactionItemProducts, items) == 0x000000, "Member 'FShopTransactionItemProducts::items' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRitualDefinition
// 0x00D0 (0x00D8 - 0x0008)
struct FDailyRitualDefinition final : public FDBDTableRowBase
{
public:
	class FString                                 RitualId;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDailyRitualPossibleCharacters         PossibleCharacters;                                // 0x0058(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EDBDScoreTypes>                        TrackedEvents;                                     // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   TrackedGameEvents;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Evaluator;                                         // 0x00A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRitualDefinition) == 0x000008, "Wrong alignment on FDailyRitualDefinition");
static_assert(sizeof(FDailyRitualDefinition) == 0x0000D8, "Wrong size on FDailyRitualDefinition");
static_assert(offsetof(FDailyRitualDefinition, RitualId) == 0x000008, "Member 'FDailyRitualDefinition::RitualId' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, DisplayName) == 0x000018, "Member 'FDailyRitualDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, Description) == 0x000030, "Member 'FDailyRitualDefinition::Description' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, IconPath) == 0x000048, "Member 'FDailyRitualDefinition::IconPath' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, PossibleCharacters) == 0x000058, "Member 'FDailyRitualDefinition::PossibleCharacters' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, TrackedEvents) == 0x000088, "Member 'FDailyRitualDefinition::TrackedEvents' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, TrackedGameEvents) == 0x000098, "Member 'FDailyRitualDefinition::TrackedGameEvents' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, Evaluator) == 0x0000A8, "Member 'FDailyRitualDefinition::Evaluator' has a wrong offset!");

// ScriptStruct DeadByDaylight.RitualEvent
// 0x0030 (0x0030 - 0x0000)
struct FRitualEvent final
{
public:
	EDBDScoreTypes                                ScoreType;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GameEventType;                                     // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amount;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Instigator;                                        // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayerState*                        InstigatorPlayerState;                             // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRitualEvent) == 0x000008, "Wrong alignment on FRitualEvent");
static_assert(sizeof(FRitualEvent) == 0x000030, "Wrong size on FRitualEvent");
static_assert(offsetof(FRitualEvent, ScoreType) == 0x000000, "Member 'FRitualEvent::ScoreType' has a wrong offset!");
static_assert(offsetof(FRitualEvent, GameEventType) == 0x000004, "Member 'FRitualEvent::GameEventType' has a wrong offset!");
static_assert(offsetof(FRitualEvent, Amount) == 0x000010, "Member 'FRitualEvent::Amount' has a wrong offset!");
static_assert(offsetof(FRitualEvent, Instigator) == 0x000018, "Member 'FRitualEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FRitualEvent, InstigatorPlayerState) == 0x000020, "Member 'FRitualEvent::InstigatorPlayerState' has a wrong offset!");
static_assert(offsetof(FRitualEvent, Target) == 0x000028, "Member 'FRitualEvent::Target' has a wrong offset!");

// ScriptStruct DeadByDaylight.CamperLoadout
// 0x00C0 (0x00C0 - 0x0000)
struct FCamperLoadout final
{
public:
	struct FCharacterCustomizationDropdown        Camper;                                            // 0x0000(0x005C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharmDropdown                         Slot0_CharmID;                                     // 0x005C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharmDropdown                         Slot1_CharmID;                                     // 0x006C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharmDropdown                         Slot2_CharmID;                                     // 0x007C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemIdDropdown                        Item;                                              // 0x008C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDebugLoadoutAddon>             AddonIDs;                                          // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDebugLoadoutPerk>              Perks;                                             // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCamperLoadout) == 0x000008, "Wrong alignment on FCamperLoadout");
static_assert(sizeof(FCamperLoadout) == 0x0000C0, "Wrong size on FCamperLoadout");
static_assert(offsetof(FCamperLoadout, Camper) == 0x000000, "Member 'FCamperLoadout::Camper' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Slot0_CharmID) == 0x00005C, "Member 'FCamperLoadout::Slot0_CharmID' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Slot1_CharmID) == 0x00006C, "Member 'FCamperLoadout::Slot1_CharmID' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Slot2_CharmID) == 0x00007C, "Member 'FCamperLoadout::Slot2_CharmID' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Item) == 0x00008C, "Member 'FCamperLoadout::Item' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, AddonIDs) == 0x0000A0, "Member 'FCamperLoadout::AddonIDs' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Perks) == 0x0000B0, "Member 'FCamperLoadout::Perks' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventSplashScreenData
// 0x0038 (0x0038 - 0x0000)
struct FSpecialEventSplashScreenData final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delay;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DBDLogoClass;                                      // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventSplashScreenData) == 0x000008, "Wrong alignment on FSpecialEventSplashScreenData");
static_assert(sizeof(FSpecialEventSplashScreenData) == 0x000038, "Wrong size on FSpecialEventSplashScreenData");
static_assert(offsetof(FSpecialEventSplashScreenData, Enabled) == 0x000000, "Member 'FSpecialEventSplashScreenData::Enabled' has a wrong offset!");
static_assert(offsetof(FSpecialEventSplashScreenData, Delay) == 0x000004, "Member 'FSpecialEventSplashScreenData::Delay' has a wrong offset!");
static_assert(offsetof(FSpecialEventSplashScreenData, DBDLogoClass) == 0x000008, "Member 'FSpecialEventSplashScreenData::DBDLogoClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.AttackTypeDetails
// 0x0020 (0x0028 - 0x0008)
struct FAttackTypeDetails final : public FDBDTableRowBase
{
public:
	EAttackType                                   AttackType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBasicAttack;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AssociatedCharacter;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackTypeDetails) == 0x000008, "Wrong alignment on FAttackTypeDetails");
static_assert(sizeof(FAttackTypeDetails) == 0x000028, "Wrong size on FAttackTypeDetails");
static_assert(offsetof(FAttackTypeDetails, AttackType) == 0x000008, "Member 'FAttackTypeDetails::AttackType' has a wrong offset!");
static_assert(offsetof(FAttackTypeDetails, IsBasicAttack) == 0x000009, "Member 'FAttackTypeDetails::IsBasicAttack' has a wrong offset!");
static_assert(offsetof(FAttackTypeDetails, AssociatedCharacter) == 0x00000C, "Member 'FAttackTypeDetails::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(FAttackTypeDetails, Description) == 0x000010, "Member 'FAttackTypeDetails::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkLevelDefinition
// 0x0004 (0x0004 - 0x0000)
struct FPerkLevelDefinition final
{
public:
	int32                                         CountRequired;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkLevelDefinition) == 0x000004, "Wrong alignment on FPerkLevelDefinition");
static_assert(sizeof(FPerkLevelDefinition) == 0x000004, "Wrong size on FPerkLevelDefinition");
static_assert(offsetof(FPerkLevelDefinition, CountRequired) == 0x000000, "Member 'FPerkLevelDefinition::CountRequired' has a wrong offset!");

// ScriptStruct DeadByDaylight.TunableValue
// 0x0020 (0x0028 - 0x0008)
struct FTunableValue final : public FDBDTunableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtlantaOverriddenValue;                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverriddenInAtlanta;                               // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTunableValue) == 0x000008, "Wrong alignment on FTunableValue");
static_assert(sizeof(FTunableValue) == 0x000028, "Wrong size on FTunableValue");
static_assert(offsetof(FTunableValue, Value) == 0x000008, "Member 'FTunableValue::Value' has a wrong offset!");
static_assert(offsetof(FTunableValue, AtlantaOverriddenValue) == 0x00000C, "Member 'FTunableValue::AtlantaOverriddenValue' has a wrong offset!");
static_assert(offsetof(FTunableValue, Description) == 0x000010, "Member 'FTunableValue::Description' has a wrong offset!");
static_assert(offsetof(FTunableValue, OverriddenInAtlanta) == 0x000020, "Member 'FTunableValue::OverriddenInAtlanta' has a wrong offset!");

// ScriptStruct DeadByDaylight.ProgressionPoints
// 0x0008 (0x0008 - 0x0000)
struct FProgressionPoints final
{
public:
	EEmblemProgressionType                        Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Points;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProgressionPoints) == 0x000004, "Wrong alignment on FProgressionPoints");
static_assert(sizeof(FProgressionPoints) == 0x000008, "Wrong size on FProgressionPoints");
static_assert(offsetof(FProgressionPoints, Type) == 0x000000, "Member 'FProgressionPoints::Type' has a wrong offset!");
static_assert(offsetof(FProgressionPoints, Points) == 0x000004, "Member 'FProgressionPoints::Points' has a wrong offset!");

// ScriptStruct DeadByDaylight.LanguageMapping
// 0x0018 (0x0020 - 0x0008)
struct FLanguageMapping final : public FTableRowBase
{
public:
	class FString                                 Language;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomerSupportLanguages                     CustomerSupportId;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EForumLanguages                               ForumId;                                           // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLanguageMapping) == 0x000008, "Wrong alignment on FLanguageMapping");
static_assert(sizeof(FLanguageMapping) == 0x000020, "Wrong size on FLanguageMapping");
static_assert(offsetof(FLanguageMapping, Language) == 0x000008, "Member 'FLanguageMapping::Language' has a wrong offset!");
static_assert(offsetof(FLanguageMapping, CustomerSupportId) == 0x000018, "Member 'FLanguageMapping::CustomerSupportId' has a wrong offset!");
static_assert(offsetof(FLanguageMapping, ForumId) == 0x000019, "Member 'FLanguageMapping::ForumId' has a wrong offset!");

// ScriptStruct DeadByDaylight.RichTextFreeTicketTextInfo
// 0x02B0 (0x02B0 - 0x0000)
struct FRichTextFreeTicketTextInfo final
{
public:
	struct FTextBlockStyle                        TextStyle;                                         // 0x0000(0x0288)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Content;                                           // 0x0288(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FMargin                                Padding;                                           // 0x02A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichTextFreeTicketTextInfo) == 0x000008, "Wrong alignment on FRichTextFreeTicketTextInfo");
static_assert(sizeof(FRichTextFreeTicketTextInfo) == 0x0002B0, "Wrong size on FRichTextFreeTicketTextInfo");
static_assert(offsetof(FRichTextFreeTicketTextInfo, TextStyle) == 0x000000, "Member 'FRichTextFreeTicketTextInfo::TextStyle' has a wrong offset!");
static_assert(offsetof(FRichTextFreeTicketTextInfo, Content) == 0x000288, "Member 'FRichTextFreeTicketTextInfo::Content' has a wrong offset!");
static_assert(offsetof(FRichTextFreeTicketTextInfo, Padding) == 0x0002A0, "Member 'FRichTextFreeTicketTextInfo::Padding' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDFoliageInfo
// 0x0018 (0x0018 - 0x0000)
struct FDBDFoliageInfo final
{
public:
	class UFoliageType*                           foliageType;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDBDFoliageInstance>            instances;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDFoliageInfo) == 0x000008, "Wrong alignment on FDBDFoliageInfo");
static_assert(sizeof(FDBDFoliageInfo) == 0x000018, "Wrong size on FDBDFoliageInfo");
static_assert(offsetof(FDBDFoliageInfo, foliageType) == 0x000000, "Member 'FDBDFoliageInfo::foliageType' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInfo, instances) == 0x000008, "Member 'FDBDFoliageInfo::instances' has a wrong offset!");

// ScriptStruct DeadByDaylight.KeyDisplayInfo
// 0x0040 (0x0040 - 0x0000)
struct FKeyDisplayInfo final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyDisplayName;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PromptType;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyDisplayInfo) == 0x000008, "Wrong alignment on FKeyDisplayInfo");
static_assert(sizeof(FKeyDisplayInfo) == 0x000040, "Wrong size on FKeyDisplayInfo");
static_assert(offsetof(FKeyDisplayInfo, Key) == 0x000000, "Member 'FKeyDisplayInfo::Key' has a wrong offset!");
static_assert(offsetof(FKeyDisplayInfo, KeyDisplayName) == 0x000020, "Member 'FKeyDisplayInfo::KeyDisplayName' has a wrong offset!");
static_assert(offsetof(FKeyDisplayInfo, PromptType) == 0x000030, "Member 'FKeyDisplayInfo::PromptType' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacyPlayerSavedProfileDataShared
// 0x0040 (0x0040 - 0x0000)
struct FLegacyPlayerSavedProfileDataShared final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0008(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedCamperIndex;                               // 0x0018(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSlasherIndex;                              // 0x001C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SelectedCharacterCustomization;                    // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	int32                                         SlasherSkulls;                                     // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CamperSkulls;                                      // 0x0034(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CamperStreak;                                      // 0x0038(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyPlayerSavedProfileDataShared) == 0x000008, "Wrong alignment on FLegacyPlayerSavedProfileDataShared");
static_assert(sizeof(FLegacyPlayerSavedProfileDataShared) == 0x000040, "Wrong size on FLegacyPlayerSavedProfileDataShared");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, PlayerName) == 0x000008, "Member 'FLegacyPlayerSavedProfileDataShared::PlayerName' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, SelectedCamperIndex) == 0x000018, "Member 'FLegacyPlayerSavedProfileDataShared::SelectedCamperIndex' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, SelectedSlasherIndex) == 0x00001C, "Member 'FLegacyPlayerSavedProfileDataShared::SelectedSlasherIndex' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, SelectedCharacterCustomization) == 0x000020, "Member 'FLegacyPlayerSavedProfileDataShared::SelectedCharacterCustomization' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, SlasherSkulls) == 0x000030, "Member 'FLegacyPlayerSavedProfileDataShared::SlasherSkulls' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, CamperSkulls) == 0x000034, "Member 'FLegacyPlayerSavedProfileDataShared::CamperSkulls' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, CamperStreak) == 0x000038, "Member 'FLegacyPlayerSavedProfileDataShared::CamperStreak' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacyPlayerSavedProfileData
// 0x01D0 (0x01E0 - 0x0010)
struct FLegacyPlayerSavedProfileData final : public FSaveDataBase
{
public:
	class FString                                 PlayerUID;                                         // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLegacyPlayerSavedProfileDataShared    SharedData;                                        // 0x0020(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacyPlayerSavedProfileDataLocal     LocalData;                                         // 0x0060(0x0180)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyPlayerSavedProfileData) == 0x000008, "Wrong alignment on FLegacyPlayerSavedProfileData");
static_assert(sizeof(FLegacyPlayerSavedProfileData) == 0x0001E0, "Wrong size on FLegacyPlayerSavedProfileData");
static_assert(offsetof(FLegacyPlayerSavedProfileData, PlayerUID) == 0x000010, "Member 'FLegacyPlayerSavedProfileData::PlayerUID' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileData, SharedData) == 0x000020, "Member 'FLegacyPlayerSavedProfileData::SharedData' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileData, LocalData) == 0x000060, "Member 'FLegacyPlayerSavedProfileData::LocalData' has a wrong offset!");

// ScriptStruct DeadByDaylight.InboxMessageUIData
// 0x0060 (0x0060 - 0x0000)
struct FInboxMessageUIData final
{
public:
	class FString                                 MessageId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ReceivedTime;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInboxMessageUIType                           MessageType;                                       // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MessageTitle;                                      // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageBody;                                       // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInboxMessageUIState                          MessageState;                                      // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClaimableInboxMessage                 AttachedClaimable;                                 // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInboxMessageUIData) == 0x000008, "Wrong alignment on FInboxMessageUIData");
static_assert(sizeof(FInboxMessageUIData) == 0x000060, "Wrong size on FInboxMessageUIData");
static_assert(offsetof(FInboxMessageUIData, MessageId) == 0x000000, "Member 'FInboxMessageUIData::MessageId' has a wrong offset!");
static_assert(offsetof(FInboxMessageUIData, ReceivedTime) == 0x000010, "Member 'FInboxMessageUIData::ReceivedTime' has a wrong offset!");
static_assert(offsetof(FInboxMessageUIData, MessageType) == 0x000018, "Member 'FInboxMessageUIData::MessageType' has a wrong offset!");
static_assert(offsetof(FInboxMessageUIData, MessageTitle) == 0x000020, "Member 'FInboxMessageUIData::MessageTitle' has a wrong offset!");
static_assert(offsetof(FInboxMessageUIData, MessageBody) == 0x000030, "Member 'FInboxMessageUIData::MessageBody' has a wrong offset!");
static_assert(offsetof(FInboxMessageUIData, MessageState) == 0x000040, "Member 'FInboxMessageUIData::MessageState' has a wrong offset!");
static_assert(offsetof(FInboxMessageUIData, AttachedClaimable) == 0x000048, "Member 'FInboxMessageUIData::AttachedClaimable' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuCharacterUIData
// 0x0020 (0x0028 - 0x0008)
struct FMenuCharacterUIData final : public FDBDTableRowBase
{
public:
	int32                                         CharacterIndex;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                offsetMainMenuForwardPosition;                     // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                offsetMainMenuBackwardPosition;                    // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMenuCharacterUIData) == 0x000008, "Wrong alignment on FMenuCharacterUIData");
static_assert(sizeof(FMenuCharacterUIData) == 0x000028, "Wrong size on FMenuCharacterUIData");
static_assert(offsetof(FMenuCharacterUIData, CharacterIndex) == 0x000008, "Member 'FMenuCharacterUIData::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FMenuCharacterUIData, offsetMainMenuForwardPosition) == 0x00000C, "Member 'FMenuCharacterUIData::offsetMainMenuForwardPosition' has a wrong offset!");
static_assert(offsetof(FMenuCharacterUIData, offsetMainMenuBackwardPosition) == 0x000018, "Member 'FMenuCharacterUIData::offsetMainMenuBackwardPosition' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerRankData
// 0x0018 (0x0018 - 0x0000)
struct FPlayerRankData final
{
public:
	class FString                                 MirrorsId;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerRankForRole;                                 // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerRankData) == 0x000008, "Wrong alignment on FPlayerRankData");
static_assert(sizeof(FPlayerRankData) == 0x000018, "Wrong size on FPlayerRankData");
static_assert(offsetof(FPlayerRankData, MirrorsId) == 0x000000, "Member 'FPlayerRankData::MirrorsId' has a wrong offset!");
static_assert(offsetof(FPlayerRankData, PlayerRole) == 0x000010, "Member 'FPlayerRankData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FPlayerRankData, PlayerRankForRole) == 0x000014, "Member 'FPlayerRankData::PlayerRankForRole' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerRoundStartEventData
// 0x0050 (0x0050 - 0x0000)
struct FPlayerRoundStartEventData final
{
public:
	EPlayerRole                                   PlayerRole;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsABot;                                            // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIDifficultyLevel                            BotDifficultyLevel;                                // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BotName;                                           // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BotMirrorID;                                       // 0x0018(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterId;                                       // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerRankForRole;                                 // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeLevel;                                     // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodWebLevel;                                     // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pips;                                              // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerRankData>                PlayerRankDataArray;                               // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerRoundStartEventData) == 0x000008, "Wrong alignment on FPlayerRoundStartEventData");
static_assert(sizeof(FPlayerRoundStartEventData) == 0x000050, "Wrong size on FPlayerRoundStartEventData");
static_assert(offsetof(FPlayerRoundStartEventData, PlayerRole) == 0x000000, "Member 'FPlayerRoundStartEventData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, IsABot) == 0x000001, "Member 'FPlayerRoundStartEventData::IsABot' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, BotDifficultyLevel) == 0x000002, "Member 'FPlayerRoundStartEventData::BotDifficultyLevel' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, BotName) == 0x000008, "Member 'FPlayerRoundStartEventData::BotName' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, BotMirrorID) == 0x000018, "Member 'FPlayerRoundStartEventData::BotMirrorID' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, CharacterId) == 0x000028, "Member 'FPlayerRoundStartEventData::CharacterId' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, PlayerRankForRole) == 0x00002C, "Member 'FPlayerRoundStartEventData::PlayerRankForRole' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, PrestigeLevel) == 0x000030, "Member 'FPlayerRoundStartEventData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, BloodWebLevel) == 0x000034, "Member 'FPlayerRoundStartEventData::BloodWebLevel' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, Pips) == 0x000038, "Member 'FPlayerRoundStartEventData::Pips' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, PlayerRankDataArray) == 0x000040, "Member 'FPlayerRoundStartEventData::PlayerRankDataArray' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingEffect
// 0x0028 (0x0028 - 0x0000)
struct FOfferingEffect final
{
public:
	EOfferingEffectType                           Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Value;                                             // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Modifier;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingEffect) == 0x000008, "Wrong alignment on FOfferingEffect");
static_assert(sizeof(FOfferingEffect) == 0x000028, "Wrong size on FOfferingEffect");
static_assert(offsetof(FOfferingEffect, Type) == 0x000000, "Member 'FOfferingEffect::Type' has a wrong offset!");
static_assert(offsetof(FOfferingEffect, Tags) == 0x000008, "Member 'FOfferingEffect::Tags' has a wrong offset!");
static_assert(offsetof(FOfferingEffect, Value) == 0x000018, "Member 'FOfferingEffect::Value' has a wrong offset!");
static_assert(offsetof(FOfferingEffect, Modifier) == 0x000024, "Member 'FOfferingEffect::Modifier' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkLevelText
// 0x0028 (0x0028 - 0x0000)
struct FPerkLevelText final
{
public:
	TArray<class FString>                         Tunables;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   TextOverride;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkLevelText) == 0x000008, "Wrong alignment on FPerkLevelText");
static_assert(sizeof(FPerkLevelText) == 0x000028, "Wrong size on FPerkLevelText");
static_assert(offsetof(FPerkLevelText, Tunables) == 0x000000, "Member 'FPerkLevelText::Tunables' has a wrong offset!");
static_assert(offsetof(FPerkLevelText, TextOverride) == 0x000010, "Member 'FPerkLevelText::TextOverride' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkProperties
// 0x00F0 (0x02D8 - 0x01E8)
struct FPerkProperties final : public FItemData
{
public:
	TArray<class FName>                           Tags;                                              // 0x01E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOfferingEffect>                Effects;                                           // 0x01F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AssociatedPlayerIndex;                             // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MandatoryOnBloodweblevel;                          // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeachableOnBloodweblevel;                          // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AtlantaTeachableLevel;                             // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPerkCategory>                         PerkCategory;                                      // 0x0218(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PerkBlueprint;                                     // 0x0228(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EItemRarity>                           PerkLevelRarity;                                   // 0x0258(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPerkLevelText>                 PerkLevelTunables;                                 // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   PerkLevel1Description;                             // 0x0278(0x0018)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
	class FText                                   PerkLevel2Description;                             // 0x0290(0x0018)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
	class FText                                   PerkLevel3Description;                             // 0x02A8(0x0018)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
	TArray<class FString>                         AtlantaActivatableInteractionIDs;                  // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          AtlantaLowPriority;                                // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerkProperties) == 0x000008, "Wrong alignment on FPerkProperties");
static_assert(sizeof(FPerkProperties) == 0x0002D8, "Wrong size on FPerkProperties");
static_assert(offsetof(FPerkProperties, Tags) == 0x0001E8, "Member 'FPerkProperties::Tags' has a wrong offset!");
static_assert(offsetof(FPerkProperties, Effects) == 0x0001F8, "Member 'FPerkProperties::Effects' has a wrong offset!");
static_assert(offsetof(FPerkProperties, AssociatedPlayerIndex) == 0x000208, "Member 'FPerkProperties::AssociatedPlayerIndex' has a wrong offset!");
static_assert(offsetof(FPerkProperties, MandatoryOnBloodweblevel) == 0x00020C, "Member 'FPerkProperties::MandatoryOnBloodweblevel' has a wrong offset!");
static_assert(offsetof(FPerkProperties, TeachableOnBloodweblevel) == 0x000210, "Member 'FPerkProperties::TeachableOnBloodweblevel' has a wrong offset!");
static_assert(offsetof(FPerkProperties, AtlantaTeachableLevel) == 0x000214, "Member 'FPerkProperties::AtlantaTeachableLevel' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkCategory) == 0x000218, "Member 'FPerkProperties::PerkCategory' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkBlueprint) == 0x000228, "Member 'FPerkProperties::PerkBlueprint' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkLevelRarity) == 0x000258, "Member 'FPerkProperties::PerkLevelRarity' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkLevelTunables) == 0x000268, "Member 'FPerkProperties::PerkLevelTunables' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkLevel1Description) == 0x000278, "Member 'FPerkProperties::PerkLevel1Description' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkLevel2Description) == 0x000290, "Member 'FPerkProperties::PerkLevel2Description' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkLevel3Description) == 0x0002A8, "Member 'FPerkProperties::PerkLevel3Description' has a wrong offset!");
static_assert(offsetof(FPerkProperties, AtlantaActivatableInteractionIDs) == 0x0002C0, "Member 'FPerkProperties::AtlantaActivatableInteractionIDs' has a wrong offset!");
static_assert(offsetof(FPerkProperties, AtlantaLowPriority) == 0x0002D0, "Member 'FPerkProperties::AtlantaLowPriority' has a wrong offset!");

// ScriptStruct DeadByDaylight.NodeContentDistributionValue
// 0x0058 (0x0060 - 0x0008)
struct FNodeContentDistributionValue final : public FDBDTableRowBase
{
public:
	int32                                         Empty_Weight;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Empty_MinCount;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Empty_MaxCount;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Perks_Weight;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Perks_MinCount;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Perks_MaxCount;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPacks_Weight;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPacks_MinCount;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPacks_MaxCount;                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Offerings_Weight;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Offerings_MinCount;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Offerings_MaxCount;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Items_Weight;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Items_MinCount;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Items_MaxCount;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOn_Weight;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOn_MinCount;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOn_MaxCount;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chests_Weight;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chests_MinCount;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chests_MaxCount;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNodeContentDistributionValue) == 0x000008, "Wrong alignment on FNodeContentDistributionValue");
static_assert(sizeof(FNodeContentDistributionValue) == 0x000060, "Wrong size on FNodeContentDistributionValue");
static_assert(offsetof(FNodeContentDistributionValue, Empty_Weight) == 0x000008, "Member 'FNodeContentDistributionValue::Empty_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Empty_MinCount) == 0x00000C, "Member 'FNodeContentDistributionValue::Empty_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Empty_MaxCount) == 0x000010, "Member 'FNodeContentDistributionValue::Empty_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Perks_Weight) == 0x000014, "Member 'FNodeContentDistributionValue::Perks_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Perks_MinCount) == 0x000018, "Member 'FNodeContentDistributionValue::Perks_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Perks_MaxCount) == 0x00001C, "Member 'FNodeContentDistributionValue::Perks_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, PerksPacks_Weight) == 0x000020, "Member 'FNodeContentDistributionValue::PerksPacks_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, PerksPacks_MinCount) == 0x000024, "Member 'FNodeContentDistributionValue::PerksPacks_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, PerksPacks_MaxCount) == 0x000028, "Member 'FNodeContentDistributionValue::PerksPacks_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Offerings_Weight) == 0x00002C, "Member 'FNodeContentDistributionValue::Offerings_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Offerings_MinCount) == 0x000030, "Member 'FNodeContentDistributionValue::Offerings_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Offerings_MaxCount) == 0x000034, "Member 'FNodeContentDistributionValue::Offerings_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Items_Weight) == 0x000038, "Member 'FNodeContentDistributionValue::Items_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Items_MinCount) == 0x00003C, "Member 'FNodeContentDistributionValue::Items_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Items_MaxCount) == 0x000040, "Member 'FNodeContentDistributionValue::Items_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, AddOn_Weight) == 0x000044, "Member 'FNodeContentDistributionValue::AddOn_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, AddOn_MinCount) == 0x000048, "Member 'FNodeContentDistributionValue::AddOn_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, AddOn_MaxCount) == 0x00004C, "Member 'FNodeContentDistributionValue::AddOn_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Chests_Weight) == 0x000050, "Member 'FNodeContentDistributionValue::Chests_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Chests_MinCount) == 0x000054, "Member 'FNodeContentDistributionValue::Chests_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Chests_MaxCount) == 0x000058, "Member 'FNodeContentDistributionValue::Chests_MaxCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.TypeFoliageToAutomateDensity
// 0x0068 (0x0068 - 0x0000)
struct FTypeFoliageToAutomateDensity final
{
public:
	TSoftObjectPtr<class UStaticMesh>             SourceMesh;                                        // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             ReplacementMesh;                                   // 0x0030(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateOverlaps;                                 // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceiveDecals;                                    // 0x0061(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECanBeCharacterBase                           bCanCharacterStepOn;                               // 0x0062(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetailMode                                   DetailMode;                                        // 0x0063(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumFoliageRadius;                              // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTypeFoliageToAutomateDensity) == 0x000008, "Wrong alignment on FTypeFoliageToAutomateDensity");
static_assert(sizeof(FTypeFoliageToAutomateDensity) == 0x000068, "Wrong size on FTypeFoliageToAutomateDensity");
static_assert(offsetof(FTypeFoliageToAutomateDensity, SourceMesh) == 0x000000, "Member 'FTypeFoliageToAutomateDensity::SourceMesh' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, ReplacementMesh) == 0x000030, "Member 'FTypeFoliageToAutomateDensity::ReplacementMesh' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, bGenerateOverlaps) == 0x000060, "Member 'FTypeFoliageToAutomateDensity::bGenerateOverlaps' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, bReceiveDecals) == 0x000061, "Member 'FTypeFoliageToAutomateDensity::bReceiveDecals' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, bCanCharacterStepOn) == 0x000062, "Member 'FTypeFoliageToAutomateDensity::bCanCharacterStepOn' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, DetailMode) == 0x000063, "Member 'FTypeFoliageToAutomateDensity::DetailMode' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, MinimumFoliageRadius) == 0x000064, "Member 'FTypeFoliageToAutomateDensity::MinimumFoliageRadius' has a wrong offset!");

// ScriptStruct DeadByDaylight.LevelReadyToPlayRequirements
// 0x0010 (0x0010 - 0x0000)
struct FLevelReadyToPlayRequirements final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         perkCount;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         itemCount;                                         // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         addonCount;                                        // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelReadyToPlayRequirements) == 0x000008, "Wrong alignment on FLevelReadyToPlayRequirements");
static_assert(sizeof(FLevelReadyToPlayRequirements) == 0x000010, "Wrong size on FLevelReadyToPlayRequirements");
static_assert(offsetof(FLevelReadyToPlayRequirements, player) == 0x000000, "Member 'FLevelReadyToPlayRequirements::player' has a wrong offset!");
static_assert(offsetof(FLevelReadyToPlayRequirements, perkCount) == 0x000008, "Member 'FLevelReadyToPlayRequirements::perkCount' has a wrong offset!");
static_assert(offsetof(FLevelReadyToPlayRequirements, itemCount) == 0x000009, "Member 'FLevelReadyToPlayRequirements::itemCount' has a wrong offset!");
static_assert(offsetof(FLevelReadyToPlayRequirements, addonCount) == 0x00000A, "Member 'FLevelReadyToPlayRequirements::addonCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutlineConfig
// 0x0010 (0x0010 - 0x0000)
struct FOutlineConfig final
{
public:
	TArray<TSoftObjectPtr<class UMaterialInterface>> TranslucencyMaterials;                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutlineConfig) == 0x000008, "Wrong alignment on FOutlineConfig");
static_assert(sizeof(FOutlineConfig) == 0x000010, "Wrong size on FOutlineConfig");
static_assert(offsetof(FOutlineConfig, TranslucencyMaterials) == 0x000000, "Member 'FOutlineConfig::TranslucencyMaterials' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutlineColourConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FOutlineColourConfiguration final
{
public:
	struct FLinearColor                           ColourValue;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutlineColourConfiguration) == 0x000004, "Wrong alignment on FOutlineColourConfiguration");
static_assert(sizeof(FOutlineColourConfiguration) == 0x000010, "Wrong size on FOutlineColourConfiguration");
static_assert(offsetof(FOutlineColourConfiguration, ColourValue) == 0x000000, "Member 'FOutlineColourConfiguration::ColourValue' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDOutlineRenderStrategySelector
// 0x0040 (0x0040 - 0x0000)
struct FDBDOutlineRenderStrategySelector final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _actorForStrategy;                                 // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseOutlineRenderStrategy*             _selectedStrategy;                                 // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x28];                                      // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDBDOutlineRenderStrategySelector) == 0x000008, "Wrong alignment on FDBDOutlineRenderStrategySelector");
static_assert(sizeof(FDBDOutlineRenderStrategySelector) == 0x000040, "Wrong size on FDBDOutlineRenderStrategySelector");
static_assert(offsetof(FDBDOutlineRenderStrategySelector, _actorForStrategy) == 0x000008, "Member 'FDBDOutlineRenderStrategySelector::_actorForStrategy' has a wrong offset!");
static_assert(offsetof(FDBDOutlineRenderStrategySelector, _selectedStrategy) == 0x000010, "Member 'FDBDOutlineRenderStrategySelector::_selectedStrategy' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerReadyStatusData
// 0x000C (0x000C - 0x0000)
struct FPlayerReadyStatusData final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReady;                                           // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasher;                                         // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocalPlayer;                                     // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerReadyStatusData) == 0x000004, "Wrong alignment on FPlayerReadyStatusData");
static_assert(sizeof(FPlayerReadyStatusData) == 0x00000C, "Wrong size on FPlayerReadyStatusData");
static_assert(offsetof(FPlayerReadyStatusData, PlayerId) == 0x000000, "Member 'FPlayerReadyStatusData::PlayerId' has a wrong offset!");
static_assert(offsetof(FPlayerReadyStatusData, SlotIndex) == 0x000004, "Member 'FPlayerReadyStatusData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FPlayerReadyStatusData, IsReady) == 0x000008, "Member 'FPlayerReadyStatusData::IsReady' has a wrong offset!");
static_assert(offsetof(FPlayerReadyStatusData, IsSlasher) == 0x000009, "Member 'FPlayerReadyStatusData::IsSlasher' has a wrong offset!");
static_assert(offsetof(FPlayerReadyStatusData, IsLocalPlayer) == 0x00000A, "Member 'FPlayerReadyStatusData::IsLocalPlayer' has a wrong offset!");

// ScriptStruct DeadByDaylight.GamePersistentData
// 0x0108 (0x0108 - 0x0000)
struct FGamePersistentData final
{
public:
	int32                                         PlayerCount;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpectatorCount;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGamePresetData                        GamePresetData;                                    // 0x0008(0x0090)(NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x70];                                      // 0x0098(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGamePersistentData) == 0x000008, "Wrong alignment on FGamePersistentData");
static_assert(sizeof(FGamePersistentData) == 0x000108, "Wrong size on FGamePersistentData");
static_assert(offsetof(FGamePersistentData, PlayerCount) == 0x000000, "Member 'FGamePersistentData::PlayerCount' has a wrong offset!");
static_assert(offsetof(FGamePersistentData, SpectatorCount) == 0x000004, "Member 'FGamePersistentData::SpectatorCount' has a wrong offset!");
static_assert(offsetof(FGamePersistentData, GamePresetData) == 0x000008, "Member 'FGamePersistentData::GamePresetData' has a wrong offset!");

// ScriptStruct DeadByDaylight.SessionInfos
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FSessionInfos final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSessionInfos) == 0x000008, "Wrong alignment on FSessionInfos");
static_assert(sizeof(FSessionInfos) == 0x000048, "Wrong size on FSessionInfos");

// ScriptStruct DeadByDaylight.AnimData
// 0x0001 (0x0001 - 0x0000)
struct FAnimData final
{
public:
	ECharacterStance                              Stance;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimData) == 0x000001, "Wrong alignment on FAnimData");
static_assert(sizeof(FAnimData) == 0x000001, "Wrong size on FAnimData");
static_assert(offsetof(FAnimData, Stance) == 0x000000, "Member 'FAnimData::Stance' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDRecentGameplayEvents
// 0x0050 (0x0050 - 0x0000)
struct FDBDRecentGameplayEvents final
{
public:
	TMap<EDBDScoreTypes, struct FDateTime>        _recentGameplayEvents;                             // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDBDRecentGameplayEvents) == 0x000008, "Wrong alignment on FDBDRecentGameplayEvents");
static_assert(sizeof(FDBDRecentGameplayEvents) == 0x000050, "Wrong size on FDBDRecentGameplayEvents");
static_assert(offsetof(FDBDRecentGameplayEvents, _recentGameplayEvents) == 0x000000, "Member 'FDBDRecentGameplayEvents::_recentGameplayEvents' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerFinishStats
// 0x0001 (0x0001 - 0x0000)
struct FPlayerFinishStats final
{
public:
	int8                                          NumberOfSurvivorsKilled;                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerFinishStats) == 0x000001, "Wrong alignment on FPlayerFinishStats");
static_assert(sizeof(FPlayerFinishStats) == 0x000001, "Wrong size on FPlayerFinishStats");
static_assert(offsetof(FPlayerFinishStats, NumberOfSurvivorsKilled) == 0x000000, "Member 'FPlayerFinishStats::NumberOfSurvivorsKilled' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoadoutSlotUnlockLevelValue
// 0x0008 (0x0010 - 0x0008)
struct FLoadoutSlotUnlockLevelValue final : public FDBDTableRowBase
{
public:
	ELoadoutSlot                                  LoadoutSlot;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BloodwebLevel;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadoutSlotUnlockLevelValue) == 0x000008, "Wrong alignment on FLoadoutSlotUnlockLevelValue");
static_assert(sizeof(FLoadoutSlotUnlockLevelValue) == 0x000010, "Wrong size on FLoadoutSlotUnlockLevelValue");
static_assert(offsetof(FLoadoutSlotUnlockLevelValue, LoadoutSlot) == 0x000008, "Member 'FLoadoutSlotUnlockLevelValue::LoadoutSlot' has a wrong offset!");
static_assert(offsetof(FLoadoutSlotUnlockLevelValue, BloodwebLevel) == 0x00000C, "Member 'FLoadoutSlotUnlockLevelValue::BloodwebLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.LookInputScalingData
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FLookInputScalingData final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLookInputScalingData) == 0x000008, "Wrong alignment on FLookInputScalingData");
static_assert(sizeof(FLookInputScalingData) == 0x000080, "Wrong size on FLookInputScalingData");

// ScriptStruct DeadByDaylight.LookInputAxisScalingData
// 0x0040 (0x0040 - 0x0000)
struct FLookInputAxisScalingData final
{
public:
	struct FDBDTimer                              ScalingTimer;                                      // 0x0000(0x0028)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLookInputAxisScalingData) == 0x000008, "Wrong alignment on FLookInputAxisScalingData");
static_assert(sizeof(FLookInputAxisScalingData) == 0x000040, "Wrong size on FLookInputAxisScalingData");
static_assert(offsetof(FLookInputAxisScalingData, ScalingTimer) == 0x000000, "Member 'FLookInputAxisScalingData::ScalingTimer' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerSavedProfileDataShared
// 0x0068 (0x0068 - 0x0000)
struct FPlayerSavedProfileDataShared final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedCamperIndex;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSlasherIndex;                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquippedPlayerCustomization           SelectedCharacterCustomization;                    // 0x0018(0x0038)(NativeAccessSpecifierPublic)
	int32                                         CamperStreak;                                      // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowPortraitBorder;                                // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasActiveSubscription;                             // 0x0055(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformId;                                        // 0x0058(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPlayerSavedProfileDataShared) == 0x000008, "Wrong alignment on FPlayerSavedProfileDataShared");
static_assert(sizeof(FPlayerSavedProfileDataShared) == 0x000068, "Wrong size on FPlayerSavedProfileDataShared");
static_assert(offsetof(FPlayerSavedProfileDataShared, PlayerName) == 0x000000, "Member 'FPlayerSavedProfileDataShared::PlayerName' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, SelectedCamperIndex) == 0x000010, "Member 'FPlayerSavedProfileDataShared::SelectedCamperIndex' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, SelectedSlasherIndex) == 0x000014, "Member 'FPlayerSavedProfileDataShared::SelectedSlasherIndex' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, SelectedCharacterCustomization) == 0x000018, "Member 'FPlayerSavedProfileDataShared::SelectedCharacterCustomization' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, CamperStreak) == 0x000050, "Member 'FPlayerSavedProfileDataShared::CamperStreak' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, ShowPortraitBorder) == 0x000054, "Member 'FPlayerSavedProfileDataShared::ShowPortraitBorder' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, HasActiveSubscription) == 0x000055, "Member 'FPlayerSavedProfileDataShared::HasActiveSubscription' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, PlatformId) == 0x000058, "Member 'FPlayerSavedProfileDataShared::PlatformId' has a wrong offset!");

// ScriptStruct DeadByDaylight.UIViewFlagSaveData
// 0x0050 (0x0050 - 0x0000)
struct FUIViewFlagSaveData final
{
public:
	TMap<class FString, bool>                     CharactersFirstBloodweb;                           // 0x0000(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUIViewFlagSaveData) == 0x000008, "Wrong alignment on FUIViewFlagSaveData");
static_assert(sizeof(FUIViewFlagSaveData) == 0x000050, "Wrong size on FUIViewFlagSaveData");
static_assert(offsetof(FUIViewFlagSaveData, CharactersFirstBloodweb) == 0x000000, "Member 'FUIViewFlagSaveData::CharactersFirstBloodweb' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerSavedProfileCumulativeData
// 0x0038 (0x0038 - 0x0000)
struct FPlayerSavedProfileCumulativeData final
{
public:
	bool                                          FirstTimePlaying;                                  // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CumulativeMatches;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivor;                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKiller;                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivorNoFriends;              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKillerNoFriends;                // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastMatchTimestamp;                                // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastSessionTimestamp;                              // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeSessions;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              CumulativePlaytime;                                // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSavedProfileCumulativeData) == 0x000008, "Wrong alignment on FPlayerSavedProfileCumulativeData");
static_assert(sizeof(FPlayerSavedProfileCumulativeData) == 0x000038, "Wrong size on FPlayerSavedProfileCumulativeData");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, FirstTimePlaying) == 0x000000, "Member 'FPlayerSavedProfileCumulativeData::FirstTimePlaying' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatches) == 0x000004, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatches' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesAsSurvivor) == 0x000008, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesAsSurvivor' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesAsKiller) == 0x00000C, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesAsKiller' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesAsSurvivorNoFriends) == 0x000010, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesAsSurvivorNoFriends' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesAsKillerNoFriends) == 0x000014, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesAsKillerNoFriends' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, LastMatchTimestamp) == 0x000018, "Member 'FPlayerSavedProfileCumulativeData::LastMatchTimestamp' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, LastSessionTimestamp) == 0x000020, "Member 'FPlayerSavedProfileCumulativeData::LastSessionTimestamp' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeSessions) == 0x000028, "Member 'FPlayerSavedProfileCumulativeData::CumulativeSessions' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativePlaytime) == 0x000030, "Member 'FPlayerSavedProfileCumulativeData::CumulativePlaytime' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventSavedData
// 0x0002 (0x0002 - 0x0000)
struct FSpecialEventSavedData final
{
public:
	bool                                          EventEntryScreenOpened;                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EventSplashScreenSeen;                             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventSavedData) == 0x000001, "Wrong alignment on FSpecialEventSavedData");
static_assert(sizeof(FSpecialEventSavedData) == 0x000002, "Wrong size on FSpecialEventSavedData");
static_assert(offsetof(FSpecialEventSavedData, EventEntryScreenOpened) == 0x000000, "Member 'FSpecialEventSavedData::EventEntryScreenOpened' has a wrong offset!");
static_assert(offsetof(FSpecialEventSavedData, EventSplashScreenSeen) == 0x000001, "Member 'FSpecialEventSavedData::EventSplashScreenSeen' has a wrong offset!");

// ScriptStruct DeadByDaylight.ReleaseSavedData
// 0x0001 (0x0001 - 0x0000)
struct FReleaseSavedData final
{
public:
	bool                                          NewChapterPopupSeen;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReleaseSavedData) == 0x000001, "Wrong alignment on FReleaseSavedData");
static_assert(sizeof(FReleaseSavedData) == 0x000001, "Wrong size on FReleaseSavedData");
static_assert(offsetof(FReleaseSavedData, NewChapterPopupSeen) == 0x000000, "Member 'FReleaseSavedData::NewChapterPopupSeen' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerSavedProfileDataLocal
// 0x04C0 (0x04C0 - 0x0000)
struct FPlayerSavedProfileDataLocal final
{
public:
	int32                                         Tokens;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Offerings;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       PageVisited;                                       // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       ChatVisible;                                       // 0x0068(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       OnboardingCompleted;                               // 0x00B8(0x0050)(NativeAccessSpecifierPublic)
	int32                                         ConsecutiveMatchStreak;                            // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wins;                                              // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Losses;                                            // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        CurrentSeasonTicks;                                // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDailyRitualSaveData                   DailyRitualSaveData;                               // 0x0120(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FUIViewFlagSaveData                    UIViewFlags;                                       // 0x0128(0x0050)(NativeAccessSpecifierPublic)
	struct FFearMarketOfferingInstance            FearMarket;                                        // 0x0178(0x0020)(NativeAccessSpecifierPublic)
	struct FPlayerLoadoutData                     LastConnectedLoadout;                              // 0x0198(0x0098)(NativeAccessSpecifierPublic)
	int32                                         LastConnectedCharacterIndex;                       // 0x0230(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DisconnectPenaltyTime;                             // 0x0238(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastMatchEndTime;                                  // 0x0240(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastMatchStartTime;                                // 0x0248(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastKillerMatchEndTime;                            // 0x0250(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastSurvivorMatchEndTime;                          // 0x0258(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBloodWebPersistentData                BloodStoreKillers;                                 // 0x0260(0x0050)(NativeAccessSpecifierPublic)
	struct FBloodWebPersistentData                BloodStoreSurvivors;                               // 0x02B0(0x0050)(NativeAccessSpecifierPublic)
	bool                                          CrossplayAllowed;                                  // 0x0300(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDeclineFriendInvites;                          // 0x0301(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302[0x6];                                      // 0x0302(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterCustomizationPresetsList> CharacterCustomizationPresets;                 // 0x0308(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterLoadoutPresetsList>   CharacterLoadoutPresets;                           // 0x0318(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPlayerSavedProfileCumulativeData      _cumulativeData;                                   // 0x0328(0x0038)(NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FSavedStatsData>                _savedPlayerStats;                                 // 0x0360(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _hasBeenGivenKillerTutorialEndReward;              // 0x0370(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasBeenGivenSurvivorTutorialEndReward;            // 0x0371(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasSeenBloodpointsOnboardingCurrencyPopup;        // 0x0372(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasSeenAuricCellsOnboardingCurrencyPopup;         // 0x0373(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasSeenIridescentShardsOnboardingCurrencyPopup;   // 0x0374(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasSeenLightSensitivity;                          // 0x0375(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_376[0x2];                                      // 0x0376(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FCharacterSavedProfileData> _characterData;                                   // 0x0378(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FSpecialEventSavedData> _specialEvent;                                  // 0x03C8(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class FName>                             _seenCinematics;                                   // 0x0418(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FString, struct FReleaseSavedData> _releases;                                         // 0x0468(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          _hasBeginnerTooltipsBeenDisabledAtLevel;           // 0x04B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerSavedProfileDataLocal) == 0x000008, "Wrong alignment on FPlayerSavedProfileDataLocal");
static_assert(sizeof(FPlayerSavedProfileDataLocal) == 0x0004C0, "Wrong size on FPlayerSavedProfileDataLocal");
static_assert(offsetof(FPlayerSavedProfileDataLocal, Tokens) == 0x000000, "Member 'FPlayerSavedProfileDataLocal::Tokens' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, Offerings) == 0x000008, "Member 'FPlayerSavedProfileDataLocal::Offerings' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, PageVisited) == 0x000018, "Member 'FPlayerSavedProfileDataLocal::PageVisited' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, ChatVisible) == 0x000068, "Member 'FPlayerSavedProfileDataLocal::ChatVisible' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, OnboardingCompleted) == 0x0000B8, "Member 'FPlayerSavedProfileDataLocal::OnboardingCompleted' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, ConsecutiveMatchStreak) == 0x000108, "Member 'FPlayerSavedProfileDataLocal::ConsecutiveMatchStreak' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, Wins) == 0x00010C, "Member 'FPlayerSavedProfileDataLocal::Wins' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, Losses) == 0x000110, "Member 'FPlayerSavedProfileDataLocal::Losses' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, CurrentSeasonTicks) == 0x000118, "Member 'FPlayerSavedProfileDataLocal::CurrentSeasonTicks' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, DailyRitualSaveData) == 0x000120, "Member 'FPlayerSavedProfileDataLocal::DailyRitualSaveData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, UIViewFlags) == 0x000128, "Member 'FPlayerSavedProfileDataLocal::UIViewFlags' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, FearMarket) == 0x000178, "Member 'FPlayerSavedProfileDataLocal::FearMarket' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastConnectedLoadout) == 0x000198, "Member 'FPlayerSavedProfileDataLocal::LastConnectedLoadout' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastConnectedCharacterIndex) == 0x000230, "Member 'FPlayerSavedProfileDataLocal::LastConnectedCharacterIndex' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, DisconnectPenaltyTime) == 0x000238, "Member 'FPlayerSavedProfileDataLocal::DisconnectPenaltyTime' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastMatchEndTime) == 0x000240, "Member 'FPlayerSavedProfileDataLocal::LastMatchEndTime' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastMatchStartTime) == 0x000248, "Member 'FPlayerSavedProfileDataLocal::LastMatchStartTime' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastKillerMatchEndTime) == 0x000250, "Member 'FPlayerSavedProfileDataLocal::LastKillerMatchEndTime' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastSurvivorMatchEndTime) == 0x000258, "Member 'FPlayerSavedProfileDataLocal::LastSurvivorMatchEndTime' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, BloodStoreKillers) == 0x000260, "Member 'FPlayerSavedProfileDataLocal::BloodStoreKillers' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, BloodStoreSurvivors) == 0x0002B0, "Member 'FPlayerSavedProfileDataLocal::BloodStoreSurvivors' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, CrossplayAllowed) == 0x000300, "Member 'FPlayerSavedProfileDataLocal::CrossplayAllowed' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, AutoDeclineFriendInvites) == 0x000301, "Member 'FPlayerSavedProfileDataLocal::AutoDeclineFriendInvites' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, CharacterCustomizationPresets) == 0x000308, "Member 'FPlayerSavedProfileDataLocal::CharacterCustomizationPresets' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, CharacterLoadoutPresets) == 0x000318, "Member 'FPlayerSavedProfileDataLocal::CharacterLoadoutPresets' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _cumulativeData) == 0x000328, "Member 'FPlayerSavedProfileDataLocal::_cumulativeData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _savedPlayerStats) == 0x000360, "Member 'FPlayerSavedProfileDataLocal::_savedPlayerStats' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasBeenGivenKillerTutorialEndReward) == 0x000370, "Member 'FPlayerSavedProfileDataLocal::_hasBeenGivenKillerTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasBeenGivenSurvivorTutorialEndReward) == 0x000371, "Member 'FPlayerSavedProfileDataLocal::_hasBeenGivenSurvivorTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasSeenBloodpointsOnboardingCurrencyPopup) == 0x000372, "Member 'FPlayerSavedProfileDataLocal::_hasSeenBloodpointsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasSeenAuricCellsOnboardingCurrencyPopup) == 0x000373, "Member 'FPlayerSavedProfileDataLocal::_hasSeenAuricCellsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasSeenIridescentShardsOnboardingCurrencyPopup) == 0x000374, "Member 'FPlayerSavedProfileDataLocal::_hasSeenIridescentShardsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasSeenLightSensitivity) == 0x000375, "Member 'FPlayerSavedProfileDataLocal::_hasSeenLightSensitivity' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _characterData) == 0x000378, "Member 'FPlayerSavedProfileDataLocal::_characterData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _specialEvent) == 0x0003C8, "Member 'FPlayerSavedProfileDataLocal::_specialEvent' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _seenCinematics) == 0x000418, "Member 'FPlayerSavedProfileDataLocal::_seenCinematics' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _releases) == 0x000468, "Member 'FPlayerSavedProfileDataLocal::_releases' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasBeginnerTooltipsBeenDisabledAtLevel) == 0x0004B8, "Member 'FPlayerSavedProfileDataLocal::_hasBeginnerTooltipsBeenDisabledAtLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerSavedProfileData
// 0x0608 (0x0608 - 0x0000)
struct FPlayerSavedProfileData final
{
public:
	class FString                                 PlayerUID;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerSavedProfileDataShared          SharedData;                                        // 0x0010(0x0068)(NativeAccessSpecifierPublic)
	struct FPlayerSavedProfileDataLocal           LocalData;                                         // 0x0078(0x04C0)(NativeAccessSpecifierPublic)
	struct FConsoleUserSettings                   ConsoleUserSettings;                               // 0x0538(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSavedProfileData) == 0x000008, "Wrong alignment on FPlayerSavedProfileData");
static_assert(sizeof(FPlayerSavedProfileData) == 0x000608, "Wrong size on FPlayerSavedProfileData");
static_assert(offsetof(FPlayerSavedProfileData, PlayerUID) == 0x000000, "Member 'FPlayerSavedProfileData::PlayerUID' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileData, SharedData) == 0x000010, "Member 'FPlayerSavedProfileData::SharedData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileData, LocalData) == 0x000078, "Member 'FPlayerSavedProfileData::LocalData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileData, ConsoleUserSettings) == 0x000538, "Member 'FPlayerSavedProfileData::ConsoleUserSettings' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerPersistentData
// 0x0828 (0x0828 - 0x0000)
struct FPlayerPersistentData final
{
public:
	EPlayerRole                                   GameRole;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerLoadoutData                     StartingLoadout;                                   // 0x0008(0x0098)(Transient, NativeAccessSpecifierPublic)
	struct FPlayerLoadoutData                     CurrentLoadout;                                    // 0x00A0(0x0098)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x98];                                     // 0x0138(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerSavedProfileData                SavedData;                                         // 0x01D0(0x0608)(NativeAccessSpecifierPublic)
	EPlatformFlag                                 PlayerPlatform;                                    // 0x07D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProviderFlag                                 PlayerProvider;                                    // 0x07DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E0[0x48];                                     // 0x07E0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerPersistentData) == 0x000008, "Wrong alignment on FPlayerPersistentData");
static_assert(sizeof(FPlayerPersistentData) == 0x000828, "Wrong size on FPlayerPersistentData");
static_assert(offsetof(FPlayerPersistentData, GameRole) == 0x000000, "Member 'FPlayerPersistentData::GameRole' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, StartingLoadout) == 0x000008, "Member 'FPlayerPersistentData::StartingLoadout' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, CurrentLoadout) == 0x0000A0, "Member 'FPlayerPersistentData::CurrentLoadout' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, SavedData) == 0x0001D0, "Member 'FPlayerPersistentData::SavedData' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, PlayerPlatform) == 0x0007D8, "Member 'FPlayerPersistentData::PlayerPlatform' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, PlayerProvider) == 0x0007DC, "Member 'FPlayerPersistentData::PlayerProvider' has a wrong offset!");

// ScriptStruct DeadByDaylight.PrestigeIconData
// 0x0038 (0x0040 - 0x0008)
struct FPrestigeIconData final : public FDBDTableRowBase
{
public:
	EPlayerRole                                   PlayerRole;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PrestigeLevel;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0010(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrestigeIconData) == 0x000008, "Wrong alignment on FPrestigeIconData");
static_assert(sizeof(FPrestigeIconData) == 0x000040, "Wrong size on FPrestigeIconData");
static_assert(offsetof(FPrestigeIconData, PlayerRole) == 0x000008, "Member 'FPrestigeIconData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FPrestigeIconData, PrestigeLevel) == 0x00000C, "Member 'FPrestigeIconData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FPrestigeIconData, Icon) == 0x000010, "Member 'FPrestigeIconData::Icon' has a wrong offset!");

// ScriptStruct DeadByDaylight.SectionLenghtsProperties
// 0x0008 (0x0008 - 0x0000)
struct FSectionLenghtsProperties final
{
public:
	EDirection                                    Direction;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Length;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSectionLenghtsProperties) == 0x000004, "Wrong alignment on FSectionLenghtsProperties");
static_assert(sizeof(FSectionLenghtsProperties) == 0x000008, "Wrong size on FSectionLenghtsProperties");
static_assert(offsetof(FSectionLenghtsProperties, Direction) == 0x000000, "Member 'FSectionLenghtsProperties::Direction' has a wrong offset!");
static_assert(offsetof(FSectionLenghtsProperties, Length) == 0x000004, "Member 'FSectionLenghtsProperties::Length' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuadrantSpawnTypeProperties
// 0x0018 (0x0018 - 0x0000)
struct FQuadrantSpawnTypeProperties final
{
public:
	EQuadrantSpawnType                            QuadrantSpawnType;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSectionLenghtsProperties>      SectionLenghts;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuadrantSpawnTypeProperties) == 0x000008, "Wrong alignment on FQuadrantSpawnTypeProperties");
static_assert(sizeof(FQuadrantSpawnTypeProperties) == 0x000018, "Wrong size on FQuadrantSpawnTypeProperties");
static_assert(offsetof(FQuadrantSpawnTypeProperties, QuadrantSpawnType) == 0x000000, "Member 'FQuadrantSpawnTypeProperties::QuadrantSpawnType' has a wrong offset!");
static_assert(offsetof(FQuadrantSpawnTypeProperties, SectionLenghts) == 0x000008, "Member 'FQuadrantSpawnTypeProperties::SectionLenghts' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3BeginnerTutorialLevelConfig
// 0x0008 (0x0008 - 0x0000)
struct FS3BeginnerTutorialLevelConfig final
{
public:
	int32                                         LevelToHideTutorial;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeToHideTutorial;                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3BeginnerTutorialLevelConfig) == 0x000004, "Wrong alignment on FS3BeginnerTutorialLevelConfig");
static_assert(sizeof(FS3BeginnerTutorialLevelConfig) == 0x000008, "Wrong size on FS3BeginnerTutorialLevelConfig");
static_assert(offsetof(FS3BeginnerTutorialLevelConfig, LevelToHideTutorial) == 0x000000, "Member 'FS3BeginnerTutorialLevelConfig::LevelToHideTutorial' has a wrong offset!");
static_assert(offsetof(FS3BeginnerTutorialLevelConfig, PrestigeToHideTutorial) == 0x000004, "Member 'FS3BeginnerTutorialLevelConfig::PrestigeToHideTutorial' has a wrong offset!");

// ScriptStruct DeadByDaylight.TileProperties
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FTileProperties final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTileProperties) == 0x000008, "Wrong alignment on FTileProperties");
static_assert(sizeof(FTileProperties) == 0x000078, "Wrong size on FTileProperties");

// ScriptStruct DeadByDaylight.LoadingInfoData
// 0x0068 (0x0068 - 0x0000)
struct FLoadingInfoData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableForKiller;                              // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableForSurvivor;                            // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingInfoData) == 0x000008, "Wrong alignment on FLoadingInfoData");
static_assert(sizeof(FLoadingInfoData) == 0x000068, "Wrong size on FLoadingInfoData");
static_assert(offsetof(FLoadingInfoData, Title) == 0x000000, "Member 'FLoadingInfoData::Title' has a wrong offset!");
static_assert(offsetof(FLoadingInfoData, Description) == 0x000018, "Member 'FLoadingInfoData::Description' has a wrong offset!");
static_assert(offsetof(FLoadingInfoData, Icon) == 0x000030, "Member 'FLoadingInfoData::Icon' has a wrong offset!");
static_assert(offsetof(FLoadingInfoData, IsAvailableForKiller) == 0x000060, "Member 'FLoadingInfoData::IsAvailableForKiller' has a wrong offset!");
static_assert(offsetof(FLoadingInfoData, IsAvailableForSurvivor) == 0x000061, "Member 'FLoadingInfoData::IsAvailableForSurvivor' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterStateData
// 0x0020 (0x0020 - 0x0000)
struct FCharacterStateData final
{
public:
	int32                                         _pips;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _powerId;                                          // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _addonIds;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCharacterStateData) == 0x000008, "Wrong alignment on FCharacterStateData");
static_assert(sizeof(FCharacterStateData) == 0x000020, "Wrong size on FCharacterStateData");
static_assert(offsetof(FCharacterStateData, _pips) == 0x000000, "Member 'FCharacterStateData::_pips' has a wrong offset!");
static_assert(offsetof(FCharacterStateData, _powerId) == 0x000004, "Member 'FCharacterStateData::_powerId' has a wrong offset!");
static_assert(offsetof(FCharacterStateData, _addonIds) == 0x000010, "Member 'FCharacterStateData::_addonIds' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerClosetActorsTypes
// 0x0050 (0x0058 - 0x0008)
struct FKillerClosetActorsTypes final : public FDBDTableRowBase
{
public:
	struct FGameplayTag                           KillerPresenceTag;                                 // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ClosetActorClass;                                  // 0x0018(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketToSpawnOn;                                   // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillerClosetActorsTypes) == 0x000008, "Wrong alignment on FKillerClosetActorsTypes");
static_assert(sizeof(FKillerClosetActorsTypes) == 0x000058, "Wrong size on FKillerClosetActorsTypes");
static_assert(offsetof(FKillerClosetActorsTypes, KillerPresenceTag) == 0x000008, "Member 'FKillerClosetActorsTypes::KillerPresenceTag' has a wrong offset!");
static_assert(offsetof(FKillerClosetActorsTypes, ClosetActorClass) == 0x000018, "Member 'FKillerClosetActorsTypes::ClosetActorClass' has a wrong offset!");
static_assert(offsetof(FKillerClosetActorsTypes, SocketToSpawnOn) == 0x000048, "Member 'FKillerClosetActorsTypes::SocketToSpawnOn' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerStateData
// 0x0038 (0x0038 - 0x0000)
struct FPlayerStateData final
{
public:
	int32                                         CharacterLevel;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EquipedFavorId;                                    // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           EquipedPerkIds;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 EquipedPerkLevels;                                 // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EGameState                                    _playerGameState;                                  // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _prestigeLevel;                                    // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPlayerStateData) == 0x000008, "Wrong alignment on FPlayerStateData");
static_assert(sizeof(FPlayerStateData) == 0x000038, "Wrong size on FPlayerStateData");
static_assert(offsetof(FPlayerStateData, CharacterLevel) == 0x000000, "Member 'FPlayerStateData::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, EquipedFavorId) == 0x000004, "Member 'FPlayerStateData::EquipedFavorId' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, EquipedPerkIds) == 0x000010, "Member 'FPlayerStateData::EquipedPerkIds' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, EquipedPerkLevels) == 0x000020, "Member 'FPlayerStateData::EquipedPerkLevels' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, _playerGameState) == 0x000030, "Member 'FPlayerStateData::_playerGameState' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, _prestigeLevel) == 0x000034, "Member 'FPlayerStateData::_prestigeLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerDataSync
// 0x0090 (0x0090 - 0x0000)
struct FPlayerDataSync final
{
public:
	struct FPlayerStateData                       PlayerData;                                        // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	struct FEquippedPlayerCustomization           EquippedCustomization;                             // 0x0038(0x0038)(NativeAccessSpecifierPublic)
	class FName                                   EquipedItemId;                                     // 0x0070(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           EquipedItemAddonIds;                               // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataSync) == 0x000008, "Wrong alignment on FPlayerDataSync");
static_assert(sizeof(FPlayerDataSync) == 0x000090, "Wrong size on FPlayerDataSync");
static_assert(offsetof(FPlayerDataSync, PlayerData) == 0x000000, "Member 'FPlayerDataSync::PlayerData' has a wrong offset!");
static_assert(offsetof(FPlayerDataSync, EquippedCustomization) == 0x000038, "Member 'FPlayerDataSync::EquippedCustomization' has a wrong offset!");
static_assert(offsetof(FPlayerDataSync, EquipedItemId) == 0x000070, "Member 'FPlayerDataSync::EquipedItemId' has a wrong offset!");
static_assert(offsetof(FPlayerDataSync, EquipedItemAddonIds) == 0x000080, "Member 'FPlayerDataSync::EquipedItemAddonIds' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerHUDInfos
// 0x0058 (0x0060 - 0x0008)
struct FPlayerHUDInfos final : public FDBDTableRowBase
{
public:
	EPlayerRole                                   Role;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   HUDClass;                                          // 0x0010(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TouchInterfaceName;                                // 0x0040(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerHUDInfos) == 0x000008, "Wrong alignment on FPlayerHUDInfos");
static_assert(sizeof(FPlayerHUDInfos) == 0x000060, "Wrong size on FPlayerHUDInfos");
static_assert(offsetof(FPlayerHUDInfos, Role) == 0x000008, "Member 'FPlayerHUDInfos::Role' has a wrong offset!");
static_assert(offsetof(FPlayerHUDInfos, HUDClass) == 0x000010, "Member 'FPlayerHUDInfos::HUDClass' has a wrong offset!");
static_assert(offsetof(FPlayerHUDInfos, TouchInterfaceName) == 0x000040, "Member 'FPlayerHUDInfos::TouchInterfaceName' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlatformDlcData
// 0x00F0 (0x00F8 - 0x0008)
struct FPlatformDlcData final : public FDBDTableRowBase
{
public:
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UnlockDescription;                                 // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UISortOrder;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DlcIdSteam;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdEpic;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdDmm;                                          // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdPS4;                                          // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdXB1LegacyXDK;                                 // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcId_XB1_XSX_GDK;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdSwitch;                                       // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdGRDK;                                         // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdPS5;                                          // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdStadia;                                       // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdMobile;                                       // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPlatformDlcData) == 0x000008, "Wrong alignment on FPlatformDlcData");
static_assert(sizeof(FPlatformDlcData) == 0x0000F8, "Wrong size on FPlatformDlcData");
static_assert(offsetof(FPlatformDlcData, ID) == 0x000008, "Member 'FPlatformDlcData::ID' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, UnlockDescription) == 0x000018, "Member 'FPlatformDlcData::UnlockDescription' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, Description) == 0x000030, "Member 'FPlatformDlcData::Description' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, UISortOrder) == 0x000040, "Member 'FPlatformDlcData::UISortOrder' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdSteam) == 0x000048, "Member 'FPlatformDlcData::DlcIdSteam' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdEpic) == 0x000058, "Member 'FPlatformDlcData::DlcIdEpic' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdDmm) == 0x000068, "Member 'FPlatformDlcData::DlcIdDmm' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdPS4) == 0x000078, "Member 'FPlatformDlcData::DlcIdPS4' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdXB1LegacyXDK) == 0x000088, "Member 'FPlatformDlcData::DlcIdXB1LegacyXDK' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcId_XB1_XSX_GDK) == 0x000098, "Member 'FPlatformDlcData::DlcId_XB1_XSX_GDK' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdSwitch) == 0x0000A8, "Member 'FPlatformDlcData::DlcIdSwitch' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdGRDK) == 0x0000B8, "Member 'FPlatformDlcData::DlcIdGRDK' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdPS5) == 0x0000C8, "Member 'FPlatformDlcData::DlcIdPS5' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdStadia) == 0x0000D8, "Member 'FPlatformDlcData::DlcIdStadia' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdMobile) == 0x0000E8, "Member 'FPlatformDlcData::DlcIdMobile' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventItemsContentTypeUIData
// 0x0090 (0x0090 - 0x0000)
struct FEventItemsContentTypeUIData final
{
public:
	EEventItemContentType                         ContentType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedRemoveRarityBackground;                        // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDefaultRarityBackgroundColor;                   // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            DefaultRarityBackgroundColor;                      // 0x0008(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BackgroundTexture;                                 // 0x0030(0x0030)(Edit, DisableEditOnInstance, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              RarityBackgroundTexture;                           // 0x0060(0x0030)(Edit, DisableEditOnInstance, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventItemsContentTypeUIData) == 0x000008, "Wrong alignment on FEventItemsContentTypeUIData");
static_assert(sizeof(FEventItemsContentTypeUIData) == 0x000090, "Wrong size on FEventItemsContentTypeUIData");
static_assert(offsetof(FEventItemsContentTypeUIData, ContentType) == 0x000000, "Member 'FEventItemsContentTypeUIData::ContentType' has a wrong offset!");
static_assert(offsetof(FEventItemsContentTypeUIData, NeedRemoveRarityBackground) == 0x000001, "Member 'FEventItemsContentTypeUIData::NeedRemoveRarityBackground' has a wrong offset!");
static_assert(offsetof(FEventItemsContentTypeUIData, UseDefaultRarityBackgroundColor) == 0x000002, "Member 'FEventItemsContentTypeUIData::UseDefaultRarityBackgroundColor' has a wrong offset!");
static_assert(offsetof(FEventItemsContentTypeUIData, DefaultRarityBackgroundColor) == 0x000008, "Member 'FEventItemsContentTypeUIData::DefaultRarityBackgroundColor' has a wrong offset!");
static_assert(offsetof(FEventItemsContentTypeUIData, BackgroundTexture) == 0x000030, "Member 'FEventItemsContentTypeUIData::BackgroundTexture' has a wrong offset!");
static_assert(offsetof(FEventItemsContentTypeUIData, RarityBackgroundTexture) == 0x000060, "Member 'FEventItemsContentTypeUIData::RarityBackgroundTexture' has a wrong offset!");

// ScriptStruct DeadByDaylight.AttackSubstateRequestResult
// 0x0003 (0x0003 - 0x0000)
struct FAttackSubstateRequestResult final
{
public:
	bool                                          IsValid;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackSubstate                               RequestedNextSubstate;                             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackSubstate                               ServerNextSubstate;                                // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackSubstateRequestResult) == 0x000001, "Wrong alignment on FAttackSubstateRequestResult");
static_assert(sizeof(FAttackSubstateRequestResult) == 0x000003, "Wrong size on FAttackSubstateRequestResult");
static_assert(offsetof(FAttackSubstateRequestResult, IsValid) == 0x000000, "Member 'FAttackSubstateRequestResult::IsValid' has a wrong offset!");
static_assert(offsetof(FAttackSubstateRequestResult, RequestedNextSubstate) == 0x000001, "Member 'FAttackSubstateRequestResult::RequestedNextSubstate' has a wrong offset!");
static_assert(offsetof(FAttackSubstateRequestResult, ServerNextSubstate) == 0x000002, "Member 'FAttackSubstateRequestResult::ServerNextSubstate' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankResetStartingPips
// 0x0004 (0x0004 - 0x0000)
struct FRankResetStartingPips final
{
public:
	int32                                         NewPipAmount;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankResetStartingPips) == 0x000004, "Wrong alignment on FRankResetStartingPips");
static_assert(sizeof(FRankResetStartingPips) == 0x000004, "Wrong size on FRankResetStartingPips");
static_assert(offsetof(FRankResetStartingPips, NewPipAmount) == 0x000000, "Member 'FRankResetStartingPips::NewPipAmount' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankGroupDefinition
// 0x0018 (0x0018 - 0x0000)
struct FRankGroupDefinition final
{
public:
	int32                                         RankThreshold;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PipThresholds;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankGroupDefinition) == 0x000008, "Wrong alignment on FRankGroupDefinition");
static_assert(sizeof(FRankGroupDefinition) == 0x000018, "Wrong size on FRankGroupDefinition");
static_assert(offsetof(FRankGroupDefinition, RankThreshold) == 0x000000, "Member 'FRankGroupDefinition::RankThreshold' has a wrong offset!");
static_assert(offsetof(FRankGroupDefinition, PipThresholds) == 0x000008, "Member 'FRankGroupDefinition::PipThresholds' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankDefinition
// 0x0004 (0x0004 - 0x0000)
struct FRankDefinition final
{
public:
	int32                                         PipsRequired;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankDefinition) == 0x000004, "Wrong alignment on FRankDefinition");
static_assert(sizeof(FRankDefinition) == 0x000004, "Wrong size on FRankDefinition");
static_assert(offsetof(FRankDefinition, PipsRequired) == 0x000000, "Member 'FRankDefinition::PipsRequired' has a wrong offset!");

// ScriptStruct DeadByDaylight.KeyTupleBool
// 0x0010 (0x0010 - 0x0000)
struct FKeyTupleBool final
{
public:
	class FName                                   Key;                                               // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x000C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyTupleBool) == 0x000004, "Wrong alignment on FKeyTupleBool");
static_assert(sizeof(FKeyTupleBool) == 0x000010, "Wrong size on FKeyTupleBool");
static_assert(offsetof(FKeyTupleBool, Key) == 0x000000, "Member 'FKeyTupleBool::Key' has a wrong offset!");
static_assert(offsetof(FKeyTupleBool, Value) == 0x00000C, "Member 'FKeyTupleBool::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSavedInventoryDataV7
// 0x0020 (0x0020 - 0x0000)
struct FCharacterSavedInventoryDataV7 final
{
public:
	class FName                                   Id;                                                // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 I;                                                 // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSavedInventoryDataV7) == 0x000008, "Wrong alignment on FCharacterSavedInventoryDataV7");
static_assert(sizeof(FCharacterSavedInventoryDataV7) == 0x000020, "Wrong size on FCharacterSavedInventoryDataV7");
static_assert(offsetof(FCharacterSavedInventoryDataV7, Id) == 0x000000, "Member 'FCharacterSavedInventoryDataV7::Id' has a wrong offset!");
static_assert(offsetof(FCharacterSavedInventoryDataV7, Num) == 0x00000C, "Member 'FCharacterSavedInventoryDataV7::Num' has a wrong offset!");
static_assert(offsetof(FCharacterSavedInventoryDataV7, I) == 0x000010, "Member 'FCharacterSavedInventoryDataV7::I' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedStatsDataV7
// 0x0010 (0x0010 - 0x0000)
struct FSavedStatsDataV7 final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedStatsDataV7) == 0x000004, "Wrong alignment on FSavedStatsDataV7");
static_assert(sizeof(FSavedStatsDataV7) == 0x000010, "Wrong size on FSavedStatsDataV7");
static_assert(offsetof(FSavedStatsDataV7, Name) == 0x000000, "Member 'FSavedStatsDataV7::Name' has a wrong offset!");
static_assert(offsetof(FSavedStatsDataV7, Value) == 0x00000C, "Member 'FSavedStatsDataV7::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.AssignedPerkPropertiesV7
// 0x0014 (0x0014 - 0x0000)
struct FAssignedPerkPropertiesV7 final
{
public:
	class FName                                   PerkId;                                            // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkLevel;                                         // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeachable;                                       // 0x0010(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssignedPerkPropertiesV7) == 0x000004, "Wrong alignment on FAssignedPerkPropertiesV7");
static_assert(sizeof(FAssignedPerkPropertiesV7) == 0x000014, "Wrong size on FAssignedPerkPropertiesV7");
static_assert(offsetof(FAssignedPerkPropertiesV7, PerkId) == 0x000000, "Member 'FAssignedPerkPropertiesV7::PerkId' has a wrong offset!");
static_assert(offsetof(FAssignedPerkPropertiesV7, PerkLevel) == 0x00000C, "Member 'FAssignedPerkPropertiesV7::PerkLevel' has a wrong offset!");
static_assert(offsetof(FAssignedPerkPropertiesV7, IsTeachable) == 0x000010, "Member 'FAssignedPerkPropertiesV7::IsTeachable' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedCharacterLevelDataV7
// 0x0018 (0x0018 - 0x0000)
struct FSavedCharacterLevelDataV7 final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPerksBeenSelected;                              // 0x0004(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPerkSelectionBeenGenerated;                     // 0x0005(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssignedPerkPropertiesV7>      PerkSelection;                                     // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedCharacterLevelDataV7) == 0x000008, "Wrong alignment on FSavedCharacterLevelDataV7");
static_assert(sizeof(FSavedCharacterLevelDataV7) == 0x000018, "Wrong size on FSavedCharacterLevelDataV7");
static_assert(offsetof(FSavedCharacterLevelDataV7, Level) == 0x000000, "Member 'FSavedCharacterLevelDataV7::Level' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelDataV7, HasPerksBeenSelected) == 0x000004, "Member 'FSavedCharacterLevelDataV7::HasPerksBeenSelected' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelDataV7, HasPerkSelectionBeenGenerated) == 0x000005, "Member 'FSavedCharacterLevelDataV7::HasPerkSelectionBeenGenerated' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelDataV7, PerkSelection) == 0x000008, "Member 'FSavedCharacterLevelDataV7::PerkSelection' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSavedProfileDataV7
// 0x0158 (0x0158 - 0x0000)
struct FCharacterSavedProfileDataV7 final
{
public:
	int32                                         BloodWebLevel;                                     // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeLevel;                                     // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterExperience;                               // 0x0008(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesConfronted;                                   // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PrestigeDates;                                     // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodWebData;                                      // 0x0020(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedPlayerLoadoutData          CharacterLoadoutData;                              // 0x0060(0x0098)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FCharacterSavedInventoryDataV7> Inventory;                                         // 0x00F8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedCharacterLevelDataV7>     CharacterProgression;                              // 0x0108(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedStatsDataV7>              StatProgression;                                   // 0x0118(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           CurrentCustomization;                              // 0x0128(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedCharmSlotData>            CurrentCharmCustomization;                         // 0x0138(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           UniquePerksAdded;                                  // 0x0148(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSavedProfileDataV7) == 0x000008, "Wrong alignment on FCharacterSavedProfileDataV7");
static_assert(sizeof(FCharacterSavedProfileDataV7) == 0x000158, "Wrong size on FCharacterSavedProfileDataV7");
static_assert(offsetof(FCharacterSavedProfileDataV7, BloodWebLevel) == 0x000000, "Member 'FCharacterSavedProfileDataV7::BloodWebLevel' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, PrestigeLevel) == 0x000004, "Member 'FCharacterSavedProfileDataV7::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, CharacterExperience) == 0x000008, "Member 'FCharacterSavedProfileDataV7::CharacterExperience' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, TimesConfronted) == 0x00000C, "Member 'FCharacterSavedProfileDataV7::TimesConfronted' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, PrestigeDates) == 0x000010, "Member 'FCharacterSavedProfileDataV7::PrestigeDates' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, BloodWebData) == 0x000020, "Member 'FCharacterSavedProfileDataV7::BloodWebData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, CharacterLoadoutData) == 0x000060, "Member 'FCharacterSavedProfileDataV7::CharacterLoadoutData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, Inventory) == 0x0000F8, "Member 'FCharacterSavedProfileDataV7::Inventory' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, CharacterProgression) == 0x000108, "Member 'FCharacterSavedProfileDataV7::CharacterProgression' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, StatProgression) == 0x000118, "Member 'FCharacterSavedProfileDataV7::StatProgression' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, CurrentCustomization) == 0x000128, "Member 'FCharacterSavedProfileDataV7::CurrentCustomization' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, CurrentCharmCustomization) == 0x000138, "Member 'FCharacterSavedProfileDataV7::CurrentCharmCustomization' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, UniquePerksAdded) == 0x000148, "Member 'FCharacterSavedProfileDataV7::UniquePerksAdded' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterKeyTuple
// 0x0160 (0x0160 - 0x0000)
struct FCharacterKeyTuple final
{
public:
	int32                                         Key;                                               // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterSavedProfileDataV7           Data;                                              // 0x0008(0x0158)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterKeyTuple) == 0x000008, "Wrong alignment on FCharacterKeyTuple");
static_assert(sizeof(FCharacterKeyTuple) == 0x000160, "Wrong size on FCharacterKeyTuple");
static_assert(offsetof(FCharacterKeyTuple, Key) == 0x000000, "Member 'FCharacterKeyTuple::Key' has a wrong offset!");
static_assert(offsetof(FCharacterKeyTuple, Data) == 0x000008, "Member 'FCharacterKeyTuple::Data' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedDailyRitualContainerV7
// 0x0040 (0x0040 - 0x0000)
struct FSavedDailyRitualContainerV7 final
{
public:
	class FString                                 LastRitualReceivedDate;                            // 0x0000(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastRitualPopupDate;                               // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastRitualDismissedDate;                           // 0x0020(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLegacySavedDailyRitualInstance> Rituals;                                          // 0x0030(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedDailyRitualContainerV7) == 0x000008, "Wrong alignment on FSavedDailyRitualContainerV7");
static_assert(sizeof(FSavedDailyRitualContainerV7) == 0x000040, "Wrong size on FSavedDailyRitualContainerV7");
static_assert(offsetof(FSavedDailyRitualContainerV7, LastRitualReceivedDate) == 0x000000, "Member 'FSavedDailyRitualContainerV7::LastRitualReceivedDate' has a wrong offset!");
static_assert(offsetof(FSavedDailyRitualContainerV7, LastRitualPopupDate) == 0x000010, "Member 'FSavedDailyRitualContainerV7::LastRitualPopupDate' has a wrong offset!");
static_assert(offsetof(FSavedDailyRitualContainerV7, LastRitualDismissedDate) == 0x000020, "Member 'FSavedDailyRitualContainerV7::LastRitualDismissedDate' has a wrong offset!");
static_assert(offsetof(FSavedDailyRitualContainerV7, Rituals) == 0x000030, "Member 'FSavedDailyRitualContainerV7::Rituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedFearMarketOfferingInstanceV7
// 0x0030 (0x0030 - 0x0000)
struct FSavedFearMarketOfferingInstanceV7 final
{
public:
	TArray<struct FLegacySavedFearMarketItemInstance> ObjectsForSale;                                // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FString                                 StartTime;                                         // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndTime;                                           // 0x0020(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedFearMarketOfferingInstanceV7) == 0x000008, "Wrong alignment on FSavedFearMarketOfferingInstanceV7");
static_assert(sizeof(FSavedFearMarketOfferingInstanceV7) == 0x000030, "Wrong size on FSavedFearMarketOfferingInstanceV7");
static_assert(offsetof(FSavedFearMarketOfferingInstanceV7, ObjectsForSale) == 0x000000, "Member 'FSavedFearMarketOfferingInstanceV7::ObjectsForSale' has a wrong offset!");
static_assert(offsetof(FSavedFearMarketOfferingInstanceV7, StartTime) == 0x000010, "Member 'FSavedFearMarketOfferingInstanceV7::StartTime' has a wrong offset!");
static_assert(offsetof(FSavedFearMarketOfferingInstanceV7, EndTime) == 0x000020, "Member 'FSavedFearMarketOfferingInstanceV7::EndTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedSpecialEventDataV7
// 0x0028 (0x0028 - 0x0000)
struct FSavedSpecialEventDataV7 final
{
public:
	class FName                                   EventId;                                           // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SeenCinematics;                                    // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          EventEntryScreenOpened;                            // 0x0020(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedSpecialEventDataV7) == 0x000008, "Wrong alignment on FSavedSpecialEventDataV7");
static_assert(sizeof(FSavedSpecialEventDataV7) == 0x000028, "Wrong size on FSavedSpecialEventDataV7");
static_assert(offsetof(FSavedSpecialEventDataV7, EventId) == 0x000000, "Member 'FSavedSpecialEventDataV7::EventId' has a wrong offset!");
static_assert(offsetof(FSavedSpecialEventDataV7, SeenCinematics) == 0x000010, "Member 'FSavedSpecialEventDataV7::SeenCinematics' has a wrong offset!");
static_assert(offsetof(FSavedSpecialEventDataV7, EventEntryScreenOpened) == 0x000020, "Member 'FSavedSpecialEventDataV7::EventEntryScreenOpened' has a wrong offset!");

// ScriptStruct DeadByDaylight.SaveDataV7
// 0x03D8 (0x03E8 - 0x0010)
struct FSaveDataV7 final : public FSaveDataBase
{
public:
	class FString                                 PlayerUID;                                         // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedCamperIndex;                               // 0x0020(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSlasherIndex;                              // 0x0024(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Offerings;                                         // 0x0028(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          FirstTimePlaying;                                  // 0x0038(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConsecutiveMatchStreak;                            // 0x003C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenKillerTutorialEndReward;               // 0x0040(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenSurvivorTutorialEndReward;             // 0x0041(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenBloodpointsOnboardingCurrencyPopup;         // 0x0042(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenAuricCellsOnboardingCurrencyPopup;          // 0x0043(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenIridescentShardsOnboardingCurrencyPopup;    // 0x0044(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        CurrentSeasonTicks;                                // 0x0048(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastConnectedCharacterIndex;                       // 0x0050(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisconnectPenaltyTime;                             // 0x0058(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastMatchEndTime;                                  // 0x0068(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastMatchStartTime;                                // 0x0078(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastKillerMatchEndTime;                            // 0x0088(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastSurvivorMatchEndTime;                          // 0x0098(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Experience;                                        // 0x00A8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusExperience;                                   // 0x00AC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FearTokens;                                        // 0x00B0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FearTokensMigrated;                                // 0x00B4(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OngoingGameTime;                                   // 0x00B8(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatches;                                 // 0x00C8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKeyTupleBool>                  PageVisited;                                       // 0x00D0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FKeyTupleBool>                  ChatVisible;                                       // 0x00E0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivor;                       // 0x00F0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKiller;                         // 0x00F4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivorNoFriends;              // 0x00F8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKillerNoFriends;                // 0x00FC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastMatchTimestamp;                                // 0x0100(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastSessionTimestamp;                              // 0x0108(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeSessions;                                // 0x0110(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CumulativePlaytime;                                // 0x0118(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterKeyTuple>             CharacterData;                                     // 0x0128(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           OwnedCharms;                                       // 0x0138(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FSavedDailyRitualContainerV7           DailyRituals;                                      // 0x0148(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FSavedFearMarketOfferingInstanceV7     FearMarket;                                        // 0x0188(0x0030)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedPlayerLoadoutData          LastLoadout;                                       // 0x01B8(0x0098)(SaveGame, NativeAccessSpecifierPublic)
	struct FConsoleUserSettings                   ConsoleUserSettings;                               // 0x0250(0x00D0)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedStatsDataV7>              PlayerStatProgression;                             // 0x0320(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FString>                         OwnedContent;                                      // 0x0330(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedSpecialEventDataV7>       SpecialEvent;                                      // 0x0340(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodStoreKillers;                                 // 0x0350(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodStoreSurvivors;                               // 0x0390(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FKeyTupleBool>                  OnBoardingCompleted;                               // 0x03D0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          IsCrossplayAllowed;                                // 0x03E0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDeclineFriendInvites;                          // 0x03E1(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E2[0x6];                                      // 0x03E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveDataV7) == 0x000008, "Wrong alignment on FSaveDataV7");
static_assert(sizeof(FSaveDataV7) == 0x0003E8, "Wrong size on FSaveDataV7");
static_assert(offsetof(FSaveDataV7, PlayerUID) == 0x000010, "Member 'FSaveDataV7::PlayerUID' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, SelectedCamperIndex) == 0x000020, "Member 'FSaveDataV7::SelectedCamperIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, SelectedSlasherIndex) == 0x000024, "Member 'FSaveDataV7::SelectedSlasherIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, Offerings) == 0x000028, "Member 'FSaveDataV7::Offerings' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, FirstTimePlaying) == 0x000038, "Member 'FSaveDataV7::FirstTimePlaying' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, ConsecutiveMatchStreak) == 0x00003C, "Member 'FSaveDataV7::ConsecutiveMatchStreak' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, HasBeenGivenKillerTutorialEndReward) == 0x000040, "Member 'FSaveDataV7::HasBeenGivenKillerTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, HasBeenGivenSurvivorTutorialEndReward) == 0x000041, "Member 'FSaveDataV7::HasBeenGivenSurvivorTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, HasSeenBloodpointsOnboardingCurrencyPopup) == 0x000042, "Member 'FSaveDataV7::HasSeenBloodpointsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, HasSeenAuricCellsOnboardingCurrencyPopup) == 0x000043, "Member 'FSaveDataV7::HasSeenAuricCellsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, HasSeenIridescentShardsOnboardingCurrencyPopup) == 0x000044, "Member 'FSaveDataV7::HasSeenIridescentShardsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CurrentSeasonTicks) == 0x000048, "Member 'FSaveDataV7::CurrentSeasonTicks' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastConnectedCharacterIndex) == 0x000050, "Member 'FSaveDataV7::LastConnectedCharacterIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, DisconnectPenaltyTime) == 0x000058, "Member 'FSaveDataV7::DisconnectPenaltyTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastMatchEndTime) == 0x000068, "Member 'FSaveDataV7::LastMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastMatchStartTime) == 0x000078, "Member 'FSaveDataV7::LastMatchStartTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastKillerMatchEndTime) == 0x000088, "Member 'FSaveDataV7::LastKillerMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastSurvivorMatchEndTime) == 0x000098, "Member 'FSaveDataV7::LastSurvivorMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, Experience) == 0x0000A8, "Member 'FSaveDataV7::Experience' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, BonusExperience) == 0x0000AC, "Member 'FSaveDataV7::BonusExperience' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, FearTokens) == 0x0000B0, "Member 'FSaveDataV7::FearTokens' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, FearTokensMigrated) == 0x0000B4, "Member 'FSaveDataV7::FearTokensMigrated' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, OngoingGameTime) == 0x0000B8, "Member 'FSaveDataV7::OngoingGameTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeMatches) == 0x0000C8, "Member 'FSaveDataV7::CumulativeMatches' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, PageVisited) == 0x0000D0, "Member 'FSaveDataV7::PageVisited' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, ChatVisible) == 0x0000E0, "Member 'FSaveDataV7::ChatVisible' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeMatchesAsSurvivor) == 0x0000F0, "Member 'FSaveDataV7::CumulativeMatchesAsSurvivor' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeMatchesAsKiller) == 0x0000F4, "Member 'FSaveDataV7::CumulativeMatchesAsKiller' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeMatchesAsSurvivorNoFriends) == 0x0000F8, "Member 'FSaveDataV7::CumulativeMatchesAsSurvivorNoFriends' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeMatchesAsKillerNoFriends) == 0x0000FC, "Member 'FSaveDataV7::CumulativeMatchesAsKillerNoFriends' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastMatchTimestamp) == 0x000100, "Member 'FSaveDataV7::LastMatchTimestamp' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastSessionTimestamp) == 0x000108, "Member 'FSaveDataV7::LastSessionTimestamp' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeSessions) == 0x000110, "Member 'FSaveDataV7::CumulativeSessions' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativePlaytime) == 0x000118, "Member 'FSaveDataV7::CumulativePlaytime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CharacterData) == 0x000128, "Member 'FSaveDataV7::CharacterData' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, OwnedCharms) == 0x000138, "Member 'FSaveDataV7::OwnedCharms' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, DailyRituals) == 0x000148, "Member 'FSaveDataV7::DailyRituals' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, FearMarket) == 0x000188, "Member 'FSaveDataV7::FearMarket' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastLoadout) == 0x0001B8, "Member 'FSaveDataV7::LastLoadout' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, ConsoleUserSettings) == 0x000250, "Member 'FSaveDataV7::ConsoleUserSettings' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, PlayerStatProgression) == 0x000320, "Member 'FSaveDataV7::PlayerStatProgression' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, OwnedContent) == 0x000330, "Member 'FSaveDataV7::OwnedContent' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, SpecialEvent) == 0x000340, "Member 'FSaveDataV7::SpecialEvent' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, BloodStoreKillers) == 0x000350, "Member 'FSaveDataV7::BloodStoreKillers' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, BloodStoreSurvivors) == 0x000390, "Member 'FSaveDataV7::BloodStoreSurvivors' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, OnBoardingCompleted) == 0x0003D0, "Member 'FSaveDataV7::OnBoardingCompleted' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, IsCrossplayAllowed) == 0x0003E0, "Member 'FSaveDataV7::IsCrossplayAllowed' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, AutoDeclineFriendInvites) == 0x0003E1, "Member 'FSaveDataV7::AutoDeclineFriendInvites' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuRoleChangeEventData
// 0x0001 (0x0001 - 0x0000)
struct FMenuRoleChangeEventData final
{
public:
	EPlayerRole                                   PlayerRole;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuRoleChangeEventData) == 0x000001, "Wrong alignment on FMenuRoleChangeEventData");
static_assert(sizeof(FMenuRoleChangeEventData) == 0x000001, "Wrong size on FMenuRoleChangeEventData");
static_assert(offsetof(FMenuRoleChangeEventData, PlayerRole) == 0x000000, "Member 'FMenuRoleChangeEventData::PlayerRole' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerScoreEmitterData
// 0x0078 (0x0080 - 0x0008)
struct FPlayerScoreEmitterData final : public FDBDTableRowBase
{
public:
	struct FGameplayTagQuery                      PawnSemanticTags;                                  // 0x0008(0x0048)(Edit, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Emitter;                                           // 0x0050(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerScoreEmitterData) == 0x000008, "Wrong alignment on FPlayerScoreEmitterData");
static_assert(sizeof(FPlayerScoreEmitterData) == 0x000080, "Wrong size on FPlayerScoreEmitterData");
static_assert(offsetof(FPlayerScoreEmitterData, PawnSemanticTags) == 0x000008, "Member 'FPlayerScoreEmitterData::PawnSemanticTags' has a wrong offset!");
static_assert(offsetof(FPlayerScoreEmitterData, Emitter) == 0x000050, "Member 'FPlayerScoreEmitterData::Emitter' has a wrong offset!");

// ScriptStruct DeadByDaylight.RewardLayoutWidgetToGenerate
// 0x0090 (0x0090 - 0x0000)
struct FRewardLayoutWidgetToGenerate final
{
public:
	TSoftClassPtr<class UClass>                   CharacterRewardWidget;                             // 0x0000(0x0030)(Edit, DisableEditOnInstance, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CurrencyRewardWidget;                              // 0x0030(0x0030)(Edit, DisableEditOnInstance, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SpacerWidget;                                      // 0x0060(0x0030)(Edit, DisableEditOnInstance, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardLayoutWidgetToGenerate) == 0x000008, "Wrong alignment on FRewardLayoutWidgetToGenerate");
static_assert(sizeof(FRewardLayoutWidgetToGenerate) == 0x000090, "Wrong size on FRewardLayoutWidgetToGenerate");
static_assert(offsetof(FRewardLayoutWidgetToGenerate, CharacterRewardWidget) == 0x000000, "Member 'FRewardLayoutWidgetToGenerate::CharacterRewardWidget' has a wrong offset!");
static_assert(offsetof(FRewardLayoutWidgetToGenerate, CurrencyRewardWidget) == 0x000030, "Member 'FRewardLayoutWidgetToGenerate::CurrencyRewardWidget' has a wrong offset!");
static_assert(offsetof(FRewardLayoutWidgetToGenerate, SpacerWidget) == 0x000060, "Member 'FRewardLayoutWidgetToGenerate::SpacerWidget' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingCategoryData
// 0x00D8 (0x00E0 - 0x0008)
struct FOfferingCategoryData final : public FDBDTableRowBase
{
public:
	EOfferingCategory                             OfferingCategory;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerRole>                           Role;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FItemUIData                            UIData;                                            // 0x0020(0x00C0)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingCategoryData) == 0x000008, "Wrong alignment on FOfferingCategoryData");
static_assert(sizeof(FOfferingCategoryData) == 0x0000E0, "Wrong size on FOfferingCategoryData");
static_assert(offsetof(FOfferingCategoryData, OfferingCategory) == 0x000008, "Member 'FOfferingCategoryData::OfferingCategory' has a wrong offset!");
static_assert(offsetof(FOfferingCategoryData, Role) == 0x000010, "Member 'FOfferingCategoryData::Role' has a wrong offset!");
static_assert(offsetof(FOfferingCategoryData, UIData) == 0x000020, "Member 'FOfferingCategoryData::UIData' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingProperties
// 0x0038 (0x0220 - 0x01E8)
struct FOfferingProperties final : public FItemData
{
public:
	EOfferingType                                 OfferingType;                                      // 0x01E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOfferingEffect>                Effects;                                           // 0x0200(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 BigIconFilePath;                                   // 0x0210(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingProperties) == 0x000008, "Wrong alignment on FOfferingProperties");
static_assert(sizeof(FOfferingProperties) == 0x000220, "Wrong size on FOfferingProperties");
static_assert(offsetof(FOfferingProperties, OfferingType) == 0x0001E8, "Member 'FOfferingProperties::OfferingType' has a wrong offset!");
static_assert(offsetof(FOfferingProperties, Tags) == 0x0001F0, "Member 'FOfferingProperties::Tags' has a wrong offset!");
static_assert(offsetof(FOfferingProperties, Effects) == 0x000200, "Member 'FOfferingProperties::Effects' has a wrong offset!");
static_assert(offsetof(FOfferingProperties, BigIconFilePath) == 0x000210, "Member 'FOfferingProperties::BigIconFilePath' has a wrong offset!");

// ScriptStruct DeadByDaylight.LightingSpecifics
// 0x0030 (0x0030 - 0x0000)
struct FLightingSpecifics final
{
public:
	TSoftClassPtr<class UClass>                   LightBlueprint;                                    // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightingSpecifics) == 0x000008, "Wrong alignment on FLightingSpecifics");
static_assert(sizeof(FLightingSpecifics) == 0x000030, "Wrong size on FLightingSpecifics");
static_assert(offsetof(FLightingSpecifics, LightBlueprint) == 0x000000, "Member 'FLightingSpecifics::LightBlueprint' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedSpecialEventDataV8
// 0x0010 (0x0010 - 0x0000)
struct FSavedSpecialEventDataV8 final
{
public:
	class FName                                   EventId;                                           // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EventEntryScreenOpened;                            // 0x000C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EventSplashScreenSeen;                             // 0x000D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedSpecialEventDataV8) == 0x000004, "Wrong alignment on FSavedSpecialEventDataV8");
static_assert(sizeof(FSavedSpecialEventDataV8) == 0x000010, "Wrong size on FSavedSpecialEventDataV8");
static_assert(offsetof(FSavedSpecialEventDataV8, EventId) == 0x000000, "Member 'FSavedSpecialEventDataV8::EventId' has a wrong offset!");
static_assert(offsetof(FSavedSpecialEventDataV8, EventEntryScreenOpened) == 0x00000C, "Member 'FSavedSpecialEventDataV8::EventEntryScreenOpened' has a wrong offset!");
static_assert(offsetof(FSavedSpecialEventDataV8, EventSplashScreenSeen) == 0x00000D, "Member 'FSavedSpecialEventDataV8::EventSplashScreenSeen' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedReleaseDataV8
// 0x0018 (0x0018 - 0x0000)
struct FSavedReleaseDataV8 final
{
public:
	class FString                                 Version;                                           // 0x0000(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewChapterPopupSeen;                               // 0x0010(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedReleaseDataV8) == 0x000008, "Wrong alignment on FSavedReleaseDataV8");
static_assert(sizeof(FSavedReleaseDataV8) == 0x000018, "Wrong size on FSavedReleaseDataV8");
static_assert(offsetof(FSavedReleaseDataV8, Version) == 0x000000, "Member 'FSavedReleaseDataV8::Version' has a wrong offset!");
static_assert(offsetof(FSavedReleaseDataV8, NewChapterPopupSeen) == 0x000010, "Member 'FSavedReleaseDataV8::NewChapterPopupSeen' has a wrong offset!");

// ScriptStruct DeadByDaylight.SaveDataV8
// 0x0490 (0x04A0 - 0x0010)
struct FSaveDataV8 final : public FSaveDataBase
{
public:
	class FString                                 PlayerUID;                                         // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedCamperIndex;                               // 0x0020(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSlasherIndex;                              // 0x0024(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Offerings;                                         // 0x0028(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          FirstTimePlaying;                                  // 0x0038(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenLightSensitivity;                           // 0x0039(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConsecutiveMatchStreak;                            // 0x003C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenKillerTutorialEndReward;               // 0x0040(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenSurvivorTutorialEndReward;             // 0x0041(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenBloodpointsOnboardingCurrencyPopup;         // 0x0042(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenAuricCellsOnboardingCurrencyPopup;          // 0x0043(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenIridescentShardsOnboardingCurrencyPopup;    // 0x0044(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        CurrentSeasonTicks;                                // 0x0048(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastConnectedCharacterIndex;                       // 0x0050(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisconnectPenaltyTime;                             // 0x0058(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastMatchEndTime;                                  // 0x0068(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastMatchStartTime;                                // 0x0078(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastKillerMatchEndTime;                            // 0x0088(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastSurvivorMatchEndTime;                          // 0x0098(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatches;                                 // 0x00A8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKeyTupleBool>                  PageVisited;                                       // 0x00B0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FKeyTupleBool>                  ChatVisible;                                       // 0x00C0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivor;                       // 0x00D0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKiller;                         // 0x00D4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivorNoFriends;              // 0x00D8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKillerNoFriends;                // 0x00DC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastMatchTimestamp;                                // 0x00E0(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastSessionTimestamp;                              // 0x00E8(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeSessions;                                // 0x00F0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CumulativePlaytime;                                // 0x00F8(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterKeyTuple>             CharacterData;                                     // 0x0108(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           OwnedCharms;                                       // 0x0118(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FSavedDailyRitualContainerV7           DailyRituals;                                      // 0x0128(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FSavedFearMarketOfferingInstanceV7     FearMarket;                                        // 0x0168(0x0030)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedPlayerLoadoutData          LastLoadout;                                       // 0x0198(0x0098)(SaveGame, NativeAccessSpecifierPublic)
	struct FConsoleUserSettings                   ConsoleUserSettings;                               // 0x0230(0x00D0)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedStatsDataV7>              PlayerStatProgression;                             // 0x0300(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FString>                         OwnedContent;                                      // 0x0310(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedSpecialEventDataV8>       SpecialEvent;                                      // 0x0320(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedReleaseDataV8>            Releases;                                          // 0x0330(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TSet<class FName>                             SeenCinematics;                                    // 0x0340(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodStoreKillers;                                 // 0x0390(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodStoreSurvivors;                               // 0x03D0(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FKeyTupleBool>                  OnBoardingCompleted;                               // 0x0410(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FDailyRitualSaveData                   DailyRitualSaveData;                               // 0x0420(0x0008)(SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	struct FUIViewFlagSaveData                    UIViewFlags;                                       // 0x0428(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	bool                                          IsCrossplayAllowed;                                // 0x0478(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDeclineFriendInvites;                          // 0x0479(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeginnerTooltipsBeenDisabledAtLevel;            // 0x047A(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowPortraitBorder;                                // 0x047B(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterCustomizationPresetsList> CharacterCustomizationPresets;                 // 0x0480(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FCharacterLoadoutPresetsList>   CharacterLoadoutPresets;                           // 0x0490(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveDataV8) == 0x000008, "Wrong alignment on FSaveDataV8");
static_assert(sizeof(FSaveDataV8) == 0x0004A0, "Wrong size on FSaveDataV8");
static_assert(offsetof(FSaveDataV8, PlayerUID) == 0x000010, "Member 'FSaveDataV8::PlayerUID' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SelectedCamperIndex) == 0x000020, "Member 'FSaveDataV8::SelectedCamperIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SelectedSlasherIndex) == 0x000024, "Member 'FSaveDataV8::SelectedSlasherIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, Offerings) == 0x000028, "Member 'FSaveDataV8::Offerings' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, FirstTimePlaying) == 0x000038, "Member 'FSaveDataV8::FirstTimePlaying' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasSeenLightSensitivity) == 0x000039, "Member 'FSaveDataV8::HasSeenLightSensitivity' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, ConsecutiveMatchStreak) == 0x00003C, "Member 'FSaveDataV8::ConsecutiveMatchStreak' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasBeenGivenKillerTutorialEndReward) == 0x000040, "Member 'FSaveDataV8::HasBeenGivenKillerTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasBeenGivenSurvivorTutorialEndReward) == 0x000041, "Member 'FSaveDataV8::HasBeenGivenSurvivorTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasSeenBloodpointsOnboardingCurrencyPopup) == 0x000042, "Member 'FSaveDataV8::HasSeenBloodpointsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasSeenAuricCellsOnboardingCurrencyPopup) == 0x000043, "Member 'FSaveDataV8::HasSeenAuricCellsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasSeenIridescentShardsOnboardingCurrencyPopup) == 0x000044, "Member 'FSaveDataV8::HasSeenIridescentShardsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CurrentSeasonTicks) == 0x000048, "Member 'FSaveDataV8::CurrentSeasonTicks' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastConnectedCharacterIndex) == 0x000050, "Member 'FSaveDataV8::LastConnectedCharacterIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, DisconnectPenaltyTime) == 0x000058, "Member 'FSaveDataV8::DisconnectPenaltyTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastMatchEndTime) == 0x000068, "Member 'FSaveDataV8::LastMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastMatchStartTime) == 0x000078, "Member 'FSaveDataV8::LastMatchStartTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastKillerMatchEndTime) == 0x000088, "Member 'FSaveDataV8::LastKillerMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastSurvivorMatchEndTime) == 0x000098, "Member 'FSaveDataV8::LastSurvivorMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatches) == 0x0000A8, "Member 'FSaveDataV8::CumulativeMatches' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, PageVisited) == 0x0000B0, "Member 'FSaveDataV8::PageVisited' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, ChatVisible) == 0x0000C0, "Member 'FSaveDataV8::ChatVisible' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesAsSurvivor) == 0x0000D0, "Member 'FSaveDataV8::CumulativeMatchesAsSurvivor' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesAsKiller) == 0x0000D4, "Member 'FSaveDataV8::CumulativeMatchesAsKiller' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesAsSurvivorNoFriends) == 0x0000D8, "Member 'FSaveDataV8::CumulativeMatchesAsSurvivorNoFriends' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesAsKillerNoFriends) == 0x0000DC, "Member 'FSaveDataV8::CumulativeMatchesAsKillerNoFriends' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastMatchTimestamp) == 0x0000E0, "Member 'FSaveDataV8::LastMatchTimestamp' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastSessionTimestamp) == 0x0000E8, "Member 'FSaveDataV8::LastSessionTimestamp' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeSessions) == 0x0000F0, "Member 'FSaveDataV8::CumulativeSessions' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativePlaytime) == 0x0000F8, "Member 'FSaveDataV8::CumulativePlaytime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CharacterData) == 0x000108, "Member 'FSaveDataV8::CharacterData' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, OwnedCharms) == 0x000118, "Member 'FSaveDataV8::OwnedCharms' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, DailyRituals) == 0x000128, "Member 'FSaveDataV8::DailyRituals' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, FearMarket) == 0x000168, "Member 'FSaveDataV8::FearMarket' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastLoadout) == 0x000198, "Member 'FSaveDataV8::LastLoadout' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, ConsoleUserSettings) == 0x000230, "Member 'FSaveDataV8::ConsoleUserSettings' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, PlayerStatProgression) == 0x000300, "Member 'FSaveDataV8::PlayerStatProgression' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, OwnedContent) == 0x000310, "Member 'FSaveDataV8::OwnedContent' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SpecialEvent) == 0x000320, "Member 'FSaveDataV8::SpecialEvent' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, Releases) == 0x000330, "Member 'FSaveDataV8::Releases' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SeenCinematics) == 0x000340, "Member 'FSaveDataV8::SeenCinematics' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, BloodStoreKillers) == 0x000390, "Member 'FSaveDataV8::BloodStoreKillers' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, BloodStoreSurvivors) == 0x0003D0, "Member 'FSaveDataV8::BloodStoreSurvivors' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, OnBoardingCompleted) == 0x000410, "Member 'FSaveDataV8::OnBoardingCompleted' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, DailyRitualSaveData) == 0x000420, "Member 'FSaveDataV8::DailyRitualSaveData' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, UIViewFlags) == 0x000428, "Member 'FSaveDataV8::UIViewFlags' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, IsCrossplayAllowed) == 0x000478, "Member 'FSaveDataV8::IsCrossplayAllowed' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, AutoDeclineFriendInvites) == 0x000479, "Member 'FSaveDataV8::AutoDeclineFriendInvites' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasBeginnerTooltipsBeenDisabledAtLevel) == 0x00047A, "Member 'FSaveDataV8::HasBeginnerTooltipsBeenDisabledAtLevel' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, ShowPortraitBorder) == 0x00047B, "Member 'FSaveDataV8::ShowPortraitBorder' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CharacterCustomizationPresets) == 0x000480, "Member 'FSaveDataV8::CharacterCustomizationPresets' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CharacterLoadoutPresets) == 0x000490, "Member 'FSaveDataV8::CharacterLoadoutPresets' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutfitData
// 0x0160 (0x0168 - 0x0008)
struct FOutfitData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemUIData                            UIData;                                            // 0x0018(0x00C0)(Edit, NativeAccessSpecifierPublic)
	struct FItemAvailability                      Availability;                                      // 0x00D8(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           OutfitItems;                                       // 0x0108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   CollectionName;                                    // 0x0118(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CollectionDescription;                             // 0x0130(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0148(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableInAtlantaBuild;                         // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomizedAudioStateCollection;                    // 0x015C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutfitData) == 0x000008, "Wrong alignment on FOutfitData");
static_assert(sizeof(FOutfitData) == 0x000168, "Wrong size on FOutfitData");
static_assert(offsetof(FOutfitData, ID) == 0x000008, "Member 'FOutfitData::ID' has a wrong offset!");
static_assert(offsetof(FOutfitData, UIData) == 0x000018, "Member 'FOutfitData::UIData' has a wrong offset!");
static_assert(offsetof(FOutfitData, Availability) == 0x0000D8, "Member 'FOutfitData::Availability' has a wrong offset!");
static_assert(offsetof(FOutfitData, OutfitItems) == 0x000108, "Member 'FOutfitData::OutfitItems' has a wrong offset!");
static_assert(offsetof(FOutfitData, CollectionName) == 0x000118, "Member 'FOutfitData::CollectionName' has a wrong offset!");
static_assert(offsetof(FOutfitData, CollectionDescription) == 0x000130, "Member 'FOutfitData::CollectionDescription' has a wrong offset!");
static_assert(offsetof(FOutfitData, InclusionVersion) == 0x000148, "Member 'FOutfitData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FOutfitData, IsAvailableInAtlantaBuild) == 0x000158, "Member 'FOutfitData::IsAvailableInAtlantaBuild' has a wrong offset!");
static_assert(offsetof(FOutfitData, CustomizedAudioStateCollection) == 0x00015C, "Member 'FOutfitData::CustomizedAudioStateCollection' has a wrong offset!");

// ScriptStruct DeadByDaylight.SaveValidationData
// 0x0030 (0x0030 - 0x0000)
struct FSaveValidationData final
{
public:
	class FString                                 PlayerUID;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CharacterData;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveValidationData) == 0x000008, "Wrong alignment on FSaveValidationData");
static_assert(sizeof(FSaveValidationData) == 0x000030, "Wrong size on FSaveValidationData");
static_assert(offsetof(FSaveValidationData, PlayerUID) == 0x000000, "Member 'FSaveValidationData::PlayerUID' has a wrong offset!");
static_assert(offsetof(FSaveValidationData, CharacterData) == 0x000010, "Member 'FSaveValidationData::CharacterData' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScoreValue
// 0x0040 (0x0048 - 0x0008)
struct FScoreValue final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDBDScoreCategory                             Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BloodpointValue;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBloodpointValue;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BloodpointDepreciationCurve;                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OngoingWaitTime;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreValue) == 0x000008, "Wrong alignment on FScoreValue");
static_assert(sizeof(FScoreValue) == 0x000048, "Wrong size on FScoreValue");
static_assert(offsetof(FScoreValue, ID) == 0x000008, "Member 'FScoreValue::ID' has a wrong offset!");
static_assert(offsetof(FScoreValue, Category) == 0x000014, "Member 'FScoreValue::Category' has a wrong offset!");
static_assert(offsetof(FScoreValue, BloodpointValue) == 0x000018, "Member 'FScoreValue::BloodpointValue' has a wrong offset!");
static_assert(offsetof(FScoreValue, MaxBloodpointValue) == 0x00001C, "Member 'FScoreValue::MaxBloodpointValue' has a wrong offset!");
static_assert(offsetof(FScoreValue, BloodpointDepreciationCurve) == 0x000020, "Member 'FScoreValue::BloodpointDepreciationCurve' has a wrong offset!");
static_assert(offsetof(FScoreValue, OngoingWaitTime) == 0x000028, "Member 'FScoreValue::OngoingWaitTime' has a wrong offset!");
static_assert(offsetof(FScoreValue, DisplayName) == 0x000030, "Member 'FScoreValue::DisplayName' has a wrong offset!");

// ScriptStruct DeadByDaylight.RefundKeyUIData
// 0x0058 (0x0058 - 0x0000)
struct FRefundKeyUIData final
{
public:
	class FName                                   Id;                                                // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconFilePath;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0038(0x0018)(NativeAccessSpecifierPublic)
	ERefundSource                                 Source;                                            // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRefundKeyUIData) == 0x000008, "Wrong alignment on FRefundKeyUIData");
static_assert(sizeof(FRefundKeyUIData) == 0x000058, "Wrong size on FRefundKeyUIData");
static_assert(offsetof(FRefundKeyUIData, Id) == 0x000000, "Member 'FRefundKeyUIData::Id' has a wrong offset!");
static_assert(offsetof(FRefundKeyUIData, IconFilePath) == 0x000010, "Member 'FRefundKeyUIData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FRefundKeyUIData, DisplayName) == 0x000020, "Member 'FRefundKeyUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FRefundKeyUIData, Description) == 0x000038, "Member 'FRefundKeyUIData::Description' has a wrong offset!");
static_assert(offsetof(FRefundKeyUIData, Source) == 0x000050, "Member 'FRefundKeyUIData::Source' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScoreCategoryData
// 0x0010 (0x0018 - 0x0008)
struct FScoreCategoryData final : public FDBDTableRowBase
{
public:
	EDBDScoreCategory                             Category;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScoreCap;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressionCap;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AchievementCap;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreCategoryData) == 0x000008, "Wrong alignment on FScoreCategoryData");
static_assert(sizeof(FScoreCategoryData) == 0x000018, "Wrong size on FScoreCategoryData");
static_assert(offsetof(FScoreCategoryData, Category) == 0x000008, "Member 'FScoreCategoryData::Category' has a wrong offset!");
static_assert(offsetof(FScoreCategoryData, ScoreCap) == 0x00000C, "Member 'FScoreCategoryData::ScoreCap' has a wrong offset!");
static_assert(offsetof(FScoreCategoryData, ProgressionCap) == 0x000010, "Member 'FScoreCategoryData::ProgressionCap' has a wrong offset!");
static_assert(offsetof(FScoreCategoryData, AchievementCap) == 0x000014, "Member 'FScoreCategoryData::AchievementCap' has a wrong offset!");

// ScriptStruct DeadByDaylight.AwardedScore
// 0x0010 (0x0010 - 0x0000)
struct FAwardedScore final
{
public:
	class FName                                   ScoreTypeId;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodpointsAwarded;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAwardedScore) == 0x000004, "Wrong alignment on FAwardedScore");
static_assert(sizeof(FAwardedScore) == 0x000010, "Wrong size on FAwardedScore");
static_assert(offsetof(FAwardedScore, ScoreTypeId) == 0x000000, "Member 'FAwardedScore::ScoreTypeId' has a wrong offset!");
static_assert(offsetof(FAwardedScore, BloodpointsAwarded) == 0x00000C, "Member 'FAwardedScore::BloodpointsAwarded' has a wrong offset!");

// ScriptStruct DeadByDaylight.AwardedScores
// 0x0010 (0x0010 - 0x0000)
struct FAwardedScores final
{
public:
	TArray<struct FAwardedScore>                  Array;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAwardedScores) == 0x000008, "Wrong alignment on FAwardedScores");
static_assert(sizeof(FAwardedScores) == 0x000010, "Wrong size on FAwardedScores");
static_assert(offsetof(FAwardedScores, Array) == 0x000000, "Member 'FAwardedScores::Array' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerstateDataCache
// 0x0058 (0x0058 - 0x0000)
struct FPlayerstateDataCache final
{
public:
	TMap<class FName, struct FAwardedScores>      awardedScoresByType;                               // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	bool                                          IsDataCacheValid;                                  // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerstateDataCache) == 0x000008, "Wrong alignment on FPlayerstateDataCache");
static_assert(sizeof(FPlayerstateDataCache) == 0x000058, "Wrong size on FPlayerstateDataCache");
static_assert(offsetof(FPlayerstateDataCache, awardedScoresByType) == 0x000000, "Member 'FPlayerstateDataCache::awardedScoresByType' has a wrong offset!");
static_assert(offsetof(FPlayerstateDataCache, IsDataCacheValid) == 0x000050, "Member 'FPlayerstateDataCache::IsDataCacheValid' has a wrong offset!");

// ScriptStruct DeadByDaylight.LobbyPlayerData
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FLobbyPlayerData final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbyPlayerData) == 0x000008, "Wrong alignment on FLobbyPlayerData");
static_assert(sizeof(FLobbyPlayerData) == 0x000050, "Wrong size on FLobbyPlayerData");

// ScriptStruct DeadByDaylight.PerkInitializationData
// 0x0008 (0x0008 - 0x0000)
struct FPerkInitializationData final
{
public:
	int32                                         PerkLevel;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         ActivatableInteractionInputType;                   // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AuthorityDataSet;                                  // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerkInitializationData) == 0x000004, "Wrong alignment on FPerkInitializationData");
static_assert(sizeof(FPerkInitializationData) == 0x000008, "Wrong size on FPerkInitializationData");
static_assert(offsetof(FPerkInitializationData, PerkLevel) == 0x000000, "Member 'FPerkInitializationData::PerkLevel' has a wrong offset!");
static_assert(offsetof(FPerkInitializationData, ActivatableInteractionInputType) == 0x000004, "Member 'FPerkInitializationData::ActivatableInteractionInputType' has a wrong offset!");
static_assert(offsetof(FPerkInitializationData, AuthorityDataSet) == 0x000005, "Member 'FPerkInitializationData::AuthorityDataSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.UserGameStats
// 0x00B0 (0x00B0 - 0x0000)
struct FUserGameStats final
{
public:
	bool                                          Disconnected;                                      // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FearTokens;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skulls;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDBDScoreCategory, int32>                BonusBloodpoints;                                  // 0x0010(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<EDBDScoreCategory, int32>                _bloodpoints;                                      // 0x0060(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUserGameStats) == 0x000008, "Wrong alignment on FUserGameStats");
static_assert(sizeof(FUserGameStats) == 0x0000B0, "Wrong size on FUserGameStats");
static_assert(offsetof(FUserGameStats, Disconnected) == 0x000000, "Member 'FUserGameStats::Disconnected' has a wrong offset!");
static_assert(offsetof(FUserGameStats, FearTokens) == 0x000004, "Member 'FUserGameStats::FearTokens' has a wrong offset!");
static_assert(offsetof(FUserGameStats, Skulls) == 0x000008, "Member 'FUserGameStats::Skulls' has a wrong offset!");
static_assert(offsetof(FUserGameStats, BonusBloodpoints) == 0x000010, "Member 'FUserGameStats::BonusBloodpoints' has a wrong offset!");
static_assert(offsetof(FUserGameStats, _bloodpoints) == 0x000060, "Member 'FUserGameStats::_bloodpoints' has a wrong offset!");

// ScriptStruct DeadByDaylight.OngoingScoreData
// 0x0030 (0x0030 - 0x0000)
struct FOngoingScoreData final
{
public:
	EDBDScoreTypes                                ScoreType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ScoreTypeTag;                                      // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceScore;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApplyScoreTimeout;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedPercent;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CustomObjectParameter;                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOngoingScoreData) == 0x000008, "Wrong alignment on FOngoingScoreData");
static_assert(sizeof(FOngoingScoreData) == 0x000030, "Wrong size on FOngoingScoreData");
static_assert(offsetof(FOngoingScoreData, ScoreType) == 0x000000, "Member 'FOngoingScoreData::ScoreType' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, ScoreTypeTag) == 0x000004, "Member 'FOngoingScoreData::ScoreTypeTag' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, TimeSinceScore) == 0x000010, "Member 'FOngoingScoreData::TimeSinceScore' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, ApplyScoreTimeout) == 0x000014, "Member 'FOngoingScoreData::ApplyScoreTimeout' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, AccumulatedPercent) == 0x000018, "Member 'FOngoingScoreData::AccumulatedPercent' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, Target) == 0x000020, "Member 'FOngoingScoreData::Target' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, CustomObjectParameter) == 0x000028, "Member 'FOngoingScoreData::CustomObjectParameter' has a wrong offset!");

// ScriptStruct DeadByDaylight.ToastButton
// 0x0020 (0x0020 - 0x0000)
struct FToastButton final
{
public:
	class FText                                   ButtonText;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsRegression;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FToastButton) == 0x000008, "Wrong alignment on FToastButton");
static_assert(sizeof(FToastButton) == 0x000020, "Wrong size on FToastButton");
static_assert(offsetof(FToastButton, ButtonText) == 0x000000, "Member 'FToastButton::ButtonText' has a wrong offset!");
static_assert(offsetof(FToastButton, IsRegression) == 0x000018, "Member 'FToastButton::IsRegression' has a wrong offset!");

// ScriptStruct DeadByDaylight.Toast
// 0x00A8 (0x00B0 - 0x0008)
struct FToast final : public FDBDTableRowBase
{
public:
	float                                         DisplayDuration;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lifetime;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ToastText;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EToastInputType, struct FToastButton>    ButtonsData;                                       // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         DelayBeforeInteraction;                            // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ToastIcon;                                         // 0x0080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FToast) == 0x000008, "Wrong alignment on FToast");
static_assert(sizeof(FToast) == 0x0000B0, "Wrong size on FToast");
static_assert(offsetof(FToast, DisplayDuration) == 0x000008, "Member 'FToast::DisplayDuration' has a wrong offset!");
static_assert(offsetof(FToast, Lifetime) == 0x00000C, "Member 'FToast::Lifetime' has a wrong offset!");
static_assert(offsetof(FToast, ToastText) == 0x000010, "Member 'FToast::ToastText' has a wrong offset!");
static_assert(offsetof(FToast, ButtonsData) == 0x000028, "Member 'FToast::ButtonsData' has a wrong offset!");
static_assert(offsetof(FToast, DelayBeforeInteraction) == 0x000078, "Member 'FToast::DelayBeforeInteraction' has a wrong offset!");
static_assert(offsetof(FToast, ToastIcon) == 0x000080, "Member 'FToast::ToastIcon' has a wrong offset!");

// ScriptStruct DeadByDaylight.DDosGameConfigDS
// 0x0002 (0x0002 - 0x0000)
struct FDDosGameConfigDS final
{
public:
	bool                                          DDoSDetection;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DDoSDetectionAnalytics;                            // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDDosGameConfigDS) == 0x000001, "Wrong alignment on FDDosGameConfigDS");
static_assert(sizeof(FDDosGameConfigDS) == 0x000002, "Wrong size on FDDosGameConfigDS");
static_assert(offsetof(FDDosGameConfigDS, DDoSDetection) == 0x000000, "Member 'FDDosGameConfigDS::DDoSDetection' has a wrong offset!");
static_assert(offsetof(FDDosGameConfigDS, DDoSDetectionAnalytics) == 0x000001, "Member 'FDDosGameConfigDS::DDoSDetectionAnalytics' has a wrong offset!");

// ScriptStruct DeadByDaylight.GenerationParams
// 0x0004 (0x0004 - 0x0000)
struct FGenerationParams final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenerationParams) == 0x000004, "Wrong alignment on FGenerationParams");
static_assert(sizeof(FGenerationParams) == 0x000004, "Wrong size on FGenerationParams");
static_assert(offsetof(FGenerationParams, Seed) == 0x000000, "Member 'FGenerationParams::Seed' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugModelExtArchiveQuestEvent
// 0x0028 (0x0028 - 0x0000)
struct FDebugModelExtArchiveQuestEvent final
{
public:
	class FString                                 Parameters;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuestEventId;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Repetition;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugModelExtArchiveQuestEvent) == 0x000008, "Wrong alignment on FDebugModelExtArchiveQuestEvent");
static_assert(sizeof(FDebugModelExtArchiveQuestEvent) == 0x000028, "Wrong size on FDebugModelExtArchiveQuestEvent");
static_assert(offsetof(FDebugModelExtArchiveQuestEvent, Parameters) == 0x000000, "Member 'FDebugModelExtArchiveQuestEvent::Parameters' has a wrong offset!");
static_assert(offsetof(FDebugModelExtArchiveQuestEvent, QuestEventId) == 0x000010, "Member 'FDebugModelExtArchiveQuestEvent::QuestEventId' has a wrong offset!");
static_assert(offsetof(FDebugModelExtArchiveQuestEvent, Repetition) == 0x000020, "Member 'FDebugModelExtArchiveQuestEvent::Repetition' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugModelExtArchiveQuestSpecialBehaviours
// 0x0020 (0x0020 - 0x0000)
struct FDebugModelExtArchiveQuestSpecialBehaviours final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Params;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugModelExtArchiveQuestSpecialBehaviours) == 0x000008, "Wrong alignment on FDebugModelExtArchiveQuestSpecialBehaviours");
static_assert(sizeof(FDebugModelExtArchiveQuestSpecialBehaviours) == 0x000020, "Wrong size on FDebugModelExtArchiveQuestSpecialBehaviours");
static_assert(offsetof(FDebugModelExtArchiveQuestSpecialBehaviours, Id) == 0x000000, "Member 'FDebugModelExtArchiveQuestSpecialBehaviours::Id' has a wrong offset!");
static_assert(offsetof(FDebugModelExtArchiveQuestSpecialBehaviours, Params) == 0x000010, "Member 'FDebugModelExtArchiveQuestSpecialBehaviours::Params' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugQuestModelExtArchiveCondition
// 0x0020 (0x0020 - 0x0000)
struct FDebugQuestModelExtArchiveCondition final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Value;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugQuestModelExtArchiveCondition) == 0x000008, "Wrong alignment on FDebugQuestModelExtArchiveCondition");
static_assert(sizeof(FDebugQuestModelExtArchiveCondition) == 0x000020, "Wrong size on FDebugQuestModelExtArchiveCondition");
static_assert(offsetof(FDebugQuestModelExtArchiveCondition, Key) == 0x000000, "Member 'FDebugQuestModelExtArchiveCondition::Key' has a wrong offset!");
static_assert(offsetof(FDebugQuestModelExtArchiveCondition, Value) == 0x000010, "Member 'FDebugQuestModelExtArchiveCondition::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3OnlineConfig
// 0x0020 (0x0020 - 0x0000)
struct FS3OnlineConfig final
{
public:
	TArray<int32>                                 HiddenProgressiveQueueDelays;                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         HiddenQueueDelayResetThreshold;                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomQueueDelayMin;                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomQueueDelayMax;                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3OnlineConfig) == 0x000008, "Wrong alignment on FS3OnlineConfig");
static_assert(sizeof(FS3OnlineConfig) == 0x000020, "Wrong size on FS3OnlineConfig");
static_assert(offsetof(FS3OnlineConfig, HiddenProgressiveQueueDelays) == 0x000000, "Member 'FS3OnlineConfig::HiddenProgressiveQueueDelays' has a wrong offset!");
static_assert(offsetof(FS3OnlineConfig, HiddenQueueDelayResetThreshold) == 0x000010, "Member 'FS3OnlineConfig::HiddenQueueDelayResetThreshold' has a wrong offset!");
static_assert(offsetof(FS3OnlineConfig, RandomQueueDelayMin) == 0x000014, "Member 'FS3OnlineConfig::RandomQueueDelayMin' has a wrong offset!");
static_assert(offsetof(FS3OnlineConfig, RandomQueueDelayMax) == 0x000018, "Member 'FS3OnlineConfig::RandomQueueDelayMax' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugQuestModelExtArchiveObjective
// 0x0038 (0x0038 - 0x0000)
struct FDebugQuestModelExtArchiveObjective final
{
public:
	TArray<struct FDebugQuestModelExtArchiveCondition> Conditions;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NeededProgression;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDebugModelExtArchiveQuestEvent> QuestEvents;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDebugModelExtArchiveQuestSpecialBehaviours> SpecialBehaviours;                    // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugQuestModelExtArchiveObjective) == 0x000008, "Wrong alignment on FDebugQuestModelExtArchiveObjective");
static_assert(sizeof(FDebugQuestModelExtArchiveObjective) == 0x000038, "Wrong size on FDebugQuestModelExtArchiveObjective");
static_assert(offsetof(FDebugQuestModelExtArchiveObjective, Conditions) == 0x000000, "Member 'FDebugQuestModelExtArchiveObjective::Conditions' has a wrong offset!");
static_assert(offsetof(FDebugQuestModelExtArchiveObjective, NeededProgression) == 0x000010, "Member 'FDebugQuestModelExtArchiveObjective::NeededProgression' has a wrong offset!");
static_assert(offsetof(FDebugQuestModelExtArchiveObjective, QuestEvents) == 0x000018, "Member 'FDebugQuestModelExtArchiveObjective::QuestEvents' has a wrong offset!");
static_assert(offsetof(FDebugQuestModelExtArchiveObjective, SpecialBehaviours) == 0x000028, "Member 'FDebugQuestModelExtArchiveObjective::SpecialBehaviours' has a wrong offset!");

// ScriptStruct DeadByDaylight.DedicatedServerGameConfig
// 0x0010 (0x0010 - 0x0000)
struct FDedicatedServerGameConfig final
{
public:
	int32                                         LatencyRetryCooldownSeconds;                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewContentShutdown;                                // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewContentShutdownMaxMinutes;                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewContentShutdownMinMinutes;                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDedicatedServerGameConfig) == 0x000004, "Wrong alignment on FDedicatedServerGameConfig");
static_assert(sizeof(FDedicatedServerGameConfig) == 0x000010, "Wrong size on FDedicatedServerGameConfig");
static_assert(offsetof(FDedicatedServerGameConfig, LatencyRetryCooldownSeconds) == 0x000000, "Member 'FDedicatedServerGameConfig::LatencyRetryCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FDedicatedServerGameConfig, NewContentShutdown) == 0x000004, "Member 'FDedicatedServerGameConfig::NewContentShutdown' has a wrong offset!");
static_assert(offsetof(FDedicatedServerGameConfig, NewContentShutdownMaxMinutes) == 0x000008, "Member 'FDedicatedServerGameConfig::NewContentShutdownMaxMinutes' has a wrong offset!");
static_assert(offsetof(FDedicatedServerGameConfig, NewContentShutdownMinMinutes) == 0x00000C, "Member 'FDedicatedServerGameConfig::NewContentShutdownMinMinutes' has a wrong offset!");

// ScriptStruct DeadByDaylight.DedicatedSessionSearchCompletedEventData
// 0x0058 (0x0058 - 0x0000)
struct FDedicatedSessionSearchCompletedEventData final
{
public:
	class FString                                 GameLiftSessionId;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchId;                                           // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FleetId;                                           // 0x0020(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IpAddress;                                         // 0x0030(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DnsName;                                           // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDedicatedSessionSearchCompletedEventData) == 0x000008, "Wrong alignment on FDedicatedSessionSearchCompletedEventData");
static_assert(sizeof(FDedicatedSessionSearchCompletedEventData) == 0x000058, "Wrong size on FDedicatedSessionSearchCompletedEventData");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, GameLiftSessionId) == 0x000000, "Member 'FDedicatedSessionSearchCompletedEventData::GameLiftSessionId' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, MatchId) == 0x000010, "Member 'FDedicatedSessionSearchCompletedEventData::MatchId' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, FleetId) == 0x000020, "Member 'FDedicatedSessionSearchCompletedEventData::FleetId' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, IpAddress) == 0x000030, "Member 'FDedicatedSessionSearchCompletedEventData::IpAddress' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, Port) == 0x000040, "Member 'FDedicatedSessionSearchCompletedEventData::Port' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, DnsName) == 0x000048, "Member 'FDedicatedSessionSearchCompletedEventData::DnsName' has a wrong offset!");

// ScriptStruct DeadByDaylight.ResolutionQualityPair
// 0x0018 (0x0020 - 0x0008)
struct FResolutionQualityPair final : public FDBDTableRowBase
{
public:
	int32                                         ResX;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResY;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoAdjust;                                        // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScreenScaleForWindowedMode;                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenResolution;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResolutionQualityPair) == 0x000008, "Wrong alignment on FResolutionQualityPair");
static_assert(sizeof(FResolutionQualityPair) == 0x000020, "Wrong size on FResolutionQualityPair");
static_assert(offsetof(FResolutionQualityPair, ResX) == 0x000008, "Member 'FResolutionQualityPair::ResX' has a wrong offset!");
static_assert(offsetof(FResolutionQualityPair, ResY) == 0x00000C, "Member 'FResolutionQualityPair::ResY' has a wrong offset!");
static_assert(offsetof(FResolutionQualityPair, Quality) == 0x000010, "Member 'FResolutionQualityPair::Quality' has a wrong offset!");
static_assert(offsetof(FResolutionQualityPair, AutoAdjust) == 0x000014, "Member 'FResolutionQualityPair::AutoAdjust' has a wrong offset!");
static_assert(offsetof(FResolutionQualityPair, ScreenScaleForWindowedMode) == 0x000018, "Member 'FResolutionQualityPair::ScreenScaleForWindowedMode' has a wrong offset!");
static_assert(offsetof(FResolutionQualityPair, ScreenResolution) == 0x00001C, "Member 'FResolutionQualityPair::ScreenResolution' has a wrong offset!");

// ScriptStruct DeadByDaylight.PCDeviceProfiles
// 0x0028 (0x0030 - 0x0008)
struct FPCDeviceProfiles final : public FDBDTableRowBase
{
public:
	class FName                                   CPU;                                               // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GPU;                                               // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FResolutionQualityPair>         Pairs;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCDeviceProfiles) == 0x000008, "Wrong alignment on FPCDeviceProfiles");
static_assert(sizeof(FPCDeviceProfiles) == 0x000030, "Wrong size on FPCDeviceProfiles");
static_assert(offsetof(FPCDeviceProfiles, CPU) == 0x000008, "Member 'FPCDeviceProfiles::CPU' has a wrong offset!");
static_assert(offsetof(FPCDeviceProfiles, GPU) == 0x000014, "Member 'FPCDeviceProfiles::GPU' has a wrong offset!");
static_assert(offsetof(FPCDeviceProfiles, Pairs) == 0x000020, "Member 'FPCDeviceProfiles::Pairs' has a wrong offset!");

// ScriptStruct DeadByDaylight.PromoPackItemData
// 0x0030 (0x0030 - 0x0000)
struct FPromoPackItemData final
{
public:
	class UTexture2D*                             ItemIcon;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemID;                                            // 0x0008(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   ItemRarity;                                        // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x14];                                      // 0x001C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPromoPackItemData) == 0x000008, "Wrong alignment on FPromoPackItemData");
static_assert(sizeof(FPromoPackItemData) == 0x000030, "Wrong size on FPromoPackItemData");
static_assert(offsetof(FPromoPackItemData, ItemIcon) == 0x000000, "Member 'FPromoPackItemData::ItemIcon' has a wrong offset!");
static_assert(offsetof(FPromoPackItemData, ItemID) == 0x000008, "Member 'FPromoPackItemData::ItemID' has a wrong offset!");
static_assert(offsetof(FPromoPackItemData, ItemRarity) == 0x000014, "Member 'FPromoPackItemData::ItemRarity' has a wrong offset!");
static_assert(offsetof(FPromoPackItemData, Amount) == 0x000018, "Member 'FPromoPackItemData::Amount' has a wrong offset!");

// ScriptStruct DeadByDaylight.AkEventWithSubtitle
// 0x0038 (0x0038 - 0x0000)
struct FAkEventWithSubtitle final
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weight;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSubtitles;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomSoundFXData>             RequiredAudioSwitch;                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCustomSoundFXData>             ForbiddenAudioSwitch;                              // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        DelayMsBeforeSubtitles;                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkEventWithSubtitle) == 0x000008, "Wrong alignment on FAkEventWithSubtitle");
static_assert(sizeof(FAkEventWithSubtitle) == 0x000038, "Wrong size on FAkEventWithSubtitle");
static_assert(offsetof(FAkEventWithSubtitle, AudioEvent) == 0x000000, "Member 'FAkEventWithSubtitle::AudioEvent' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, Weight) == 0x000008, "Member 'FAkEventWithSubtitle::Weight' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, HasSubtitles) == 0x000009, "Member 'FAkEventWithSubtitle::HasSubtitles' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, RequiredAudioSwitch) == 0x000010, "Member 'FAkEventWithSubtitle::RequiredAudioSwitch' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, ForbiddenAudioSwitch) == 0x000020, "Member 'FAkEventWithSubtitle::ForbiddenAudioSwitch' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, DelayMsBeforeSubtitles) == 0x000030, "Member 'FAkEventWithSubtitle::DelayMsBeforeSubtitles' has a wrong offset!");

// ScriptStruct DeadByDaylight.DialogPlannedPlayback
// 0x0020 (0x0020 - 0x0000)
struct FDialogPlannedPlayback final
{
public:
	TArray<struct FAkEventWithSubtitle>           PlannedClip;                                       // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameEventTrigger;                                  // 0x0010(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDeletingAfterTrigger;                            // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogPlannedPlayback) == 0x000008, "Wrong alignment on FDialogPlannedPlayback");
static_assert(sizeof(FDialogPlannedPlayback) == 0x000020, "Wrong size on FDialogPlannedPlayback");
static_assert(offsetof(FDialogPlannedPlayback, PlannedClip) == 0x000000, "Member 'FDialogPlannedPlayback::PlannedClip' has a wrong offset!");
static_assert(offsetof(FDialogPlannedPlayback, GameEventTrigger) == 0x000010, "Member 'FDialogPlannedPlayback::GameEventTrigger' has a wrong offset!");
static_assert(offsetof(FDialogPlannedPlayback, IsDeletingAfterTrigger) == 0x00001C, "Member 'FDialogPlannedPlayback::IsDeletingAfterTrigger' has a wrong offset!");

// ScriptStruct DeadByDaylight.DialogClipSettings
// 0x0028 (0x0028 - 0x0000)
struct FDialogClipSettings final
{
public:
	class UAkAudioEvent*                          Clip;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDialogHandlerCondition>    ConditionClass;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogHandlerCondition*                Condition;                                         // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnlyPlayingOnce;                                 // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogClipSettings) == 0x000008, "Wrong alignment on FDialogClipSettings");
static_assert(sizeof(FDialogClipSettings) == 0x000028, "Wrong size on FDialogClipSettings");
static_assert(offsetof(FDialogClipSettings, Clip) == 0x000000, "Member 'FDialogClipSettings::Clip' has a wrong offset!");
static_assert(offsetof(FDialogClipSettings, ConditionClass) == 0x000008, "Member 'FDialogClipSettings::ConditionClass' has a wrong offset!");
static_assert(offsetof(FDialogClipSettings, Condition) == 0x000010, "Member 'FDialogClipSettings::Condition' has a wrong offset!");
static_assert(offsetof(FDialogClipSettings, Priority) == 0x000018, "Member 'FDialogClipSettings::Priority' has a wrong offset!");
static_assert(offsetof(FDialogClipSettings, Weight) == 0x00001C, "Member 'FDialogClipSettings::Weight' has a wrong offset!");
static_assert(offsetof(FDialogClipSettings, IsOnlyPlayingOnce) == 0x000020, "Member 'FDialogClipSettings::IsOnlyPlayingOnce' has a wrong offset!");

// ScriptStruct DeadByDaylight.DialogEventSettings
// 0x0030 (0x0030 - 0x0000)
struct FDialogEventSettings final
{
public:
	struct FGameplayTag                           GameEventTrigger;                                  // 0x0000(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDialogClipSettings>            Clips;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          OverrideCurrentAudio;                              // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayUntilPlay;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayProbability;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogEventSettings) == 0x000008, "Wrong alignment on FDialogEventSettings");
static_assert(sizeof(FDialogEventSettings) == 0x000030, "Wrong size on FDialogEventSettings");
static_assert(offsetof(FDialogEventSettings, GameEventTrigger) == 0x000000, "Member 'FDialogEventSettings::GameEventTrigger' has a wrong offset!");
static_assert(offsetof(FDialogEventSettings, Clips) == 0x000010, "Member 'FDialogEventSettings::Clips' has a wrong offset!");
static_assert(offsetof(FDialogEventSettings, OverrideCurrentAudio) == 0x000020, "Member 'FDialogEventSettings::OverrideCurrentAudio' has a wrong offset!");
static_assert(offsetof(FDialogEventSettings, DelayUntilPlay) == 0x000024, "Member 'FDialogEventSettings::DelayUntilPlay' has a wrong offset!");
static_assert(offsetof(FDialogEventSettings, PlayProbability) == 0x000028, "Member 'FDialogEventSettings::PlayProbability' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3PrestigeRewardItem
// 0x0028 (0x0028 - 0x0000)
struct FS3PrestigeRewardItem final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RewardType;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkLevel;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PerkLevel_IsSet;                                   // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3PrestigeRewardItem) == 0x000008, "Wrong alignment on FS3PrestigeRewardItem");
static_assert(sizeof(FS3PrestigeRewardItem) == 0x000028, "Wrong size on FS3PrestigeRewardItem");
static_assert(offsetof(FS3PrestigeRewardItem, Id) == 0x000000, "Member 'FS3PrestigeRewardItem::Id' has a wrong offset!");
static_assert(offsetof(FS3PrestigeRewardItem, RewardType) == 0x000010, "Member 'FS3PrestigeRewardItem::RewardType' has a wrong offset!");
static_assert(offsetof(FS3PrestigeRewardItem, PerkLevel) == 0x000020, "Member 'FS3PrestigeRewardItem::PerkLevel' has a wrong offset!");
static_assert(offsetof(FS3PrestigeRewardItem, PerkLevel_IsSet) == 0x000024, "Member 'FS3PrestigeRewardItem::PerkLevel_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.GeneratorQueryHandlePair
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FGeneratorQueryHandlePair final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGeneratorQueryHandlePair) == 0x000008, "Wrong alignment on FGeneratorQueryHandlePair");
static_assert(sizeof(FGeneratorQueryHandlePair) == 0x000028, "Wrong size on FGeneratorQueryHandlePair");

// ScriptStruct DeadByDaylight.DisplayStandControllerData
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FDisplayStandControllerData final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDisplayStandControllerData) == 0x000008, "Wrong alignment on FDisplayStandControllerData");
static_assert(sizeof(FDisplayStandControllerData) == 0x000070, "Wrong size on FDisplayStandControllerData");

// ScriptStruct DeadByDaylight.DownloadProgression
// 0x0030 (0x0030 - 0x0000)
struct FDownloadProgression final
{
public:
	float                                         DownloadSize;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDownloadedSize;                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownloadSpeed;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstallProgress;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDownloading;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DownloadStatus;                                    // 0x0018(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDownloadProgression) == 0x000008, "Wrong alignment on FDownloadProgression");
static_assert(sizeof(FDownloadProgression) == 0x000030, "Wrong size on FDownloadProgression");
static_assert(offsetof(FDownloadProgression, DownloadSize) == 0x000000, "Member 'FDownloadProgression::DownloadSize' has a wrong offset!");
static_assert(offsetof(FDownloadProgression, TotalDownloadedSize) == 0x000004, "Member 'FDownloadProgression::TotalDownloadedSize' has a wrong offset!");
static_assert(offsetof(FDownloadProgression, DownloadSpeed) == 0x000008, "Member 'FDownloadProgression::DownloadSpeed' has a wrong offset!");
static_assert(offsetof(FDownloadProgression, InstallProgress) == 0x00000C, "Member 'FDownloadProgression::InstallProgress' has a wrong offset!");
static_assert(offsetof(FDownloadProgression, IsDownloading) == 0x000010, "Member 'FDownloadProgression::IsDownloading' has a wrong offset!");
static_assert(offsetof(FDownloadProgression, DownloadStatus) == 0x000018, "Member 'FDownloadProgression::DownloadStatus' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScoreEventRewards
// 0x0018 (0x0018 - 0x0000)
struct FScoreEventRewards final
{
public:
	int32                                         Weight;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Rewards;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreEventRewards) == 0x000008, "Wrong alignment on FScoreEventRewards");
static_assert(sizeof(FScoreEventRewards) == 0x000018, "Wrong size on FScoreEventRewards");
static_assert(offsetof(FScoreEventRewards, Weight) == 0x000000, "Member 'FScoreEventRewards::Weight' has a wrong offset!");
static_assert(offsetof(FScoreEventRewards, Rewards) == 0x000008, "Member 'FScoreEventRewards::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.EffectsLocatorTargets
// 0x0008 (0x0008 - 0x0000)
struct FEffectsLocatorTargets final
{
public:
	TSubclassOf<class AActor>                     TargetActorClass;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectsLocatorTargets) == 0x000008, "Wrong alignment on FEffectsLocatorTargets");
static_assert(sizeof(FEffectsLocatorTargets) == 0x000008, "Wrong size on FEffectsLocatorTargets");
static_assert(offsetof(FEffectsLocatorTargets, TargetActorClass) == 0x000000, "Member 'FEffectsLocatorTargets::TargetActorClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.EmblemTooltipData
// 0x0070 (0x0108 - 0x0098)
struct FEmblemTooltipData final : public FBaseTooltipData
{
public:
	struct FEmblemSlotData                        EmblemSlotData;                                    // 0x0098(0x0070)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmblemTooltipData) == 0x000008, "Wrong alignment on FEmblemTooltipData");
static_assert(sizeof(FEmblemTooltipData) == 0x000108, "Wrong size on FEmblemTooltipData");
static_assert(offsetof(FEmblemTooltipData, EmblemSlotData) == 0x000098, "Member 'FEmblemTooltipData::EmblemSlotData' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerItemProperty
// 0x0070 (0x0070 - 0x0000)
struct FKillerItemProperty final
{
public:
	TSoftClassPtr<class UClass>                   Object;                                            // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            Population;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGameplayElementType                          _gameplayElementType;                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   IterativeWeightAdjustmentStrategyClass;            // 0x0040(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FKillerItemProperty) == 0x000008, "Wrong alignment on FKillerItemProperty");
static_assert(sizeof(FKillerItemProperty) == 0x000070, "Wrong size on FKillerItemProperty");
static_assert(offsetof(FKillerItemProperty, Object) == 0x000000, "Member 'FKillerItemProperty::Object' has a wrong offset!");
static_assert(offsetof(FKillerItemProperty, Population) == 0x000030, "Member 'FKillerItemProperty::Population' has a wrong offset!");
static_assert(offsetof(FKillerItemProperty, _gameplayElementType) == 0x000038, "Member 'FKillerItemProperty::_gameplayElementType' has a wrong offset!");
static_assert(offsetof(FKillerItemProperty, IterativeWeightAdjustmentStrategyClass) == 0x000040, "Member 'FKillerItemProperty::IterativeWeightAdjustmentStrategyClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerItemDependencies
// 0x0018 (0x0020 - 0x0008)
struct FKillerItemDependencies final : public FDBDTableRowBase
{
public:
	EKillerAbilities                              KillerAbility;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKillerItemProperty>            Items;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillerItemDependencies) == 0x000008, "Wrong alignment on FKillerItemDependencies");
static_assert(sizeof(FKillerItemDependencies) == 0x000020, "Wrong size on FKillerItemDependencies");
static_assert(offsetof(FKillerItemDependencies, KillerAbility) == 0x000008, "Member 'FKillerItemDependencies::KillerAbility' has a wrong offset!");
static_assert(offsetof(FKillerItemDependencies, Items) == 0x000010, "Member 'FKillerItemDependencies::Items' has a wrong offset!");

// ScriptStruct DeadByDaylight.SubstitutionElements
// 0x0060 (0x0060 - 0x0000)
struct FSubstitutionElements final
{
public:
	TSoftClassPtr<class UClass>                   _elementToReplace;                                 // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _elementToReplaceWith;                             // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSubstitutionElements) == 0x000008, "Wrong alignment on FSubstitutionElements");
static_assert(sizeof(FSubstitutionElements) == 0x000060, "Wrong size on FSubstitutionElements");
static_assert(offsetof(FSubstitutionElements, _elementToReplace) == 0x000000, "Member 'FSubstitutionElements::_elementToReplace' has a wrong offset!");
static_assert(offsetof(FSubstitutionElements, _elementToReplaceWith) == 0x000030, "Member 'FSubstitutionElements::_elementToReplaceWith' has a wrong offset!");

// ScriptStruct DeadByDaylight.ElementSubstitutions
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FElementSubstitutions
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FElementSubstitutions) == 0x000008, "Wrong alignment on FElementSubstitutions");
static_assert(sizeof(FElementSubstitutions) == 0x000010, "Wrong size on FElementSubstitutions");

// ScriptStruct DeadByDaylight.GameplayElementSubstitutions
// 0x0018 (0x0028 - 0x0010)
struct FGameplayElementSubstitutions final : public FElementSubstitutions
{
public:
	TArray<struct FSubstitutionElements>          _replacements;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	EGameplayElementType                          _type;                                             // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayElementSubstitutions) == 0x000008, "Wrong alignment on FGameplayElementSubstitutions");
static_assert(sizeof(FGameplayElementSubstitutions) == 0x000028, "Wrong size on FGameplayElementSubstitutions");
static_assert(offsetof(FGameplayElementSubstitutions, _replacements) == 0x000010, "Member 'FGameplayElementSubstitutions::_replacements' has a wrong offset!");
static_assert(offsetof(FGameplayElementSubstitutions, _type) == 0x000020, "Member 'FGameplayElementSubstitutions::_type' has a wrong offset!");

// ScriptStruct DeadByDaylight.DependencyElementSubstitutions
// 0x0018 (0x0028 - 0x0010)
struct FDependencyElementSubstitutions final : public FElementSubstitutions
{
public:
	TArray<struct FSubstitutionElements>          _replacements;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	ETileSpawnPointType                           _type;                                             // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDependencyElementSubstitutions) == 0x000008, "Wrong alignment on FDependencyElementSubstitutions");
static_assert(sizeof(FDependencyElementSubstitutions) == 0x000028, "Wrong size on FDependencyElementSubstitutions");
static_assert(offsetof(FDependencyElementSubstitutions, _replacements) == 0x000010, "Member 'FDependencyElementSubstitutions::_replacements' has a wrong offset!");
static_assert(offsetof(FDependencyElementSubstitutions, _type) == 0x000020, "Member 'FDependencyElementSubstitutions::_type' has a wrong offset!");

// ScriptStruct DeadByDaylight.DependencyElementAddition
// 0x0038 (0x0038 - 0x0000)
struct FDependencyElementAddition final
{
public:
	TSoftClassPtr<class UClass>                   _object;                                           // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETileSpawnPointType                           _type;                                             // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberToAdd;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDependencyElementAddition) == 0x000008, "Wrong alignment on FDependencyElementAddition");
static_assert(sizeof(FDependencyElementAddition) == 0x000038, "Wrong size on FDependencyElementAddition");
static_assert(offsetof(FDependencyElementAddition, _object) == 0x000000, "Member 'FDependencyElementAddition::_object' has a wrong offset!");
static_assert(offsetof(FDependencyElementAddition, _type) == 0x000030, "Member 'FDependencyElementAddition::_type' has a wrong offset!");
static_assert(offsetof(FDependencyElementAddition, _numberToAdd) == 0x000034, "Member 'FDependencyElementAddition::_numberToAdd' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameplayElementAddition
// 0x0040 (0x0040 - 0x0000)
struct FGameplayElementAddition final
{
public:
	TSoftClassPtr<class UClass>                   _elementToAdd;                                     // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGameplayElementType                          _spawnerType;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberToAdd;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _numberToAddAffectedByOffering;                    // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayElementAddition) == 0x000008, "Wrong alignment on FGameplayElementAddition");
static_assert(sizeof(FGameplayElementAddition) == 0x000040, "Wrong size on FGameplayElementAddition");
static_assert(offsetof(FGameplayElementAddition, _elementToAdd) == 0x000000, "Member 'FGameplayElementAddition::_elementToAdd' has a wrong offset!");
static_assert(offsetof(FGameplayElementAddition, _spawnerType) == 0x000030, "Member 'FGameplayElementAddition::_spawnerType' has a wrong offset!");
static_assert(offsetof(FGameplayElementAddition, _numberToAdd) == 0x000034, "Member 'FGameplayElementAddition::_numberToAdd' has a wrong offset!");
static_assert(offsetof(FGameplayElementAddition, _numberToAddAffectedByOffering) == 0x000038, "Member 'FGameplayElementAddition::_numberToAddAffectedByOffering' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventSubstitionData
// 0x0058 (0x0060 - 0x0008)
struct FEventSubstitionData final : public FDBDTableRowBase
{
public:
	class FName                                   _name;                                             // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _allowSubstitutionInKYF;                           // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _baseNumOfSubstitutionPerGroup;                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayElementSubstitutions>  _gameplaySubstitutionElements;                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDependencyElementSubstitutions> _dependencySubstitutionElements;                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDependencyElementAddition>     _dependencyElementAdditions;                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayElementAddition>       _gameplayElementAdditions;                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FEventSubstitionData) == 0x000008, "Wrong alignment on FEventSubstitionData");
static_assert(sizeof(FEventSubstitionData) == 0x000060, "Wrong size on FEventSubstitionData");
static_assert(offsetof(FEventSubstitionData, _name) == 0x000008, "Member 'FEventSubstitionData::_name' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _allowSubstitutionInKYF) == 0x000014, "Member 'FEventSubstitionData::_allowSubstitutionInKYF' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _baseNumOfSubstitutionPerGroup) == 0x000018, "Member 'FEventSubstitionData::_baseNumOfSubstitutionPerGroup' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _gameplaySubstitutionElements) == 0x000020, "Member 'FEventSubstitionData::_gameplaySubstitutionElements' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _dependencySubstitutionElements) == 0x000030, "Member 'FEventSubstitionData::_dependencySubstitutionElements' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _dependencyElementAdditions) == 0x000040, "Member 'FEventSubstitionData::_dependencyElementAdditions' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _gameplayElementAdditions) == 0x000050, "Member 'FEventSubstitionData::_gameplayElementAdditions' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutfitDropdown
// 0x000C (0x0014 - 0x0008)
struct FOutfitDropdown final : public FCharacterDropdown
{
public:
	class FName                                   OutfitId;                                          // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutfitDropdown) == 0x000004, "Wrong alignment on FOutfitDropdown");
static_assert(sizeof(FOutfitDropdown) == 0x000014, "Wrong size on FOutfitDropdown");
static_assert(offsetof(FOutfitDropdown, OutfitId) == 0x000008, "Member 'FOutfitDropdown::OutfitId' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutfitViewSetting
// 0x0048 (0x0048 - 0x0000)
struct FOutfitViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOutfitDropdown                        OutfitDropdown;                                    // 0x000C(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 Settings;                                          // 0x0020(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutfitViewSetting) == 0x000004, "Wrong alignment on FOutfitViewSetting");
static_assert(sizeof(FOutfitViewSetting) == 0x000048, "Wrong size on FOutfitViewSetting");
static_assert(offsetof(FOutfitViewSetting, Label) == 0x000000, "Member 'FOutfitViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FOutfitViewSetting, OutfitDropdown) == 0x00000C, "Member 'FOutfitViewSetting::OutfitDropdown' has a wrong offset!");
static_assert(offsetof(FOutfitViewSetting, Settings) == 0x000020, "Member 'FOutfitViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreBannersData
// 0x0098 (0x00A0 - 0x0008)
struct FStoreBannersData final : public FDBDTableRowBase
{
public:
	class FName                                   BannerId;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStoreFeaturedBannerData               BannerData;                                        // 0x0018(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          UseAsDefault;                                      // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStoreBannerLocation                          DefaultLocation;                                   // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreBannersData) == 0x000008, "Wrong alignment on FStoreBannersData");
static_assert(sizeof(FStoreBannersData) == 0x0000A0, "Wrong size on FStoreBannersData");
static_assert(offsetof(FStoreBannersData, BannerId) == 0x000008, "Member 'FStoreBannersData::BannerId' has a wrong offset!");
static_assert(offsetof(FStoreBannersData, BannerData) == 0x000018, "Member 'FStoreBannersData::BannerData' has a wrong offset!");
static_assert(offsetof(FStoreBannersData, UseAsDefault) == 0x000098, "Member 'FStoreBannersData::UseAsDefault' has a wrong offset!");
static_assert(offsetof(FStoreBannersData, DefaultLocation) == 0x000099, "Member 'FStoreBannersData::DefaultLocation' has a wrong offset!");

// ScriptStruct DeadByDaylight.PathPosition
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FPathPosition final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathPosition) == 0x000004, "Wrong alignment on FPathPosition");
static_assert(sizeof(FPathPosition) == 0x000018, "Wrong size on FPathPosition");

// ScriptStruct DeadByDaylight.ExternalEffectData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FExternalEffectData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExternalEffectData) == 0x000008, "Wrong alignment on FExternalEffectData");
static_assert(sizeof(FExternalEffectData) == 0x000038, "Wrong size on FExternalEffectData");

// ScriptStruct DeadByDaylight.FakePalletData
// 0x00D0 (0x00D8 - 0x0008)
struct FFakePalletData final : public FDBDTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   LevelPalletBP;                                     // 0x0008(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DreamPalletBP;                                     // 0x0038(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PalletTrackerBP;                                   // 0x0068(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             IllusionaryPalletStaticMesh;                       // 0x0098(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x00C8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFakePalletData) == 0x000008, "Wrong alignment on FFakePalletData");
static_assert(sizeof(FFakePalletData) == 0x0000D8, "Wrong size on FFakePalletData");
static_assert(offsetof(FFakePalletData, LevelPalletBP) == 0x000008, "Member 'FFakePalletData::LevelPalletBP' has a wrong offset!");
static_assert(offsetof(FFakePalletData, DreamPalletBP) == 0x000038, "Member 'FFakePalletData::DreamPalletBP' has a wrong offset!");
static_assert(offsetof(FFakePalletData, PalletTrackerBP) == 0x000068, "Member 'FFakePalletData::PalletTrackerBP' has a wrong offset!");
static_assert(offsetof(FFakePalletData, IllusionaryPalletStaticMesh) == 0x000098, "Member 'FFakePalletData::IllusionaryPalletStaticMesh' has a wrong offset!");
static_assert(offsetof(FFakePalletData, ID) == 0x0000C8, "Member 'FFakePalletData::ID' has a wrong offset!");

// ScriptStruct DeadByDaylight.FilterLoadoutData
// 0x0070 (0x0078 - 0x0008)
struct FFilterLoadoutData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0018(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           Role;                                              // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ELoadoutType                                  LoadoutType;                                       // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFilterLoadoutData) == 0x000008, "Wrong alignment on FFilterLoadoutData");
static_assert(sizeof(FFilterLoadoutData) == 0x000078, "Wrong size on FFilterLoadoutData");
static_assert(offsetof(FFilterLoadoutData, ID) == 0x000008, "Member 'FFilterLoadoutData::ID' has a wrong offset!");
static_assert(offsetof(FFilterLoadoutData, Icon) == 0x000018, "Member 'FFilterLoadoutData::Icon' has a wrong offset!");
static_assert(offsetof(FFilterLoadoutData, Title) == 0x000048, "Member 'FFilterLoadoutData::Title' has a wrong offset!");
static_assert(offsetof(FFilterLoadoutData, Role) == 0x000060, "Member 'FFilterLoadoutData::Role' has a wrong offset!");
static_assert(offsetof(FFilterLoadoutData, LoadoutType) == 0x000070, "Member 'FFilterLoadoutData::LoadoutType' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorItemProperties
// 0x000C (0x000C - 0x0000)
struct FSurvivorItemProperties final
{
public:
	ECollectableCategory                          Category;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPopulation;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurvivorItemProperties) == 0x000004, "Wrong alignment on FSurvivorItemProperties");
static_assert(sizeof(FSurvivorItemProperties) == 0x00000C, "Wrong size on FSurvivorItemProperties");
static_assert(offsetof(FSurvivorItemProperties, Category) == 0x000000, "Member 'FSurvivorItemProperties::Category' has a wrong offset!");
static_assert(offsetof(FSurvivorItemProperties, Weight) == 0x000004, "Member 'FSurvivorItemProperties::Weight' has a wrong offset!");
static_assert(offsetof(FSurvivorItemProperties, MaxPopulation) == 0x000008, "Member 'FSurvivorItemProperties::MaxPopulation' has a wrong offset!");

// ScriptStruct DeadByDaylight.ForceSpawnTileData
// 0x0020 (0x0020 - 0x0000)
struct FForceSpawnTileData final
{
public:
	class FString                                 name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         matrixX;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         matrixY;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         rotation;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FForceSpawnTileData) == 0x000008, "Wrong alignment on FForceSpawnTileData");
static_assert(sizeof(FForceSpawnTileData) == 0x000020, "Wrong size on FForceSpawnTileData");
static_assert(offsetof(FForceSpawnTileData, name) == 0x000000, "Member 'FForceSpawnTileData::name' has a wrong offset!");
static_assert(offsetof(FForceSpawnTileData, matrixX) == 0x000010, "Member 'FForceSpawnTileData::matrixX' has a wrong offset!");
static_assert(offsetof(FForceSpawnTileData, matrixY) == 0x000014, "Member 'FForceSpawnTileData::matrixY' has a wrong offset!");
static_assert(offsetof(FForceSpawnTileData, rotation) == 0x000018, "Member 'FForceSpawnTileData::rotation' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameplayElementsPopulation
// 0x0078 (0x0078 - 0x0000)
struct FGameplayElementsPopulation final
{
public:
	EGameplayElementType                          Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   GameplayElementBlueprint;                          // 0x0008(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinPopulation;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxPopulation;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinGuaranteePopulation;                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SpawnPass;                                         // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   IterativeWeightAdjustmentStrategyClass;            // 0x0048(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayElementsPopulation) == 0x000008, "Wrong alignment on FGameplayElementsPopulation");
static_assert(sizeof(FGameplayElementsPopulation) == 0x000078, "Wrong size on FGameplayElementsPopulation");
static_assert(offsetof(FGameplayElementsPopulation, Type) == 0x000000, "Member 'FGameplayElementsPopulation::Type' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, GameplayElementBlueprint) == 0x000008, "Member 'FGameplayElementsPopulation::GameplayElementBlueprint' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, MinPopulation) == 0x000038, "Member 'FGameplayElementsPopulation::MinPopulation' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, MaxPopulation) == 0x00003C, "Member 'FGameplayElementsPopulation::MaxPopulation' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, MinGuaranteePopulation) == 0x000040, "Member 'FGameplayElementsPopulation::MinGuaranteePopulation' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, SpawnPass) == 0x000044, "Member 'FGameplayElementsPopulation::SpawnPass' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, IterativeWeightAdjustmentStrategyClass) == 0x000048, "Member 'FGameplayElementsPopulation::IterativeWeightAdjustmentStrategyClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.FreeToPlayEventData
// 0x0030 (0x0030 - 0x0000)
struct FFreeToPlayEventData final
{
public:
	struct FFreeToPlayData                        Event;                                             // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFreeToPlayEventData) == 0x000008, "Wrong alignment on FFreeToPlayEventData");
static_assert(sizeof(FFreeToPlayEventData) == 0x000030, "Wrong size on FFreeToPlayEventData");
static_assert(offsetof(FFreeToPlayEventData, Event) == 0x000000, "Member 'FFreeToPlayEventData::Event' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3GameConfigsDSData
// 0x0058 (0x0058 - 0x0000)
struct FS3GameConfigsDSData final
{
public:
	struct FDDosGameConfigDS                      Ddos;                                              // 0x0000(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            MapHistoryWeights;                                 // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3GameConfigsDSData) == 0x000008, "Wrong alignment on FS3GameConfigsDSData");
static_assert(sizeof(FS3GameConfigsDSData) == 0x000058, "Wrong size on FS3GameConfigsDSData");
static_assert(offsetof(FS3GameConfigsDSData, Ddos) == 0x000000, "Member 'FS3GameConfigsDSData::Ddos' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsDSData, MapHistoryWeights) == 0x000008, "Member 'FS3GameConfigsDSData::MapHistoryWeights' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameEventDispatcherHandleBP
// 0x0020 (0x0020 - 0x0000)
struct FGameEventDispatcherHandleBP final
{
public:
	struct FGameplayTag                           Filter;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)> GameEventDelegate; // 0x000C(0x0014)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameEventDispatcherHandleBP) == 0x000004, "Wrong alignment on FGameEventDispatcherHandleBP");
static_assert(sizeof(FGameEventDispatcherHandleBP) == 0x000020, "Wrong size on FGameEventDispatcherHandleBP");
static_assert(offsetof(FGameEventDispatcherHandleBP, Filter) == 0x000000, "Member 'FGameEventDispatcherHandleBP::Filter' has a wrong offset!");
static_assert(offsetof(FGameEventDispatcherHandleBP, GameEventDelegate) == 0x00000C, "Member 'FGameEventDispatcherHandleBP::GameEventDelegate' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameNotificationData
// 0x0020 (0x0028 - 0x0008)
struct FGameNotificationData final : public FDBDTableRowBase
{
public:
	EPromptType                                   PromptType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPromptPriority                               Priority;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Content;                                           // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameNotificationData) == 0x000008, "Wrong alignment on FGameNotificationData");
static_assert(sizeof(FGameNotificationData) == 0x000028, "Wrong size on FGameNotificationData");
static_assert(offsetof(FGameNotificationData, PromptType) == 0x000008, "Member 'FGameNotificationData::PromptType' has a wrong offset!");
static_assert(offsetof(FGameNotificationData, Priority) == 0x000009, "Member 'FGameNotificationData::Priority' has a wrong offset!");
static_assert(offsetof(FGameNotificationData, Content) == 0x000010, "Member 'FGameNotificationData::Content' has a wrong offset!");

// ScriptStruct DeadByDaylight.NotificationHistoryElement
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FNotificationHistoryElement final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNotificationHistoryElement) == 0x000004, "Wrong alignment on FNotificationHistoryElement");
static_assert(sizeof(FNotificationHistoryElement) == 0x000018, "Wrong size on FNotificationHistoryElement");

// ScriptStruct DeadByDaylight.GameplayNotificationData
// 0x0058 (0x0058 - 0x0000)
struct FGameplayNotificationData final
{
public:
	class FName                                   SourceID;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInventoryItemType                            SourceType;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SourceIconIndex;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SourceLevel;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EffectID;                                          // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EffectIconFilePath;                                // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStatusEffectType                             EffectType;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EffectDisplayName;                                 // 0x0040(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayNotificationData) == 0x000008, "Wrong alignment on FGameplayNotificationData");
static_assert(sizeof(FGameplayNotificationData) == 0x000058, "Wrong size on FGameplayNotificationData");
static_assert(offsetof(FGameplayNotificationData, SourceID) == 0x000000, "Member 'FGameplayNotificationData::SourceID' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, SourceType) == 0x00000C, "Member 'FGameplayNotificationData::SourceType' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, SourceIconIndex) == 0x000010, "Member 'FGameplayNotificationData::SourceIconIndex' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, SourceLevel) == 0x000014, "Member 'FGameplayNotificationData::SourceLevel' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, EffectID) == 0x000018, "Member 'FGameplayNotificationData::EffectID' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, EffectIconFilePath) == 0x000028, "Member 'FGameplayNotificationData::EffectIconFilePath' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, EffectType) == 0x000038, "Member 'FGameplayNotificationData::EffectType' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, EffectDisplayName) == 0x000040, "Member 'FGameplayNotificationData::EffectDisplayName' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoudNoiseIndicatorData
// 0x0020 (0x0020 - 0x0000)
struct FLoudNoiseIndicatorData final
{
public:
	class UStaticMeshComponent*                   MeshMask;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DistortionMesh;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTime;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoudNoiseIndicatorData) == 0x000008, "Wrong alignment on FLoudNoiseIndicatorData");
static_assert(sizeof(FLoudNoiseIndicatorData) == 0x000020, "Wrong size on FLoudNoiseIndicatorData");
static_assert(offsetof(FLoudNoiseIndicatorData, MeshMask) == 0x000000, "Member 'FLoudNoiseIndicatorData::MeshMask' has a wrong offset!");
static_assert(offsetof(FLoudNoiseIndicatorData, DistortionMesh) == 0x000008, "Member 'FLoudNoiseIndicatorData::DistortionMesh' has a wrong offset!");
static_assert(offsetof(FLoudNoiseIndicatorData, Location) == 0x000010, "Member 'FLoudNoiseIndicatorData::Location' has a wrong offset!");
static_assert(offsetof(FLoudNoiseIndicatorData, RemainingTime) == 0x00001C, "Member 'FLoudNoiseIndicatorData::RemainingTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.GarantiedRarityRingDistributionValues
// 0x0090 (0x0098 - 0x0008)
struct FGarantiedRarityRingDistributionValues final : public FDBDTableRowBase
{
public:
	int32                                         InnerRingCommonItemProbability;                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingCommonItemProbability;                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingCommonItemProbability;                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUncommonItemProbability;                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUncommonItemProbability;                 // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUncommonItemProbability;                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingRareItemProbability;                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingRareItemProbability;                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingRareItemProbability;                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingVeryRareItemProbability;                  // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingVeryRareItemProbability;                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingVeryRareItemProbability;                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUltraRareItemProbability;                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUltraRareItemProbability;                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUltraRareItemProbability;                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingArtifactItemProbability;                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingArtifactItemProbability;                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingArtifactItemProbability;                  // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSpectralItemProbability;                  // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSpectralItemProbability;                 // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSpectralItemProbability;                  // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSpecialEventItemProbability;              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSpecialEventItemProbability;             // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSpecialEventItemProbability;              // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingLegendaryItemProbability;                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingLegendaryItemProbability;                // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingLegendaryItemProbability;                 // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingEpicItemProbability;                      // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingEpicItemProbability;                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingEpicItemProbability;                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSuperEpicItemProbability;                 // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSuperEpicItemProbability;                // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSuperEpicItemProbability;                 // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUltraEpicItemProbability;                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUltraEpicItemProbability;                // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUltraEpicItemProbability;                 // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGarantiedRarityRingDistributionValues) == 0x000008, "Wrong alignment on FGarantiedRarityRingDistributionValues");
static_assert(sizeof(FGarantiedRarityRingDistributionValues) == 0x000098, "Wrong size on FGarantiedRarityRingDistributionValues");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingCommonItemProbability) == 0x000008, "Member 'FGarantiedRarityRingDistributionValues::InnerRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingCommonItemProbability) == 0x00000C, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingCommonItemProbability) == 0x000010, "Member 'FGarantiedRarityRingDistributionValues::OuterRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingUncommonItemProbability) == 0x000014, "Member 'FGarantiedRarityRingDistributionValues::InnerRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingUncommonItemProbability) == 0x000018, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingUncommonItemProbability) == 0x00001C, "Member 'FGarantiedRarityRingDistributionValues::OuterRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingRareItemProbability) == 0x000020, "Member 'FGarantiedRarityRingDistributionValues::InnerRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingRareItemProbability) == 0x000024, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingRareItemProbability) == 0x000028, "Member 'FGarantiedRarityRingDistributionValues::OuterRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingVeryRareItemProbability) == 0x00002C, "Member 'FGarantiedRarityRingDistributionValues::InnerRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingVeryRareItemProbability) == 0x000030, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingVeryRareItemProbability) == 0x000034, "Member 'FGarantiedRarityRingDistributionValues::OuterRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingUltraRareItemProbability) == 0x000038, "Member 'FGarantiedRarityRingDistributionValues::InnerRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingUltraRareItemProbability) == 0x00003C, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingUltraRareItemProbability) == 0x000040, "Member 'FGarantiedRarityRingDistributionValues::OuterRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingArtifactItemProbability) == 0x000044, "Member 'FGarantiedRarityRingDistributionValues::InnerRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingArtifactItemProbability) == 0x000048, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingArtifactItemProbability) == 0x00004C, "Member 'FGarantiedRarityRingDistributionValues::OuterRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingSpectralItemProbability) == 0x000050, "Member 'FGarantiedRarityRingDistributionValues::InnerRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingSpectralItemProbability) == 0x000054, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingSpectralItemProbability) == 0x000058, "Member 'FGarantiedRarityRingDistributionValues::OuterRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingSpecialEventItemProbability) == 0x00005C, "Member 'FGarantiedRarityRingDistributionValues::InnerRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingSpecialEventItemProbability) == 0x000060, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingSpecialEventItemProbability) == 0x000064, "Member 'FGarantiedRarityRingDistributionValues::OuterRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingLegendaryItemProbability) == 0x000068, "Member 'FGarantiedRarityRingDistributionValues::InnerRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingLegendaryItemProbability) == 0x00006C, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingLegendaryItemProbability) == 0x000070, "Member 'FGarantiedRarityRingDistributionValues::OuterRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingEpicItemProbability) == 0x000074, "Member 'FGarantiedRarityRingDistributionValues::InnerRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingEpicItemProbability) == 0x000078, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingEpicItemProbability) == 0x00007C, "Member 'FGarantiedRarityRingDistributionValues::OuterRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingSuperEpicItemProbability) == 0x000080, "Member 'FGarantiedRarityRingDistributionValues::InnerRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingSuperEpicItemProbability) == 0x000084, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingSuperEpicItemProbability) == 0x000088, "Member 'FGarantiedRarityRingDistributionValues::OuterRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingUltraEpicItemProbability) == 0x00008C, "Member 'FGarantiedRarityRingDistributionValues::InnerRingUltraEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingUltraEpicItemProbability) == 0x000090, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingUltraEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingUltraEpicItemProbability) == 0x000094, "Member 'FGarantiedRarityRingDistributionValues::OuterRingUltraEpicItemProbability' has a wrong offset!");

// ScriptStruct DeadByDaylight.ProfileLoadEventData
// 0x0010 (0x0010 - 0x0000)
struct FProfileLoadEventData final
{
public:
	bool                                          FirstTimePlaying;                                  // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProfileLoadEventData) == 0x000008, "Wrong alignment on FProfileLoadEventData");
static_assert(sizeof(FProfileLoadEventData) == 0x000010, "Wrong size on FProfileLoadEventData");
static_assert(offsetof(FProfileLoadEventData, FirstTimePlaying) == 0x000000, "Member 'FProfileLoadEventData::FirstTimePlaying' has a wrong offset!");
static_assert(offsetof(FProfileLoadEventData, Timestamp) == 0x000008, "Member 'FProfileLoadEventData::Timestamp' has a wrong offset!");

// ScriptStruct DeadByDaylight.DamageData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FDamageData final
{
public:
	bool                                          _isRegressing;                                     // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isIntense;                                        // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayer>              _lastDamageChangeSource;                           // 0x0004(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x14];                                       // 0x000C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageData) == 0x000008, "Wrong alignment on FDamageData");
static_assert(sizeof(FDamageData) == 0x000020, "Wrong size on FDamageData");
static_assert(offsetof(FDamageData, _isRegressing) == 0x000000, "Member 'FDamageData::_isRegressing' has a wrong offset!");
static_assert(offsetof(FDamageData, _isIntense) == 0x000001, "Member 'FDamageData::_isIntense' has a wrong offset!");
static_assert(offsetof(FDamageData, _lastDamageChangeSource) == 0x000004, "Member 'FDamageData::_lastDamageChangeSource' has a wrong offset!");

// ScriptStruct DeadByDaylight.ReflectionCaptureTwoStates
// 0x0030 (0x0030 - 0x0000)
struct FReflectionCaptureTwoStates final
{
public:
	struct FComponentReference                    ComponentReference;                                // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FReflectionCaptureTwoStates) == 0x000008, "Wrong alignment on FReflectionCaptureTwoStates");
static_assert(sizeof(FReflectionCaptureTwoStates) == 0x000030, "Wrong size on FReflectionCaptureTwoStates");
static_assert(offsetof(FReflectionCaptureTwoStates, ComponentReference) == 0x000000, "Member 'FReflectionCaptureTwoStates::ComponentReference' has a wrong offset!");

// ScriptStruct DeadByDaylight.HintData
// 0x0058 (0x0060 - 0x0008)
struct FHintData final : public FDBDTableRowBase
{
public:
	EHintCategory                                 Category;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         levelMin;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         levelMax;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         relevantCharacterID;                               // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHintData) == 0x000008, "Wrong alignment on FHintData");
static_assert(sizeof(FHintData) == 0x000060, "Wrong size on FHintData");
static_assert(offsetof(FHintData, Category) == 0x000008, "Member 'FHintData::Category' has a wrong offset!");
static_assert(offsetof(FHintData, Title) == 0x000010, "Member 'FHintData::Title' has a wrong offset!");
static_assert(offsetof(FHintData, Description) == 0x000028, "Member 'FHintData::Description' has a wrong offset!");
static_assert(offsetof(FHintData, IconPath) == 0x000040, "Member 'FHintData::IconPath' has a wrong offset!");
static_assert(offsetof(FHintData, levelMin) == 0x000050, "Member 'FHintData::levelMin' has a wrong offset!");
static_assert(offsetof(FHintData, levelMax) == 0x000054, "Member 'FHintData::levelMax' has a wrong offset!");
static_assert(offsetof(FHintData, relevantCharacterID) == 0x000058, "Member 'FHintData::relevantCharacterID' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankUIData
// 0x0060 (0x0068 - 0x0008)
struct FRankUIData final : public FDBDTableRowBase
{
public:
	int32                                         Rank;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            Color;                                             // 0x0010(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Frame;                                             // 0x0038(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankUIData) == 0x000008, "Wrong alignment on FRankUIData");
static_assert(sizeof(FRankUIData) == 0x000068, "Wrong size on FRankUIData");
static_assert(offsetof(FRankUIData, Rank) == 0x000008, "Member 'FRankUIData::Rank' has a wrong offset!");
static_assert(offsetof(FRankUIData, PlayerRole) == 0x00000C, "Member 'FRankUIData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FRankUIData, Color) == 0x000010, "Member 'FRankUIData::Color' has a wrong offset!");
static_assert(offsetof(FRankUIData, Frame) == 0x000038, "Member 'FRankUIData::Frame' has a wrong offset!");

// ScriptStruct DeadByDaylight.HitValidationEditorConfig
// 0x0010 (0x0018 - 0x0008)
struct FHitValidationEditorConfig final : public FTableRowBase
{
public:
	EHitValidatorConfigName                       ConfigName;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleInflation;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistance;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitValidationEditorConfig) == 0x000008, "Wrong alignment on FHitValidationEditorConfig");
static_assert(sizeof(FHitValidationEditorConfig) == 0x000018, "Wrong size on FHitValidationEditorConfig");
static_assert(offsetof(FHitValidationEditorConfig, ConfigName) == 0x000008, "Member 'FHitValidationEditorConfig::ConfigName' has a wrong offset!");
static_assert(offsetof(FHitValidationEditorConfig, CapsuleInflation) == 0x00000C, "Member 'FHitValidationEditorConfig::CapsuleInflation' has a wrong offset!");
static_assert(offsetof(FHitValidationEditorConfig, MaximumDistance) == 0x000010, "Member 'FHitValidationEditorConfig::MaximumDistance' has a wrong offset!");

// ScriptStruct DeadByDaylight.HitValidationRecorder
// 0x0004 (0x0004 - 0x0000)
struct FHitValidationRecorder final
{
public:
	float                                         CacheTimespan;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitValidationRecorder) == 0x000004, "Wrong alignment on FHitValidationRecorder");
static_assert(sizeof(FHitValidationRecorder) == 0x000004, "Wrong size on FHitValidationRecorder");
static_assert(offsetof(FHitValidationRecorder, CacheTimespan) == 0x000000, "Member 'FHitValidationRecorder::CacheTimespan' has a wrong offset!");

// ScriptStruct DeadByDaylight.HitValidationGameConfig
// 0x0018 (0x0018 - 0x0000)
struct FHitValidationGameConfig final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableCollisionCheck;                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitValidationRecorder                 Recorder;                                          // 0x0004(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FHitValidationValidator>        Validators;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitValidationGameConfig) == 0x000008, "Wrong alignment on FHitValidationGameConfig");
static_assert(sizeof(FHitValidationGameConfig) == 0x000018, "Wrong size on FHitValidationGameConfig");
static_assert(offsetof(FHitValidationGameConfig, Enable) == 0x000000, "Member 'FHitValidationGameConfig::Enable' has a wrong offset!");
static_assert(offsetof(FHitValidationGameConfig, EnableCollisionCheck) == 0x000001, "Member 'FHitValidationGameConfig::EnableCollisionCheck' has a wrong offset!");
static_assert(offsetof(FHitValidationGameConfig, Recorder) == 0x000004, "Member 'FHitValidationGameConfig::Recorder' has a wrong offset!");
static_assert(offsetof(FHitValidationGameConfig, Validators) == 0x000008, "Member 'FHitValidationGameConfig::Validators' has a wrong offset!");

// ScriptStruct DeadByDaylight.PromoPackSelectedItemData
// 0x0058 (0x0058 - 0x0000)
struct FPromoPackSelectedItemData final
{
public:
	class UTexture2D*                             ItemTypeIcon;                                      // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemName;                                          // 0x0008(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ItemSubTitle;                                      // 0x0020(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x0038(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UUMGPromoPackItemWidget*                Widget;                                            // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPromoPackSelectedItemData) == 0x000008, "Wrong alignment on FPromoPackSelectedItemData");
static_assert(sizeof(FPromoPackSelectedItemData) == 0x000058, "Wrong size on FPromoPackSelectedItemData");
static_assert(offsetof(FPromoPackSelectedItemData, ItemTypeIcon) == 0x000000, "Member 'FPromoPackSelectedItemData::ItemTypeIcon' has a wrong offset!");
static_assert(offsetof(FPromoPackSelectedItemData, ItemName) == 0x000008, "Member 'FPromoPackSelectedItemData::ItemName' has a wrong offset!");
static_assert(offsetof(FPromoPackSelectedItemData, ItemSubTitle) == 0x000020, "Member 'FPromoPackSelectedItemData::ItemSubTitle' has a wrong offset!");
static_assert(offsetof(FPromoPackSelectedItemData, ItemDescription) == 0x000038, "Member 'FPromoPackSelectedItemData::ItemDescription' has a wrong offset!");
static_assert(offsetof(FPromoPackSelectedItemData, Widget) == 0x000050, "Member 'FPromoPackSelectedItemData::Widget' has a wrong offset!");

// ScriptStruct DeadByDaylight.HookLingerTimerHandleContainer
// 0x0010 (0x0010 - 0x0000)
struct FHookLingerTimerHandleContainer final
{
public:
	class AMeatHook*                              Hook;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHookLingerTimerHandleContainer) == 0x000008, "Wrong alignment on FHookLingerTimerHandleContainer");
static_assert(sizeof(FHookLingerTimerHandleContainer) == 0x000010, "Wrong size on FHookLingerTimerHandleContainer");
static_assert(offsetof(FHookLingerTimerHandleContainer, Hook) == 0x000000, "Member 'FHookLingerTimerHandleContainer::Hook' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerInfoCache
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FPlayerInfoCache final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerInfoCache) == 0x000008, "Wrong alignment on FPlayerInfoCache");
static_assert(sizeof(FPlayerInfoCache) == 0x000038, "Wrong size on FPlayerInfoCache");

// ScriptStruct DeadByDaylight.RewardItemData
// 0x0038 (0x0038 - 0x0000)
struct FRewardItemData final
{
public:
	class FString                                 IconPath;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDuplicate;                                       // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyAmount;                                    // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardItemData) == 0x000008, "Wrong alignment on FRewardItemData");
static_assert(sizeof(FRewardItemData) == 0x000038, "Wrong size on FRewardItemData");
static_assert(offsetof(FRewardItemData, IconPath) == 0x000000, "Member 'FRewardItemData::IconPath' has a wrong offset!");
static_assert(offsetof(FRewardItemData, Title) == 0x000010, "Member 'FRewardItemData::Title' has a wrong offset!");
static_assert(offsetof(FRewardItemData, Description) == 0x000020, "Member 'FRewardItemData::Description' has a wrong offset!");
static_assert(offsetof(FRewardItemData, Rarity) == 0x000030, "Member 'FRewardItemData::Rarity' has a wrong offset!");
static_assert(offsetof(FRewardItemData, ItemType) == 0x000031, "Member 'FRewardItemData::ItemType' has a wrong offset!");
static_assert(offsetof(FRewardItemData, IsDuplicate) == 0x000032, "Member 'FRewardItemData::IsDuplicate' has a wrong offset!");
static_assert(offsetof(FRewardItemData, CurrencyType) == 0x000033, "Member 'FRewardItemData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FRewardItemData, CurrencyAmount) == 0x000034, "Member 'FRewardItemData::CurrencyAmount' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractionRequest
// 0x0018 (0x0018 - 0x0000)
struct FInteractionRequest final
{
public:
	class UInteractionDefinition*                 _interaction;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _requester;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInteractionRequest) == 0x000008, "Wrong alignment on FInteractionRequest");
static_assert(sizeof(FInteractionRequest) == 0x000018, "Wrong size on FInteractionRequest");
static_assert(offsetof(FInteractionRequest, _interaction) == 0x000000, "Member 'FInteractionRequest::_interaction' has a wrong offset!");
static_assert(offsetof(FInteractionRequest, _requester) == 0x000010, "Member 'FInteractionRequest::_requester' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingTypeTexture
// 0x0030 (0x0030 - 0x0000)
struct FOfferingTypeTexture final
{
public:
	class FName                                   Type;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TextureBack;                                       // 0x0010(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingTypeTexture) == 0x000008, "Wrong alignment on FOfferingTypeTexture");
static_assert(sizeof(FOfferingTypeTexture) == 0x000030, "Wrong size on FOfferingTypeTexture");
static_assert(offsetof(FOfferingTypeTexture, Type) == 0x000000, "Member 'FOfferingTypeTexture::Type' has a wrong offset!");
static_assert(offsetof(FOfferingTypeTexture, TextureBack) == 0x000010, "Member 'FOfferingTypeTexture::TextureBack' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemAddonInitializationData
// 0x0002 (0x0002 - 0x0000)
struct FItemAddonInitializationData final
{
public:
	EInventoryItemType                            InventoryItemType;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AuthorityDataSet;                                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemAddonInitializationData) == 0x000001, "Wrong alignment on FItemAddonInitializationData");
static_assert(sizeof(FItemAddonInitializationData) == 0x000002, "Wrong size on FItemAddonInitializationData");
static_assert(offsetof(FItemAddonInitializationData, InventoryItemType) == 0x000000, "Member 'FItemAddonInitializationData::InventoryItemType' has a wrong offset!");
static_assert(offsetof(FItemAddonInitializationData, AuthorityDataSet) == 0x000001, "Member 'FItemAddonInitializationData::AuthorityDataSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterFallbackData
// 0x0020 (0x0020 - 0x0000)
struct FCharacterFallbackData final
{
public:
	class FString                                 DefaultKiller;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultSurvivor;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterFallbackData) == 0x000008, "Wrong alignment on FCharacterFallbackData");
static_assert(sizeof(FCharacterFallbackData) == 0x000020, "Wrong size on FCharacterFallbackData");
static_assert(offsetof(FCharacterFallbackData, DefaultKiller) == 0x000000, "Member 'FCharacterFallbackData::DefaultKiller' has a wrong offset!");
static_assert(offsetof(FCharacterFallbackData, DefaultSurvivor) == 0x000010, "Member 'FCharacterFallbackData::DefaultSurvivor' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemCharacterKillswitchData
// 0x0038 (0x0038 - 0x0000)
struct FItemCharacterKillswitchData final
{
public:
	struct FCharacterFallbackData                 CharacterFallback;                                 // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	TArray<class FString>                         DisabledItems;                                     // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DisabledItems_IsSet;                               // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemCharacterKillswitchData) == 0x000008, "Wrong alignment on FItemCharacterKillswitchData");
static_assert(sizeof(FItemCharacterKillswitchData) == 0x000038, "Wrong size on FItemCharacterKillswitchData");
static_assert(offsetof(FItemCharacterKillswitchData, CharacterFallback) == 0x000000, "Member 'FItemCharacterKillswitchData::CharacterFallback' has a wrong offset!");
static_assert(offsetof(FItemCharacterKillswitchData, DisabledItems) == 0x000020, "Member 'FItemCharacterKillswitchData::DisabledItems' has a wrong offset!");
static_assert(offsetof(FItemCharacterKillswitchData, DisabledItems_IsSet) == 0x000030, "Member 'FItemCharacterKillswitchData::DisabledItems_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemTypeData
// 0x00C8 (0x00D0 - 0x0008)
struct FItemTypeData final : public FDBDTableRowBase
{
public:
	ELoadoutItemType                              ItemType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemUIData                            UIData;                                            // 0x0010(0x00C0)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTypeData) == 0x000008, "Wrong alignment on FItemTypeData");
static_assert(sizeof(FItemTypeData) == 0x0000D0, "Wrong size on FItemTypeData");
static_assert(offsetof(FItemTypeData, ItemType) == 0x000008, "Member 'FItemTypeData::ItemType' has a wrong offset!");
static_assert(offsetof(FItemTypeData, UIData) == 0x000010, "Member 'FItemTypeData::UIData' has a wrong offset!");

// ScriptStruct DeadByDaylight.JwtGameConfig
// 0x0001 (0x0001 - 0x0000)
struct FJwtGameConfig final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJwtGameConfig) == 0x000001, "Wrong alignment on FJwtGameConfig");
static_assert(sizeof(FJwtGameConfig) == 0x000001, "Wrong size on FJwtGameConfig");
static_assert(offsetof(FJwtGameConfig, Enabled) == 0x000000, "Member 'FJwtGameConfig::Enabled' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerSoundCueTracker
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FKillerSoundCueTracker final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillerSoundCueTracker) == 0x000004, "Wrong alignment on FKillerSoundCueTracker");
static_assert(sizeof(FKillerSoundCueTracker) == 0x00001C, "Wrong size on FKillerSoundCueTracker");

// ScriptStruct DeadByDaylight.LandingPageStorefrontTabData
// 0x0058 (0x0058 - 0x0000)
struct FLandingPageStorefrontTabData final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              NewStartDate;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              NewEndDate;                                        // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2DDynamic*                      Image;                                             // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0028(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   TagText;                                           // 0x0040(0x0018)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLandingPageStorefrontTabData) == 0x000008, "Wrong alignment on FLandingPageStorefrontTabData");
static_assert(sizeof(FLandingPageStorefrontTabData) == 0x000058, "Wrong size on FLandingPageStorefrontTabData");
static_assert(offsetof(FLandingPageStorefrontTabData, Type) == 0x000000, "Member 'FLandingPageStorefrontTabData::Type' has a wrong offset!");
static_assert(offsetof(FLandingPageStorefrontTabData, NewStartDate) == 0x000010, "Member 'FLandingPageStorefrontTabData::NewStartDate' has a wrong offset!");
static_assert(offsetof(FLandingPageStorefrontTabData, NewEndDate) == 0x000018, "Member 'FLandingPageStorefrontTabData::NewEndDate' has a wrong offset!");
static_assert(offsetof(FLandingPageStorefrontTabData, Image) == 0x000020, "Member 'FLandingPageStorefrontTabData::Image' has a wrong offset!");
static_assert(offsetof(FLandingPageStorefrontTabData, Title) == 0x000028, "Member 'FLandingPageStorefrontTabData::Title' has a wrong offset!");
static_assert(offsetof(FLandingPageStorefrontTabData, TagText) == 0x000040, "Member 'FLandingPageStorefrontTabData::TagText' has a wrong offset!");

// ScriptStruct DeadByDaylight.ReportData
// 0x0030 (0x0030 - 0x0000)
struct FReportData final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReportData) == 0x000008, "Wrong alignment on FReportData");
static_assert(sizeof(FReportData) == 0x000030, "Wrong size on FReportData");
static_assert(offsetof(FReportData, Type) == 0x000000, "Member 'FReportData::Type' has a wrong offset!");
static_assert(offsetof(FReportData, Reason) == 0x000010, "Member 'FReportData::Reason' has a wrong offset!");
static_assert(offsetof(FReportData, Comment) == 0x000020, "Member 'FReportData::Comment' has a wrong offset!");

// ScriptStruct DeadByDaylight.LandingPageTabData
// 0x0058 (0x0058 - 0x0000)
struct FLandingPageTabData final
{
public:
	class FText                                   DefaultText;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TScriptInterface<class ISlateTextureAtlasInterface> DefaultImage;                                // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSlateColor                            BannerBackgroudColor;                              // 0x0028(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          IsButtonEnabled;                                   // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLandingPageTabData) == 0x000008, "Wrong alignment on FLandingPageTabData");
static_assert(sizeof(FLandingPageTabData) == 0x000058, "Wrong size on FLandingPageTabData");
static_assert(offsetof(FLandingPageTabData, DefaultText) == 0x000000, "Member 'FLandingPageTabData::DefaultText' has a wrong offset!");
static_assert(offsetof(FLandingPageTabData, DefaultImage) == 0x000018, "Member 'FLandingPageTabData::DefaultImage' has a wrong offset!");
static_assert(offsetof(FLandingPageTabData, BannerBackgroudColor) == 0x000028, "Member 'FLandingPageTabData::BannerBackgroudColor' has a wrong offset!");
static_assert(offsetof(FLandingPageTabData, IsButtonEnabled) == 0x000050, "Member 'FLandingPageTabData::IsButtonEnabled' has a wrong offset!");

// ScriptStruct DeadByDaylight.ParadiseData
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FParadiseData final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParadiseData) == 0x000008, "Wrong alignment on FParadiseData");
static_assert(sizeof(FParadiseData) == 0x000058, "Wrong size on FParadiseData");

// ScriptStruct DeadByDaylight.SceneLightingDescription
// 0x00D0 (0x00D0 - 0x0000)
struct FSceneLightingDescription final
{
public:
	class FName                                   ThemeName;                                         // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLightingSpecifics                     LightingDetailsLowMedium;                          // 0x0010(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FLightingSpecifics                     LightingDetailsHighUltra;                          // 0x0040(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FLightingSpecifics                     LightingAtlanta;                                   // 0x0070(0x0030)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureCube>            TextureCube;                                       // 0x00A0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneLightingDescription) == 0x000008, "Wrong alignment on FSceneLightingDescription");
static_assert(sizeof(FSceneLightingDescription) == 0x0000D0, "Wrong size on FSceneLightingDescription");
static_assert(offsetof(FSceneLightingDescription, ThemeName) == 0x000000, "Member 'FSceneLightingDescription::ThemeName' has a wrong offset!");
static_assert(offsetof(FSceneLightingDescription, LightingDetailsLowMedium) == 0x000010, "Member 'FSceneLightingDescription::LightingDetailsLowMedium' has a wrong offset!");
static_assert(offsetof(FSceneLightingDescription, LightingDetailsHighUltra) == 0x000040, "Member 'FSceneLightingDescription::LightingDetailsHighUltra' has a wrong offset!");
static_assert(offsetof(FSceneLightingDescription, LightingAtlanta) == 0x000070, "Member 'FSceneLightingDescription::LightingAtlanta' has a wrong offset!");
static_assert(offsetof(FSceneLightingDescription, TextureCube) == 0x0000A0, "Member 'FSceneLightingDescription::TextureCube' has a wrong offset!");

// ScriptStruct DeadByDaylight.DirectionalHeightFogInterpolationValues
// 0x0098 (0x0098 - 0x0000)
struct FDirectionalHeightFogInterpolationValues final
{
public:
	float                                         FogDensity;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FogInscatteringColor;                              // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalInscatteringExponent;                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalInscatteringStartDistance;              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirectionalInscatteringColor;                      // 0x001C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFalloff;                                  // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMaxOpacity;                                     // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDistance;                                     // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondFogDensity;                                  // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondFogHeightFalloff;                            // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondFogHeightOffset;                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHeightFogGradientEntry>        FogGradient;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bReplaceVolumetricFogAlbedoWithColorGradient;      // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumetricFogGradientIntensityMultiplier;          // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceUntilFlatFog;                              // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceUntilNoFog;                                // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableVolumetricFog;                              // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumetricFogScatteringDistribution;               // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 VolumetricFogAlbedo;                               // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           VolumetricFogEmissive;                             // 0x0074(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogExtinctionScale;                      // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogDistance;                             // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogStaticLightingScatteringIntensity;    // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLightColorsWithFogInscatteringColors;     // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDirectionalHeightFogInterpolationValues) == 0x000008, "Wrong alignment on FDirectionalHeightFogInterpolationValues");
static_assert(sizeof(FDirectionalHeightFogInterpolationValues) == 0x000098, "Wrong size on FDirectionalHeightFogInterpolationValues");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, FogDensity) == 0x000000, "Member 'FDirectionalHeightFogInterpolationValues::FogDensity' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, FogInscatteringColor) == 0x000004, "Member 'FDirectionalHeightFogInterpolationValues::FogInscatteringColor' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DirectionalInscatteringExponent) == 0x000014, "Member 'FDirectionalHeightFogInterpolationValues::DirectionalInscatteringExponent' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DirectionalInscatteringStartDistance) == 0x000018, "Member 'FDirectionalHeightFogInterpolationValues::DirectionalInscatteringStartDistance' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DirectionalInscatteringColor) == 0x00001C, "Member 'FDirectionalHeightFogInterpolationValues::DirectionalInscatteringColor' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, FogHeightFalloff) == 0x00002C, "Member 'FDirectionalHeightFogInterpolationValues::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, FogMaxOpacity) == 0x000030, "Member 'FDirectionalHeightFogInterpolationValues::FogMaxOpacity' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, StartDistance) == 0x000034, "Member 'FDirectionalHeightFogInterpolationValues::StartDistance' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, SecondFogDensity) == 0x000038, "Member 'FDirectionalHeightFogInterpolationValues::SecondFogDensity' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, SecondFogHeightFalloff) == 0x00003C, "Member 'FDirectionalHeightFogInterpolationValues::SecondFogHeightFalloff' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, SecondFogHeightOffset) == 0x000040, "Member 'FDirectionalHeightFogInterpolationValues::SecondFogHeightOffset' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, FogGradient) == 0x000048, "Member 'FDirectionalHeightFogInterpolationValues::FogGradient' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, bReplaceVolumetricFogAlbedoWithColorGradient) == 0x000058, "Member 'FDirectionalHeightFogInterpolationValues::bReplaceVolumetricFogAlbedoWithColorGradient' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogGradientIntensityMultiplier) == 0x00005C, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogGradientIntensityMultiplier' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DistanceUntilFlatFog) == 0x000060, "Member 'FDirectionalHeightFogInterpolationValues::DistanceUntilFlatFog' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DistanceUntilNoFog) == 0x000064, "Member 'FDirectionalHeightFogInterpolationValues::DistanceUntilNoFog' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, bEnableVolumetricFog) == 0x000068, "Member 'FDirectionalHeightFogInterpolationValues::bEnableVolumetricFog' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogScatteringDistribution) == 0x00006C, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogScatteringDistribution' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogAlbedo) == 0x000070, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogAlbedo' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogEmissive) == 0x000074, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogEmissive' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogExtinctionScale) == 0x000084, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogExtinctionScale' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogDistance) == 0x000088, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogDistance' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogStaticLightingScatteringIntensity) == 0x00008C, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogStaticLightingScatteringIntensity' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, bOverrideLightColorsWithFogInscatteringColors) == 0x000090, "Member 'FDirectionalHeightFogInterpolationValues::bOverrideLightColorsWithFogInscatteringColors' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoadingImagesData
// 0x0038 (0x0040 - 0x0008)
struct FLoadingImagesData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UPaperSprite>>    Images;                                            // 0x0018(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FLoadingInfoData>               InfoData;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsAvailableForSurvivor;                            // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableForKiller;                              // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGenericImages;                                   // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingImagesData) == 0x000008, "Wrong alignment on FLoadingImagesData");
static_assert(sizeof(FLoadingImagesData) == 0x000040, "Wrong size on FLoadingImagesData");
static_assert(offsetof(FLoadingImagesData, ID) == 0x000008, "Member 'FLoadingImagesData::ID' has a wrong offset!");
static_assert(offsetof(FLoadingImagesData, Images) == 0x000018, "Member 'FLoadingImagesData::Images' has a wrong offset!");
static_assert(offsetof(FLoadingImagesData, InfoData) == 0x000028, "Member 'FLoadingImagesData::InfoData' has a wrong offset!");
static_assert(offsetof(FLoadingImagesData, IsAvailableForSurvivor) == 0x000038, "Member 'FLoadingImagesData::IsAvailableForSurvivor' has a wrong offset!");
static_assert(offsetof(FLoadingImagesData, IsAvailableForKiller) == 0x000039, "Member 'FLoadingImagesData::IsAvailableForKiller' has a wrong offset!");
static_assert(offsetof(FLoadingImagesData, IsGenericImages) == 0x00003A, "Member 'FLoadingImagesData::IsGenericImages' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoadingTimeoutPerStep
// 0x0020 (0x0020 - 0x0000)
struct FLoadingTimeoutPerStep final
{
public:
	class FString                                 StepName;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpectedTimeout;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HardCapTimeout;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeCapWithoutProgress;                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingTimeoutPerStep) == 0x000008, "Wrong alignment on FLoadingTimeoutPerStep");
static_assert(sizeof(FLoadingTimeoutPerStep) == 0x000020, "Wrong size on FLoadingTimeoutPerStep");
static_assert(offsetof(FLoadingTimeoutPerStep, StepName) == 0x000000, "Member 'FLoadingTimeoutPerStep::StepName' has a wrong offset!");
static_assert(offsetof(FLoadingTimeoutPerStep, ExpectedTimeout) == 0x000010, "Member 'FLoadingTimeoutPerStep::ExpectedTimeout' has a wrong offset!");
static_assert(offsetof(FLoadingTimeoutPerStep, HardCapTimeout) == 0x000014, "Member 'FLoadingTimeoutPerStep::HardCapTimeout' has a wrong offset!");
static_assert(offsetof(FLoadingTimeoutPerStep, TimeCapWithoutProgress) == 0x000018, "Member 'FLoadingTimeoutPerStep::TimeCapWithoutProgress' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerLobbyOrderData
// 0x0018 (0x0018 - 0x0000)
struct FPlayerLobbyOrderData final
{
public:
	class FString                                 playerId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         slotIndex;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerLobbyOrderData) == 0x000008, "Wrong alignment on FPlayerLobbyOrderData");
static_assert(sizeof(FPlayerLobbyOrderData) == 0x000018, "Wrong size on FPlayerLobbyOrderData");
static_assert(offsetof(FPlayerLobbyOrderData, playerId) == 0x000000, "Member 'FPlayerLobbyOrderData::playerId' has a wrong offset!");
static_assert(offsetof(FPlayerLobbyOrderData, slotIndex) == 0x000010, "Member 'FPlayerLobbyOrderData::slotIndex' has a wrong offset!");

// ScriptStruct DeadByDaylight.ObjectLock
// 0x0008 (0x0008 - 0x0000)
struct FObjectLock final
{
public:
	TWeakObjectPtr<class UObject>                 _lockingObject;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FObjectLock) == 0x000004, "Wrong alignment on FObjectLock");
static_assert(sizeof(FObjectLock) == 0x000008, "Wrong size on FObjectLock");
static_assert(offsetof(FObjectLock, _lockingObject) == 0x000000, "Member 'FObjectLock::_lockingObject' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomLockerOutlineOverride
// 0x0050 (0x0050 - 0x0000)
struct FCustomLockerOutlineOverride final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   LockerStateTags;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   PlayerStateTags;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   PlayerPerkFlags;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutlineColor;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwaysVisible;                                   // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FadeOutAsClosingIn;                                // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomLockerOutlineOverride) == 0x000008, "Wrong alignment on FCustomLockerOutlineOverride");
static_assert(sizeof(FCustomLockerOutlineOverride) == 0x000050, "Wrong size on FCustomLockerOutlineOverride");
static_assert(offsetof(FCustomLockerOutlineOverride, Priority) == 0x000000, "Member 'FCustomLockerOutlineOverride::Priority' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, LockerStateTags) == 0x000008, "Member 'FCustomLockerOutlineOverride::LockerStateTags' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, PlayerStateTags) == 0x000018, "Member 'FCustomLockerOutlineOverride::PlayerStateTags' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, PlayerPerkFlags) == 0x000028, "Member 'FCustomLockerOutlineOverride::PlayerPerkFlags' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, OutlineColor) == 0x000038, "Member 'FCustomLockerOutlineOverride::OutlineColor' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, IsAlwaysVisible) == 0x000048, "Member 'FCustomLockerOutlineOverride::IsAlwaysVisible' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, FadeOutAsClosingIn) == 0x000049, "Member 'FCustomLockerOutlineOverride::FadeOutAsClosingIn' has a wrong offset!");

// ScriptStruct DeadByDaylight.MainMenuButtonData
// 0x0058 (0x0060 - 0x0008)
struct FMainMenuButtonData final : public FDBDTableRowBase
{
public:
	EMainMenuButton                               ButtonType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Label;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   InfoTitle;                                         // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   LockedInfoTitle;                                   // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsDisabled;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHidden;                                          // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMainMenuButtonData) == 0x000008, "Wrong alignment on FMainMenuButtonData");
static_assert(sizeof(FMainMenuButtonData) == 0x000060, "Wrong size on FMainMenuButtonData");
static_assert(offsetof(FMainMenuButtonData, ButtonType) == 0x000008, "Member 'FMainMenuButtonData::ButtonType' has a wrong offset!");
static_assert(offsetof(FMainMenuButtonData, Label) == 0x000010, "Member 'FMainMenuButtonData::Label' has a wrong offset!");
static_assert(offsetof(FMainMenuButtonData, InfoTitle) == 0x000028, "Member 'FMainMenuButtonData::InfoTitle' has a wrong offset!");
static_assert(offsetof(FMainMenuButtonData, LockedInfoTitle) == 0x000040, "Member 'FMainMenuButtonData::LockedInfoTitle' has a wrong offset!");
static_assert(offsetof(FMainMenuButtonData, IsDisabled) == 0x000058, "Member 'FMainMenuButtonData::IsDisabled' has a wrong offset!");
static_assert(offsetof(FMainMenuButtonData, IsLocked) == 0x000059, "Member 'FMainMenuButtonData::IsLocked' has a wrong offset!");
static_assert(offsetof(FMainMenuButtonData, IsHidden) == 0x00005A, "Member 'FMainMenuButtonData::IsHidden' has a wrong offset!");

// ScriptStruct DeadByDaylight.MatchmakingContextData
// 0x0004 (0x0004 - 0x0000)
struct FMatchmakingContextData final
{
public:
	uint32                                        ContextId;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchmakingContextData) == 0x000004, "Wrong alignment on FMatchmakingContextData");
static_assert(sizeof(FMatchmakingContextData) == 0x000004, "Wrong size on FMatchmakingContextData");
static_assert(offsetof(FMatchmakingContextData, ContextId) == 0x000000, "Member 'FMatchmakingContextData::ContextId' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuIndexChangeEventData
// 0x0004 (0x0004 - 0x0000)
struct FMenuIndexChangeEventData final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuIndexChangeEventData) == 0x000004, "Wrong alignment on FMenuIndexChangeEventData");
static_assert(sizeof(FMenuIndexChangeEventData) == 0x000004, "Wrong size on FMenuIndexChangeEventData");
static_assert(offsetof(FMenuIndexChangeEventData, Index) == 0x000000, "Member 'FMenuIndexChangeEventData::Index' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameInfoEventData
// 0x0002 (0x0002 - 0x0000)
struct FGameInfoEventData final
{
public:
	EPlayerRole                                   PlayerRole;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     GameType;                                          // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameInfoEventData) == 0x000001, "Wrong alignment on FGameInfoEventData");
static_assert(sizeof(FGameInfoEventData) == 0x000002, "Wrong size on FGameInfoEventData");
static_assert(offsetof(FGameInfoEventData, PlayerRole) == 0x000000, "Member 'FGameInfoEventData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FGameInfoEventData, GameType) == 0x000001, "Member 'FGameInfoEventData::GameType' has a wrong offset!");

// ScriptStruct DeadByDaylight.NamedButton
// 0x0018 (0x0018 - 0x0000)
struct FNamedButton final
{
public:
	int32                                         ClickCounter;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedButton) == 0x000008, "Wrong alignment on FNamedButton");
static_assert(sizeof(FNamedButton) == 0x000018, "Wrong size on FNamedButton");
static_assert(offsetof(FNamedButton, ClickCounter) == 0x000000, "Member 'FNamedButton::ClickCounter' has a wrong offset!");
static_assert(offsetof(FNamedButton, DisplayName) == 0x000008, "Member 'FNamedButton::DisplayName' has a wrong offset!");

// ScriptStruct DeadByDaylight.Offering
// 0x0220 (0x0220 - 0x0000)
struct alignas(0x08) FOffering final
{
public:
	uint8                                         Pad_0[0x220];                                      // 0x0000(0x0220)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOffering) == 0x000008, "Wrong alignment on FOffering");
static_assert(sizeof(FOffering) == 0x000220, "Wrong size on FOffering");

// ScriptStruct DeadByDaylight.RarityTexture
// 0x0030 (0x0030 - 0x0000)
struct FRarityTexture final
{
public:
	class FName                                   Type;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Texture;                                           // 0x0010(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRarityTexture) == 0x000008, "Wrong alignment on FRarityTexture");
static_assert(sizeof(FRarityTexture) == 0x000030, "Wrong size on FRarityTexture");
static_assert(offsetof(FRarityTexture, Type) == 0x000000, "Member 'FRarityTexture::Type' has a wrong offset!");
static_assert(offsetof(FRarityTexture, Rarity) == 0x00000C, "Member 'FRarityTexture::Rarity' has a wrong offset!");
static_assert(offsetof(FRarityTexture, Texture) == 0x000010, "Member 'FRarityTexture::Texture' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingRevealDelays
// 0x0008 (0x0008 - 0x0000)
struct FOfferingRevealDelays final
{
public:
	EOfferingSequenceState                        RevealState;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delay;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingRevealDelays) == 0x000004, "Wrong alignment on FOfferingRevealDelays");
static_assert(sizeof(FOfferingRevealDelays) == 0x000008, "Wrong size on FOfferingRevealDelays");
static_assert(offsetof(FOfferingRevealDelays, RevealState) == 0x000000, "Member 'FOfferingRevealDelays::RevealState' has a wrong offset!");
static_assert(offsetof(FOfferingRevealDelays, Delay) == 0x000004, "Member 'FOfferingRevealDelays::Delay' has a wrong offset!");

// ScriptStruct DeadByDaylight.OnScreenDebugInfo
// 0x0028 (0x0028 - 0x0000)
struct FOnScreenDebugInfo final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        Key;                                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDisplay;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnScreenDebugInfo) == 0x000008, "Wrong alignment on FOnScreenDebugInfo");
static_assert(sizeof(FOnScreenDebugInfo) == 0x000028, "Wrong size on FOnScreenDebugInfo");
static_assert(offsetof(FOnScreenDebugInfo, Message) == 0x000000, "Member 'FOnScreenDebugInfo::Message' has a wrong offset!");
static_assert(offsetof(FOnScreenDebugInfo, Color) == 0x000010, "Member 'FOnScreenDebugInfo::Color' has a wrong offset!");
static_assert(offsetof(FOnScreenDebugInfo, Key) == 0x000018, "Member 'FOnScreenDebugInfo::Key' has a wrong offset!");
static_assert(offsetof(FOnScreenDebugInfo, TimeToDisplay) == 0x000020, "Member 'FOnScreenDebugInfo::TimeToDisplay' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerspectiveEffectData
// 0x001C (0x001C - 0x0000)
struct FPerspectiveEffectData final
{
public:
	bool                                          WantsActive;                                       // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(bool isActive)>                ActivationEvent;                                   // 0x0004(0x0014)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EPerspectiveActivationCondition               Condition;                                         // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerspectiveEffectData) == 0x000004, "Wrong alignment on FPerspectiveEffectData");
static_assert(sizeof(FPerspectiveEffectData) == 0x00001C, "Wrong size on FPerspectiveEffectData");
static_assert(offsetof(FPerspectiveEffectData, WantsActive) == 0x000000, "Member 'FPerspectiveEffectData::WantsActive' has a wrong offset!");
static_assert(offsetof(FPerspectiveEffectData, ActivationEvent) == 0x000004, "Member 'FPerspectiveEffectData::ActivationEvent' has a wrong offset!");
static_assert(offsetof(FPerspectiveEffectData, Condition) == 0x000018, "Member 'FPerspectiveEffectData::Condition' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerCapsuleQueryParams
// 0x0078 (0x0078 - 0x0000)
struct FPlayerCapsuleQueryParams final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           IgnoreActors;                                      // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerCapsuleQueryParams) == 0x000008, "Wrong alignment on FPlayerCapsuleQueryParams");
static_assert(sizeof(FPlayerCapsuleQueryParams) == 0x000078, "Wrong size on FPlayerCapsuleQueryParams");
static_assert(offsetof(FPlayerCapsuleQueryParams, Player) == 0x000000, "Member 'FPlayerCapsuleQueryParams::Player' has a wrong offset!");
static_assert(offsetof(FPlayerCapsuleQueryParams, IgnoreActors) == 0x000018, "Member 'FPlayerCapsuleQueryParams::IgnoreActors' has a wrong offset!");

// ScriptStruct DeadByDaylight.GeneratedLevelData
// 0x0310 (0x0310 - 0x0000)
struct FGeneratedLevelData final
{
public:
	class FString                                 UsedPaperTileMap;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PremadeMap;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StreamRelatedSeed;                                 // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AvailableEscapeCount;                              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AvailableSurvivorItemCount;                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESurvivorGrouping                             GroupingType;                                      // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        KillerSpawnPoint;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                SurvivorSpawnPoints;                               // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                InteractableElementsSpawnPoints;                   // 0x0048(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      SpecialBehaviourRequestCounts;                     // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FArrayOfSceneComponent> SpecialBehaviourSpawnPoints;                    // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class FName, struct FArrayOfSceneComponent> SpecialBehaviourActorSpawners;                  // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                SearchableSpawners;                                // 0x0148(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                HexSpawners;                                       // 0x0158(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                KillerLairSpawners;                                // 0x0168(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                HatchSpawners;                                     // 0x0178(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                MainBuildingHatchSpawners;                         // 0x0188(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                ShackHatchSpawners;                                // 0x0198(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                BreakableWallSpawners;                             // 0x01A8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                EscapeSpawners;                                    // 0x01B8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FManagedGameplayElementData            BookshelfManagedGameplayElementData;               // 0x01C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FManagedGameplayElementData            MeatHookManagedGameplayElementData;                // 0x0218(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FDependency>                    LevelDependencies;                                 // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDependency>                    LateLevelDependencies;                             // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         FixedMapTileIds;                                   // 0x0288(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         FixedMapOrphanSpawners;                            // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                FinisherMoriSpawnPoints;                           // 0x02A8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   SpecialEventId;                                    // 0x02B8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseForcedMap;                                      // 0x02C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePremadeMap;                                     // 0x02C5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6[0x2];                                      // 0x02C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GenerationLogs;                                    // 0x02C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GenerationErrors;                                  // 0x02D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GenerationPlayerCount;                             // 0x02E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FForceSpawnTileData>            ForceSpawnTileData;                                // 0x02F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         LevelLightings;                                    // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneratedLevelData) == 0x000008, "Wrong alignment on FGeneratedLevelData");
static_assert(sizeof(FGeneratedLevelData) == 0x000310, "Wrong size on FGeneratedLevelData");
static_assert(offsetof(FGeneratedLevelData, UsedPaperTileMap) == 0x000000, "Member 'FGeneratedLevelData::UsedPaperTileMap' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, PremadeMap) == 0x000010, "Member 'FGeneratedLevelData::PremadeMap' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, StreamRelatedSeed) == 0x000020, "Member 'FGeneratedLevelData::StreamRelatedSeed' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, AvailableEscapeCount) == 0x000024, "Member 'FGeneratedLevelData::AvailableEscapeCount' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, AvailableSurvivorItemCount) == 0x000028, "Member 'FGeneratedLevelData::AvailableSurvivorItemCount' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, GroupingType) == 0x00002C, "Member 'FGeneratedLevelData::GroupingType' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, KillerSpawnPoint) == 0x000030, "Member 'FGeneratedLevelData::KillerSpawnPoint' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SurvivorSpawnPoints) == 0x000038, "Member 'FGeneratedLevelData::SurvivorSpawnPoints' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, InteractableElementsSpawnPoints) == 0x000048, "Member 'FGeneratedLevelData::InteractableElementsSpawnPoints' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SpecialBehaviourRequestCounts) == 0x000058, "Member 'FGeneratedLevelData::SpecialBehaviourRequestCounts' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SpecialBehaviourSpawnPoints) == 0x0000A8, "Member 'FGeneratedLevelData::SpecialBehaviourSpawnPoints' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SpecialBehaviourActorSpawners) == 0x0000F8, "Member 'FGeneratedLevelData::SpecialBehaviourActorSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SearchableSpawners) == 0x000148, "Member 'FGeneratedLevelData::SearchableSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, HexSpawners) == 0x000158, "Member 'FGeneratedLevelData::HexSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, KillerLairSpawners) == 0x000168, "Member 'FGeneratedLevelData::KillerLairSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, HatchSpawners) == 0x000178, "Member 'FGeneratedLevelData::HatchSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, MainBuildingHatchSpawners) == 0x000188, "Member 'FGeneratedLevelData::MainBuildingHatchSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, ShackHatchSpawners) == 0x000198, "Member 'FGeneratedLevelData::ShackHatchSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, BreakableWallSpawners) == 0x0001A8, "Member 'FGeneratedLevelData::BreakableWallSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, EscapeSpawners) == 0x0001B8, "Member 'FGeneratedLevelData::EscapeSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, BookshelfManagedGameplayElementData) == 0x0001C8, "Member 'FGeneratedLevelData::BookshelfManagedGameplayElementData' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, MeatHookManagedGameplayElementData) == 0x000218, "Member 'FGeneratedLevelData::MeatHookManagedGameplayElementData' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, LevelDependencies) == 0x000268, "Member 'FGeneratedLevelData::LevelDependencies' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, LateLevelDependencies) == 0x000278, "Member 'FGeneratedLevelData::LateLevelDependencies' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, FixedMapTileIds) == 0x000288, "Member 'FGeneratedLevelData::FixedMapTileIds' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, FixedMapOrphanSpawners) == 0x000298, "Member 'FGeneratedLevelData::FixedMapOrphanSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, FinisherMoriSpawnPoints) == 0x0002A8, "Member 'FGeneratedLevelData::FinisherMoriSpawnPoints' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SpecialEventId) == 0x0002B8, "Member 'FGeneratedLevelData::SpecialEventId' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, UseForcedMap) == 0x0002C4, "Member 'FGeneratedLevelData::UseForcedMap' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, UsePremadeMap) == 0x0002C5, "Member 'FGeneratedLevelData::UsePremadeMap' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, GenerationLogs) == 0x0002C8, "Member 'FGeneratedLevelData::GenerationLogs' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, GenerationErrors) == 0x0002D8, "Member 'FGeneratedLevelData::GenerationErrors' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, GenerationPlayerCount) == 0x0002E8, "Member 'FGeneratedLevelData::GenerationPlayerCount' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, ForceSpawnTileData) == 0x0002F0, "Member 'FGeneratedLevelData::ForceSpawnTileData' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, LevelLightings) == 0x000300, "Member 'FGeneratedLevelData::LevelLightings' has a wrong offset!");

// ScriptStruct DeadByDaylight.ManagedGameplayElementsPopulation
// 0x0048 (0x0048 - 0x0000)
struct FManagedGameplayElementsPopulation final
{
public:
	EGameplayElementType                          Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   GameplayElementBlueprint;                          // 0x0008(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPopulation;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPopulation;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManagedGameplayElementsPopulation) == 0x000008, "Wrong alignment on FManagedGameplayElementsPopulation");
static_assert(sizeof(FManagedGameplayElementsPopulation) == 0x000048, "Wrong size on FManagedGameplayElementsPopulation");
static_assert(offsetof(FManagedGameplayElementsPopulation, Type) == 0x000000, "Member 'FManagedGameplayElementsPopulation::Type' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementsPopulation, GameplayElementBlueprint) == 0x000008, "Member 'FManagedGameplayElementsPopulation::GameplayElementBlueprint' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementsPopulation, MinDistance) == 0x000038, "Member 'FManagedGameplayElementsPopulation::MinDistance' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementsPopulation, MinPopulation) == 0x00003C, "Member 'FManagedGameplayElementsPopulation::MinPopulation' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementsPopulation, MaxPopulation) == 0x000040, "Member 'FManagedGameplayElementsPopulation::MaxPopulation' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorGroupingProbability
// 0x0008 (0x0008 - 0x0000)
struct FSurvivorGroupingProbability final
{
public:
	ESurvivorGrouping                             Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Probability;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurvivorGroupingProbability) == 0x000004, "Wrong alignment on FSurvivorGroupingProbability");
static_assert(sizeof(FSurvivorGroupingProbability) == 0x000008, "Wrong size on FSurvivorGroupingProbability");
static_assert(offsetof(FSurvivorGroupingProbability, Type) == 0x000000, "Member 'FSurvivorGroupingProbability::Type' has a wrong offset!");
static_assert(offsetof(FSurvivorGroupingProbability, Probability) == 0x000004, "Member 'FSurvivorGroupingProbability::Probability' has a wrong offset!");

// ScriptStruct DeadByDaylight.ThemeProperties
// 0x00F0 (0x00F8 - 0x0008)
struct FThemeProperties final : public FDBDTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Weather;                                           // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateThemes;                                  // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateWeather;                                 // 0x002C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioThemeEvent;                                   // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioLimitPointEvent;                              // 0x0044(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioBank>            AudioThemeSoundBank;                               // 0x0050(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TilePath;                                          // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapPath;                                           // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThemeNumber;                                       // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x00A8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EThemeColorId                                 ThemeColorId;                                      // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOfferingEffectType                           ThemeSelectionOfferingEffectType;                  // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayElementSubstitutions>  SubstitutionElements;                              // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 DlcIDString;                                       // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardData*                        Blackboard;                                        // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gesture;                                           // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FThemeProperties) == 0x000008, "Wrong alignment on FThemeProperties");
static_assert(sizeof(FThemeProperties) == 0x0000F8, "Wrong size on FThemeProperties");
static_assert(offsetof(FThemeProperties, Name) == 0x000008, "Member 'FThemeProperties::Name' has a wrong offset!");
static_assert(offsetof(FThemeProperties, Weather) == 0x000014, "Member 'FThemeProperties::Weather' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AudioStateThemes) == 0x000020, "Member 'FThemeProperties::AudioStateThemes' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AudioStateWeather) == 0x00002C, "Member 'FThemeProperties::AudioStateWeather' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AudioThemeEvent) == 0x000038, "Member 'FThemeProperties::AudioThemeEvent' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AudioLimitPointEvent) == 0x000044, "Member 'FThemeProperties::AudioLimitPointEvent' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AudioThemeSoundBank) == 0x000050, "Member 'FThemeProperties::AudioThemeSoundBank' has a wrong offset!");
static_assert(offsetof(FThemeProperties, TilePath) == 0x000080, "Member 'FThemeProperties::TilePath' has a wrong offset!");
static_assert(offsetof(FThemeProperties, MapPath) == 0x000090, "Member 'FThemeProperties::MapPath' has a wrong offset!");
static_assert(offsetof(FThemeProperties, ThemeNumber) == 0x0000A0, "Member 'FThemeProperties::ThemeNumber' has a wrong offset!");
static_assert(offsetof(FThemeProperties, DisplayName) == 0x0000A8, "Member 'FThemeProperties::DisplayName' has a wrong offset!");
static_assert(offsetof(FThemeProperties, ThemeColorId) == 0x0000C0, "Member 'FThemeProperties::ThemeColorId' has a wrong offset!");
static_assert(offsetof(FThemeProperties, ThemeSelectionOfferingEffectType) == 0x0000C1, "Member 'FThemeProperties::ThemeSelectionOfferingEffectType' has a wrong offset!");
static_assert(offsetof(FThemeProperties, SubstitutionElements) == 0x0000C8, "Member 'FThemeProperties::SubstitutionElements' has a wrong offset!");
static_assert(offsetof(FThemeProperties, DlcIDString) == 0x0000D8, "Member 'FThemeProperties::DlcIDString' has a wrong offset!");
static_assert(offsetof(FThemeProperties, Blackboard) == 0x0000E8, "Member 'FThemeProperties::Blackboard' has a wrong offset!");
static_assert(offsetof(FThemeProperties, Gesture) == 0x0000F0, "Member 'FThemeProperties::Gesture' has a wrong offset!");

// ScriptStruct DeadByDaylight.ProceduralMap
// 0x00B8 (0x00C0 - 0x0008)
struct FProceduralMap final : public FDBDTableRowBase
{
public:
	class FName                                   MapId;                                             // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ThemeName;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         HookMinDistance;                                   // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HookMinCount;                                      // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HookMaxCount;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BookShelvesMinDistance;                            // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BookShelvesMinCount;                               // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BookShelvesMaxCount;                               // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LivingWorldObjectsMinCount;                        // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LivingWorldObjectsMaxCount;                        // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ThumbnailPath;                                     // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortingIndex;                                      // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DlcIDString;                                       // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 FixedLayoutSeed;                                   // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsInNonViolentBuild;                               // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLicensed;                                        // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralMap) == 0x000008, "Wrong alignment on FProceduralMap");
static_assert(sizeof(FProceduralMap) == 0x0000C0, "Wrong size on FProceduralMap");
static_assert(offsetof(FProceduralMap, MapId) == 0x000008, "Member 'FProceduralMap::MapId' has a wrong offset!");
static_assert(offsetof(FProceduralMap, Name) == 0x000018, "Member 'FProceduralMap::Name' has a wrong offset!");
static_assert(offsetof(FProceduralMap, ThemeName) == 0x000030, "Member 'FProceduralMap::ThemeName' has a wrong offset!");
static_assert(offsetof(FProceduralMap, Description) == 0x000048, "Member 'FProceduralMap::Description' has a wrong offset!");
static_assert(offsetof(FProceduralMap, HookMinDistance) == 0x000060, "Member 'FProceduralMap::HookMinDistance' has a wrong offset!");
static_assert(offsetof(FProceduralMap, HookMinCount) == 0x000064, "Member 'FProceduralMap::HookMinCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, HookMaxCount) == 0x000068, "Member 'FProceduralMap::HookMaxCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, BookShelvesMinDistance) == 0x00006C, "Member 'FProceduralMap::BookShelvesMinDistance' has a wrong offset!");
static_assert(offsetof(FProceduralMap, BookShelvesMinCount) == 0x000070, "Member 'FProceduralMap::BookShelvesMinCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, BookShelvesMaxCount) == 0x000074, "Member 'FProceduralMap::BookShelvesMaxCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, LivingWorldObjectsMinCount) == 0x000078, "Member 'FProceduralMap::LivingWorldObjectsMinCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, LivingWorldObjectsMaxCount) == 0x00007C, "Member 'FProceduralMap::LivingWorldObjectsMaxCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, ThumbnailPath) == 0x000080, "Member 'FProceduralMap::ThumbnailPath' has a wrong offset!");
static_assert(offsetof(FProceduralMap, SortingIndex) == 0x000090, "Member 'FProceduralMap::SortingIndex' has a wrong offset!");
static_assert(offsetof(FProceduralMap, DlcIDString) == 0x000098, "Member 'FProceduralMap::DlcIDString' has a wrong offset!");
static_assert(offsetof(FProceduralMap, FixedLayoutSeed) == 0x0000A8, "Member 'FProceduralMap::FixedLayoutSeed' has a wrong offset!");
static_assert(offsetof(FProceduralMap, IsInNonViolentBuild) == 0x0000B8, "Member 'FProceduralMap::IsInNonViolentBuild' has a wrong offset!");
static_assert(offsetof(FProceduralMap, IsLicensed) == 0x0000B9, "Member 'FProceduralMap::IsLicensed' has a wrong offset!");

// ScriptStruct DeadByDaylight.PromoPackItemPayloadData
// 0x0001 (0x0001 - 0x0000)
struct FPromoPackItemPayloadData
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPromoPackItemPayloadData) == 0x000001, "Wrong alignment on FPromoPackItemPayloadData");
static_assert(sizeof(FPromoPackItemPayloadData) == 0x000001, "Wrong size on FPromoPackItemPayloadData");

// ScriptStruct DeadByDaylight.PromoPackCharacterPayloadData
// 0x0000 (0x0001 - 0x0001)
struct FPromoPackCharacterPayloadData final : public FPromoPackItemPayloadData
{
};
static_assert(alignof(FPromoPackCharacterPayloadData) == 0x000001, "Wrong alignment on FPromoPackCharacterPayloadData");
static_assert(sizeof(FPromoPackCharacterPayloadData) == 0x000001, "Wrong size on FPromoPackCharacterPayloadData");

// ScriptStruct DeadByDaylight.PromoPackCurrencyPayloadData
// 0x0003 (0x0004 - 0x0001)
struct alignas(0x04) FPromoPackCurrencyPayloadData final : public FPromoPackItemPayloadData
{
};
static_assert(alignof(FPromoPackCurrencyPayloadData) == 0x000004, "Wrong alignment on FPromoPackCurrencyPayloadData");
static_assert(sizeof(FPromoPackCurrencyPayloadData) == 0x000004, "Wrong size on FPromoPackCurrencyPayloadData");

// ScriptStruct DeadByDaylight.PromoPackPurchaseUIData
// 0x0058 (0x0058 - 0x0000)
struct FPromoPackPurchaseUIData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPurchaseCurrencyData                  AuricCellsPurchaseData;                            // 0x0008(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          HasAuricCellsData;                                 // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPurchaseCurrencyData                  IridescentShardsPurchaseData;                      // 0x0030(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          HasIridescentShards;                               // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPromoPackPurchaseUIData) == 0x000008, "Wrong alignment on FPromoPackPurchaseUIData");
static_assert(sizeof(FPromoPackPurchaseUIData) == 0x000058, "Wrong size on FPromoPackPurchaseUIData");
static_assert(offsetof(FPromoPackPurchaseUIData, AuricCellsPurchaseData) == 0x000008, "Member 'FPromoPackPurchaseUIData::AuricCellsPurchaseData' has a wrong offset!");
static_assert(offsetof(FPromoPackPurchaseUIData, HasAuricCellsData) == 0x000028, "Member 'FPromoPackPurchaseUIData::HasAuricCellsData' has a wrong offset!");
static_assert(offsetof(FPromoPackPurchaseUIData, IridescentShardsPurchaseData) == 0x000030, "Member 'FPromoPackPurchaseUIData::IridescentShardsPurchaseData' has a wrong offset!");
static_assert(offsetof(FPromoPackPurchaseUIData, HasIridescentShards) == 0x000050, "Member 'FPromoPackPurchaseUIData::HasIridescentShards' has a wrong offset!");

// ScriptStruct DeadByDaylight.PurchaseItemUIData
// 0x0050 (0x0050 - 0x0000)
struct FPurchaseItemUIData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0008(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Transient, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconPath;                                          // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventItemContentType                         ContentType;                                       // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPurchaseItemUIData) == 0x000008, "Wrong alignment on FPurchaseItemUIData");
static_assert(sizeof(FPurchaseItemUIData) == 0x000050, "Wrong size on FPurchaseItemUIData");
static_assert(offsetof(FPurchaseItemUIData, ItemId) == 0x000008, "Member 'FPurchaseItemUIData::ItemId' has a wrong offset!");
static_assert(offsetof(FPurchaseItemUIData, DisplayName) == 0x000018, "Member 'FPurchaseItemUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FPurchaseItemUIData, Quantity) == 0x000030, "Member 'FPurchaseItemUIData::Quantity' has a wrong offset!");
static_assert(offsetof(FPurchaseItemUIData, IconPath) == 0x000038, "Member 'FPurchaseItemUIData::IconPath' has a wrong offset!");
static_assert(offsetof(FPurchaseItemUIData, ContentType) == 0x000048, "Member 'FPurchaseItemUIData::ContentType' has a wrong offset!");
static_assert(offsetof(FPurchaseItemUIData, Rarity) == 0x000049, "Member 'FPurchaseItemUIData::Rarity' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankNameData
// 0x0020 (0x0028 - 0x0008)
struct FRankNameData final : public FDBDTableRowBase
{
public:
	class FText                                   RankName;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SubRanks;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRankNameData) == 0x000008, "Wrong alignment on FRankNameData");
static_assert(sizeof(FRankNameData) == 0x000028, "Wrong size on FRankNameData");
static_assert(offsetof(FRankNameData, RankName) == 0x000008, "Member 'FRankNameData::RankName' has a wrong offset!");
static_assert(offsetof(FRankNameData, SubRanks) == 0x000020, "Member 'FRankNameData::SubRanks' has a wrong offset!");

// ScriptStruct DeadByDaylight.RarityDistributionValue
// 0x0010 (0x0018 - 0x0008)
struct FRarityDistributionValue final : public FDBDTableRowBase
{
public:
	int32                                         InnerRing;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRing;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRing;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRarityDistributionValue) == 0x000008, "Wrong alignment on FRarityDistributionValue");
static_assert(sizeof(FRarityDistributionValue) == 0x000018, "Wrong size on FRarityDistributionValue");
static_assert(offsetof(FRarityDistributionValue, InnerRing) == 0x000008, "Member 'FRarityDistributionValue::InnerRing' has a wrong offset!");
static_assert(offsetof(FRarityDistributionValue, MiddleRing) == 0x00000C, "Member 'FRarityDistributionValue::MiddleRing' has a wrong offset!");
static_assert(offsetof(FRarityDistributionValue, OuterRing) == 0x000010, "Member 'FRarityDistributionValue::OuterRing' has a wrong offset!");

// ScriptStruct DeadByDaylight.Region
// 0x0020 (0x0020 - 0x0000)
struct FRegion final
{
public:
	class FName                                   Region;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IP;                                                // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegion) == 0x000008, "Wrong alignment on FRegion");
static_assert(sizeof(FRegion) == 0x000020, "Wrong size on FRegion");
static_assert(offsetof(FRegion, Region) == 0x000000, "Member 'FRegion::Region' has a wrong offset!");
static_assert(offsetof(FRegion, IP) == 0x000010, "Member 'FRegion::IP' has a wrong offset!");

// ScriptStruct DeadByDaylight.ReportFeedbackData
// 0x0018 (0x0018 - 0x0000)
struct FReportFeedbackData final
{
public:
	struct FDateTime                              BanTimestamp;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReportFeedbackData) == 0x000008, "Wrong alignment on FReportFeedbackData");
static_assert(sizeof(FReportFeedbackData) == 0x000018, "Wrong size on FReportFeedbackData");
static_assert(offsetof(FReportFeedbackData, BanTimestamp) == 0x000000, "Member 'FReportFeedbackData::BanTimestamp' has a wrong offset!");
static_assert(offsetof(FReportFeedbackData, Reason) == 0x000008, "Member 'FReportFeedbackData::Reason' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3AnalyticsConfig
// 0x0018 (0x0018 - 0x0000)
struct FS3AnalyticsConfig final
{
public:
	bool                                          GameInitVerbose;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameConsoleLogMinimumVerbosity;                    // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3AnalyticsConfig) == 0x000008, "Wrong alignment on FS3AnalyticsConfig");
static_assert(sizeof(FS3AnalyticsConfig) == 0x000018, "Wrong size on FS3AnalyticsConfig");
static_assert(offsetof(FS3AnalyticsConfig, GameInitVerbose) == 0x000000, "Member 'FS3AnalyticsConfig::GameInitVerbose' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, GameConsoleLogMinimumVerbosity) == 0x000008, "Member 'FS3AnalyticsConfig::GameConsoleLogMinimumVerbosity' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3FriendsListGameConfig
// 0x000C (0x000C - 0x0000)
struct FS3FriendsListGameConfig final
{
public:
	int32                                         MaxFriendSuggestionsFacebook;                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFriendSuggestionsGoogle;                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFriendSuggestionsRecentlyPlayed;                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3FriendsListGameConfig) == 0x000004, "Wrong alignment on FS3FriendsListGameConfig");
static_assert(sizeof(FS3FriendsListGameConfig) == 0x00000C, "Wrong size on FS3FriendsListGameConfig");
static_assert(offsetof(FS3FriendsListGameConfig, MaxFriendSuggestionsFacebook) == 0x000000, "Member 'FS3FriendsListGameConfig::MaxFriendSuggestionsFacebook' has a wrong offset!");
static_assert(offsetof(FS3FriendsListGameConfig, MaxFriendSuggestionsGoogle) == 0x000004, "Member 'FS3FriendsListGameConfig::MaxFriendSuggestionsGoogle' has a wrong offset!");
static_assert(offsetof(FS3FriendsListGameConfig, MaxFriendSuggestionsRecentlyPlayed) == 0x000008, "Member 'FS3FriendsListGameConfig::MaxFriendSuggestionsRecentlyPlayed' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3LoadingConfig
// 0x0030 (0x0030 - 0x0000)
struct FS3LoadingConfig final
{
public:
	struct FLoadingTimeoutPerStep                 GlobalTimeout;                                     // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FLoadingTimeoutPerStep>         TimeoutPerSteps;                                   // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3LoadingConfig) == 0x000008, "Wrong alignment on FS3LoadingConfig");
static_assert(sizeof(FS3LoadingConfig) == 0x000030, "Wrong size on FS3LoadingConfig");
static_assert(offsetof(FS3LoadingConfig, GlobalTimeout) == 0x000000, "Member 'FS3LoadingConfig::GlobalTimeout' has a wrong offset!");
static_assert(offsetof(FS3LoadingConfig, TimeoutPerSteps) == 0x000020, "Member 'FS3LoadingConfig::TimeoutPerSteps' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3MatchConfig
// 0x0008 (0x0008 - 0x0000)
struct FS3MatchConfig final
{
public:
	int32                                         MaxMatchSeconds;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEndGameCollapseSeconds;                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3MatchConfig) == 0x000004, "Wrong alignment on FS3MatchConfig");
static_assert(sizeof(FS3MatchConfig) == 0x000008, "Wrong size on FS3MatchConfig");
static_assert(offsetof(FS3MatchConfig, MaxMatchSeconds) == 0x000000, "Member 'FS3MatchConfig::MaxMatchSeconds' has a wrong offset!");
static_assert(offsetof(FS3MatchConfig, MaxEndGameCollapseSeconds) == 0x000004, "Member 'FS3MatchConfig::MaxEndGameCollapseSeconds' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3MirrorsDefaultRetryPolicyConfig
// 0x000C (0x000C - 0x0000)
struct FS3MirrorsDefaultRetryPolicyConfig final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RetryCount;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Timeout;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3MirrorsDefaultRetryPolicyConfig) == 0x000004, "Wrong alignment on FS3MirrorsDefaultRetryPolicyConfig");
static_assert(sizeof(FS3MirrorsDefaultRetryPolicyConfig) == 0x00000C, "Wrong size on FS3MirrorsDefaultRetryPolicyConfig");
static_assert(offsetof(FS3MirrorsDefaultRetryPolicyConfig, Enabled) == 0x000000, "Member 'FS3MirrorsDefaultRetryPolicyConfig::Enabled' has a wrong offset!");
static_assert(offsetof(FS3MirrorsDefaultRetryPolicyConfig, RetryCount) == 0x000004, "Member 'FS3MirrorsDefaultRetryPolicyConfig::RetryCount' has a wrong offset!");
static_assert(offsetof(FS3MirrorsDefaultRetryPolicyConfig, Timeout) == 0x000008, "Member 'FS3MirrorsDefaultRetryPolicyConfig::Timeout' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3SecurityConfig
// 0x0002 (0x0002 - 0x0000)
struct FS3SecurityConfig final
{
public:
	bool                                          AllowServerCheats;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowClientGuestProviderOnServerLogin;             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3SecurityConfig) == 0x000001, "Wrong alignment on FS3SecurityConfig");
static_assert(sizeof(FS3SecurityConfig) == 0x000002, "Wrong size on FS3SecurityConfig");
static_assert(offsetof(FS3SecurityConfig, AllowServerCheats) == 0x000000, "Member 'FS3SecurityConfig::AllowServerCheats' has a wrong offset!");
static_assert(offsetof(FS3SecurityConfig, AllowClientGuestProviderOnServerLogin) == 0x000001, "Member 'FS3SecurityConfig::AllowClientGuestProviderOnServerLogin' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3GameConfigsData
// 0x0268 (0x0268 - 0x0000)
struct FS3GameConfigsData final
{
public:
	struct FS3AnalyticsConfig                     Analytics;                                         // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FArchivesConfig                        Archives;                                          // 0x0018(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBalanceToolGameConfig                 BalanceTool;                                       // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	bool                                          BalanceTool_IsSet;                                 // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3BeginnerTutorialLevelConfig         BeginnerTutorialLevel;                             // 0x0034(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBotMatchConfig                        BotMatch;                                          // 0x0040(0x0020)(NativeAccessSpecifierPublic)
	struct FDedicatedServerGameConfig             DedicatedServer;                                   // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          EnableNetAsyncLoading;                             // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnablePlayersConnectionStatus;                     // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnablePlayerIdInSurvey;                            // 0x0072(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableBotsInCustomMatch;                           // 0x0073(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableNavigationDuringMatchmaking;                // 0x0074(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RTMTimeoutThreshold;                               // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameLoadingTimeout;                                // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableHapticVibration;                             // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableWinGDKAccountMismatchPopup;                  // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAntiMoveHack;                                // 0x0082(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83[0x5];                                       // 0x0083(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, bool>                     CrossPromoManagerPlatforms;                        // 0x0088(0x0050)(NativeAccessSpecifierPublic)
	bool                                          CrossPromoManagerPlatforms_IsSet;                  // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3FriendsListGameConfig               FriendsList;                                       // 0x00DC(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FHitValidationGameConfig               HitValidation;                                     // 0x00E8(0x0018)(NativeAccessSpecifierPublic)
	struct FJwtGameConfig                         Jwt;                                               // 0x0100(0x0001)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3MatchConfig                         Match;                                             // 0x0104(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3LoadingConfig                       Loading;                                           // 0x0110(0x0030)(NativeAccessSpecifierPublic)
	TMap<class FString, bool>                     MatchmakingCrossplayPlatforms;                     // 0x0140(0x0050)(NativeAccessSpecifierPublic)
	struct FS3MirrorsDefaultRetryPolicyConfig     MirrorsDefaultRetryPolicy;                         // 0x0190(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3OnlineConfig                        Online;                                            // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
	struct FS3SecurityConfig                      Security;                                          // 0x01C0(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C2[0x6];                                      // 0x01C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, bool>                     SocialCrossfriendsPlatforms;                       // 0x01C8(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, bool>                     SocialCrossprogressionPlatforms;                   // 0x0218(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3GameConfigsData) == 0x000008, "Wrong alignment on FS3GameConfigsData");
static_assert(sizeof(FS3GameConfigsData) == 0x000268, "Wrong size on FS3GameConfigsData");
static_assert(offsetof(FS3GameConfigsData, Analytics) == 0x000000, "Member 'FS3GameConfigsData::Analytics' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Archives) == 0x000018, "Member 'FS3GameConfigsData::Archives' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, BalanceTool) == 0x000020, "Member 'FS3GameConfigsData::BalanceTool' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, BalanceTool_IsSet) == 0x000030, "Member 'FS3GameConfigsData::BalanceTool_IsSet' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, BeginnerTutorialLevel) == 0x000034, "Member 'FS3GameConfigsData::BeginnerTutorialLevel' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, BotMatch) == 0x000040, "Member 'FS3GameConfigsData::BotMatch' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, DedicatedServer) == 0x000060, "Member 'FS3GameConfigsData::DedicatedServer' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableNetAsyncLoading) == 0x000070, "Member 'FS3GameConfigsData::EnableNetAsyncLoading' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnablePlayersConnectionStatus) == 0x000071, "Member 'FS3GameConfigsData::EnablePlayersConnectionStatus' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnablePlayerIdInSurvey) == 0x000072, "Member 'FS3GameConfigsData::EnablePlayerIdInSurvey' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableBotsInCustomMatch) == 0x000073, "Member 'FS3GameConfigsData::EnableBotsInCustomMatch' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, DisableNavigationDuringMatchmaking) == 0x000074, "Member 'FS3GameConfigsData::DisableNavigationDuringMatchmaking' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, RTMTimeoutThreshold) == 0x000078, "Member 'FS3GameConfigsData::RTMTimeoutThreshold' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, GameLoadingTimeout) == 0x00007C, "Member 'FS3GameConfigsData::GameLoadingTimeout' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableHapticVibration) == 0x000080, "Member 'FS3GameConfigsData::EnableHapticVibration' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableWinGDKAccountMismatchPopup) == 0x000081, "Member 'FS3GameConfigsData::EnableWinGDKAccountMismatchPopup' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableAntiMoveHack) == 0x000082, "Member 'FS3GameConfigsData::EnableAntiMoveHack' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, CrossPromoManagerPlatforms) == 0x000088, "Member 'FS3GameConfigsData::CrossPromoManagerPlatforms' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, CrossPromoManagerPlatforms_IsSet) == 0x0000D8, "Member 'FS3GameConfigsData::CrossPromoManagerPlatforms_IsSet' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, FriendsList) == 0x0000DC, "Member 'FS3GameConfigsData::FriendsList' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, HitValidation) == 0x0000E8, "Member 'FS3GameConfigsData::HitValidation' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Jwt) == 0x000100, "Member 'FS3GameConfigsData::Jwt' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Match) == 0x000104, "Member 'FS3GameConfigsData::Match' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Loading) == 0x000110, "Member 'FS3GameConfigsData::Loading' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, MatchmakingCrossplayPlatforms) == 0x000140, "Member 'FS3GameConfigsData::MatchmakingCrossplayPlatforms' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, MirrorsDefaultRetryPolicy) == 0x000190, "Member 'FS3GameConfigsData::MirrorsDefaultRetryPolicy' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Online) == 0x0001A0, "Member 'FS3GameConfigsData::Online' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Security) == 0x0001C0, "Member 'FS3GameConfigsData::Security' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, SocialCrossfriendsPlatforms) == 0x0001C8, "Member 'FS3GameConfigsData::SocialCrossfriendsPlatforms' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, SocialCrossprogressionPlatforms) == 0x000218, "Member 'FS3GameConfigsData::SocialCrossprogressionPlatforms' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3PrestigeConfig
// 0x0020 (0x0020 - 0x0000)
struct FS3PrestigeConfig final
{
public:
	int32                                         MaxPrestige;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PerkThresholds;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PrestigeCost;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3PrestigeConfig) == 0x000008, "Wrong alignment on FS3PrestigeConfig");
static_assert(sizeof(FS3PrestigeConfig) == 0x000020, "Wrong size on FS3PrestigeConfig");
static_assert(offsetof(FS3PrestigeConfig, MaxPrestige) == 0x000000, "Member 'FS3PrestigeConfig::MaxPrestige' has a wrong offset!");
static_assert(offsetof(FS3PrestigeConfig, PerkThresholds) == 0x000008, "Member 'FS3PrestigeConfig::PerkThresholds' has a wrong offset!");
static_assert(offsetof(FS3PrestigeConfig, PrestigeCost) == 0x000018, "Member 'FS3PrestigeConfig::PrestigeCost' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3PrestigeRewards
// 0x0018 (0x0018 - 0x0000)
struct FS3PrestigeRewards final
{
public:
	int32                                         PrestigeLevel;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FS3PrestigeRewardItem>          Rewards;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3PrestigeRewards) == 0x000008, "Wrong alignment on FS3PrestigeRewards");
static_assert(sizeof(FS3PrestigeRewards) == 0x000018, "Wrong size on FS3PrestigeRewards");
static_assert(offsetof(FS3PrestigeRewards, PrestigeLevel) == 0x000000, "Member 'FS3PrestigeRewards::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FS3PrestigeRewards, Rewards) == 0x000008, "Member 'FS3PrestigeRewards::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3PrestigeCharacterRewards
// 0x0010 (0x0010 - 0x0000)
struct FS3PrestigeCharacterRewards final
{
public:
	TArray<struct FS3PrestigeRewards>             RewardsByPrestigeLevel;                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3PrestigeCharacterRewards) == 0x000008, "Wrong alignment on FS3PrestigeCharacterRewards");
static_assert(sizeof(FS3PrestigeCharacterRewards) == 0x000010, "Wrong size on FS3PrestigeCharacterRewards");
static_assert(offsetof(FS3PrestigeCharacterRewards, RewardsByPrestigeLevel) == 0x000000, "Member 'FS3PrestigeCharacterRewards::RewardsByPrestigeLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3PrestigeData
// 0x0070 (0x0070 - 0x0000)
struct FS3PrestigeData final
{
public:
	struct FS3PrestigeConfig                      Config;                                            // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FS3PrestigeCharacterRewards> RewardsByCharacters;                     // 0x0020(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3PrestigeData) == 0x000008, "Wrong alignment on FS3PrestigeData");
static_assert(sizeof(FS3PrestigeData) == 0x000070, "Wrong size on FS3PrestigeData");
static_assert(offsetof(FS3PrestigeData, Config) == 0x000000, "Member 'FS3PrestigeData::Config' has a wrong offset!");
static_assert(offsetof(FS3PrestigeData, RewardsByCharacters) == 0x000020, "Member 'FS3PrestigeData::RewardsByCharacters' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterAnimation
// 0x0040 (0x0040 - 0x0000)
struct FCharacterAnimation final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAnimationDropdown            Data;                                              // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FCharacterAnimationAssetOutfitOverride> OutfitOverrides;                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnimation) == 0x000008, "Wrong alignment on FCharacterAnimation");
static_assert(sizeof(FCharacterAnimation) == 0x000040, "Wrong size on FCharacterAnimation");
static_assert(offsetof(FCharacterAnimation, Label) == 0x000000, "Member 'FCharacterAnimation::Label' has a wrong offset!");
static_assert(offsetof(FCharacterAnimation, Data) == 0x000010, "Member 'FCharacterAnimation::Data' has a wrong offset!");
static_assert(offsetof(FCharacterAnimation, OutfitOverrides) == 0x000030, "Member 'FCharacterAnimation::OutfitOverrides' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemViewSetting
// 0x0044 (0x0044 - 0x0000)
struct FItemViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCustomizationItemDropdown             Item;                                              // 0x000C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 Settings;                                          // 0x001C(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemViewSetting) == 0x000004, "Wrong alignment on FItemViewSetting");
static_assert(sizeof(FItemViewSetting) == 0x000044, "Wrong size on FItemViewSetting");
static_assert(offsetof(FItemViewSetting, Label) == 0x000000, "Member 'FItemViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FItemViewSetting, Item) == 0x00000C, "Member 'FItemViewSetting::Item' has a wrong offset!");
static_assert(offsetof(FItemViewSetting, Settings) == 0x00001C, "Member 'FItemViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharmViewSetting
// 0x0044 (0x0044 - 0x0000)
struct FCharmViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharmDropdown                         CharmID;                                           // 0x000C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 Settings;                                          // 0x001C(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharmViewSetting) == 0x000004, "Wrong alignment on FCharmViewSetting");
static_assert(sizeof(FCharmViewSetting) == 0x000044, "Wrong size on FCharmViewSetting");
static_assert(offsetof(FCharmViewSetting, Label) == 0x000000, "Member 'FCharmViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FCharmViewSetting, CharmID) == 0x00000C, "Member 'FCharmViewSetting::CharmID' has a wrong offset!");
static_assert(offsetof(FCharmViewSetting, Settings) == 0x00001C, "Member 'FCharmViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharmCategorySetting
// 0x0038 (0x0038 - 0x0000)
struct FCharmCategorySetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharmCategory                                CharmCategory;                                     // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenshotViewSetting                 Settings;                                          // 0x0010(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharmCategorySetting) == 0x000004, "Wrong alignment on FCharmCategorySetting");
static_assert(sizeof(FCharmCategorySetting) == 0x000038, "Wrong size on FCharmCategorySetting");
static_assert(offsetof(FCharmCategorySetting, Label) == 0x000000, "Member 'FCharmCategorySetting::Label' has a wrong offset!");
static_assert(offsetof(FCharmCategorySetting, CharmCategory) == 0x00000C, "Member 'FCharmCategorySetting::CharmCategory' has a wrong offset!");
static_assert(offsetof(FCharmCategorySetting, Settings) == 0x000010, "Member 'FCharmCategorySetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterViewSetting
// 0x003C (0x003C - 0x0000)
struct FCharacterViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterDropdown                     CharacterDropdown;                                 // 0x000C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 Settings;                                          // 0x0014(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterViewSetting) == 0x000004, "Wrong alignment on FCharacterViewSetting");
static_assert(sizeof(FCharacterViewSetting) == 0x00003C, "Wrong size on FCharacterViewSetting");
static_assert(offsetof(FCharacterViewSetting, Label) == 0x000000, "Member 'FCharacterViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FCharacterViewSetting, CharacterDropdown) == 0x00000C, "Member 'FCharacterViewSetting::CharacterDropdown' has a wrong offset!");
static_assert(offsetof(FCharacterViewSetting, Settings) == 0x000014, "Member 'FCharacterViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.GenderViewSetting
// 0x0044 (0x0044 - 0x0000)
struct FGenderViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleItemCategoryDropdown              RoleItemCategory;                                  // 0x000C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EGender                                       Gender;                                            // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenshotViewSetting                 Settings;                                          // 0x001C(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenderViewSetting) == 0x000004, "Wrong alignment on FGenderViewSetting");
static_assert(sizeof(FGenderViewSetting) == 0x000044, "Wrong size on FGenderViewSetting");
static_assert(offsetof(FGenderViewSetting, Label) == 0x000000, "Member 'FGenderViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FGenderViewSetting, RoleItemCategory) == 0x00000C, "Member 'FGenderViewSetting::RoleItemCategory' has a wrong offset!");
static_assert(offsetof(FGenderViewSetting, Gender) == 0x000018, "Member 'FGenderViewSetting::Gender' has a wrong offset!");
static_assert(offsetof(FGenderViewSetting, Settings) == 0x00001C, "Member 'FGenderViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotVFXCharmHookCharmData
// 0x00B8 (0x00B8 - 0x0000)
struct FScreenshotVFXCharmHookCharmData final
{
public:
	TSoftObjectPtr<class UFXSystemAsset>          TargetSystem;                                      // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VFXWarmupTime;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      TargetMaterial;                                    // 0x0038(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      MaterialScalarParameters;                          // 0x0068(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotVFXCharmHookCharmData) == 0x000008, "Wrong alignment on FScreenshotVFXCharmHookCharmData");
static_assert(sizeof(FScreenshotVFXCharmHookCharmData) == 0x0000B8, "Wrong size on FScreenshotVFXCharmHookCharmData");
static_assert(offsetof(FScreenshotVFXCharmHookCharmData, TargetSystem) == 0x000000, "Member 'FScreenshotVFXCharmHookCharmData::TargetSystem' has a wrong offset!");
static_assert(offsetof(FScreenshotVFXCharmHookCharmData, VFXWarmupTime) == 0x000030, "Member 'FScreenshotVFXCharmHookCharmData::VFXWarmupTime' has a wrong offset!");
static_assert(offsetof(FScreenshotVFXCharmHookCharmData, TargetMaterial) == 0x000038, "Member 'FScreenshotVFXCharmHookCharmData::TargetMaterial' has a wrong offset!");
static_assert(offsetof(FScreenshotVFXCharmHookCharmData, MaterialScalarParameters) == 0x000068, "Member 'FScreenshotVFXCharmHookCharmData::MaterialScalarParameters' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotVFXCharmHookCharm
// 0x00C8 (0x00C8 - 0x0000)
struct FScreenshotVFXCharmHookCharm final
{
public:
	struct FCharmDropdown                         Charm;                                             // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotVFXCharmHookCharmData       Data;                                              // 0x0010(0x00B8)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotVFXCharmHookCharm) == 0x000008, "Wrong alignment on FScreenshotVFXCharmHookCharm");
static_assert(sizeof(FScreenshotVFXCharmHookCharm) == 0x0000C8, "Wrong size on FScreenshotVFXCharmHookCharm");
static_assert(offsetof(FScreenshotVFXCharmHookCharm, Charm) == 0x000000, "Member 'FScreenshotVFXCharmHookCharm::Charm' has a wrong offset!");
static_assert(offsetof(FScreenshotVFXCharmHookCharm, Data) == 0x000010, "Member 'FScreenshotVFXCharmHookCharm::Data' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterCameraTag
// 0x0018 (0x0018 - 0x0000)
struct FCharacterCameraTag final
{
public:
	class ACameraActor*                           Camera;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterCamera>               Characters;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCameraTag) == 0x000008, "Wrong alignment on FCharacterCameraTag");
static_assert(sizeof(FCharacterCameraTag) == 0x000018, "Wrong size on FCharacterCameraTag");
static_assert(offsetof(FCharacterCameraTag, Camera) == 0x000000, "Member 'FCharacterCameraTag::Camera' has a wrong offset!");
static_assert(offsetof(FCharacterCameraTag, Characters) == 0x000008, "Member 'FCharacterCameraTag::Characters' has a wrong offset!");

// ScriptStruct DeadByDaylight.RoleGenderCharacterRotation
// 0x0014 (0x0014 - 0x0000)
struct FRoleGenderCharacterRotation final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleDropdown                          Role;                                              // 0x000C(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rotation;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoleGenderCharacterRotation) == 0x000004, "Wrong alignment on FRoleGenderCharacterRotation");
static_assert(sizeof(FRoleGenderCharacterRotation) == 0x000014, "Wrong size on FRoleGenderCharacterRotation");
static_assert(offsetof(FRoleGenderCharacterRotation, Label) == 0x000000, "Member 'FRoleGenderCharacterRotation::Label' has a wrong offset!");
static_assert(offsetof(FRoleGenderCharacterRotation, Role) == 0x00000C, "Member 'FRoleGenderCharacterRotation::Role' has a wrong offset!");
static_assert(offsetof(FRoleGenderCharacterRotation, Rotation) == 0x000010, "Member 'FRoleGenderCharacterRotation::Rotation' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionCustomData
// 0x0040 (0x0040 - 0x0000)
struct FShopTransactionCustomData final
{
public:
	struct FShopTransactionProducts               productsReceived;                                  // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	class FString                                 transactionName;                                   // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 transactionType;                                   // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionCustomData) == 0x000008, "Wrong alignment on FShopTransactionCustomData");
static_assert(sizeof(FShopTransactionCustomData) == 0x000040, "Wrong size on FShopTransactionCustomData");
static_assert(offsetof(FShopTransactionCustomData, productsReceived) == 0x000000, "Member 'FShopTransactionCustomData::productsReceived' has a wrong offset!");
static_assert(offsetof(FShopTransactionCustomData, transactionName) == 0x000020, "Member 'FShopTransactionCustomData::transactionName' has a wrong offset!");
static_assert(offsetof(FShopTransactionCustomData, transactionType) == 0x000030, "Member 'FShopTransactionCustomData::transactionType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionCurrencyProducts
// 0x0010 (0x0010 - 0x0000)
struct FShopTransactionCurrencyProducts final
{
public:
	TArray<struct FShopTransactionVirtualCurrency> virtualCurrencies;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionCurrencyProducts) == 0x000008, "Wrong alignment on FShopTransactionCurrencyProducts");
static_assert(sizeof(FShopTransactionCurrencyProducts) == 0x000010, "Wrong size on FShopTransactionCurrencyProducts");
static_assert(offsetof(FShopTransactionCurrencyProducts, virtualCurrencies) == 0x000000, "Member 'FShopTransactionCurrencyProducts::virtualCurrencies' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionCurrencyCustomData
// 0x0030 (0x0030 - 0x0000)
struct FShopTransactionCurrencyCustomData final
{
public:
	struct FShopTransactionCurrencyProducts       productsReceived;                                  // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 transactionName;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 transactionType;                                   // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionCurrencyCustomData) == 0x000008, "Wrong alignment on FShopTransactionCurrencyCustomData");
static_assert(sizeof(FShopTransactionCurrencyCustomData) == 0x000030, "Wrong size on FShopTransactionCurrencyCustomData");
static_assert(offsetof(FShopTransactionCurrencyCustomData, productsReceived) == 0x000000, "Member 'FShopTransactionCurrencyCustomData::productsReceived' has a wrong offset!");
static_assert(offsetof(FShopTransactionCurrencyCustomData, transactionName) == 0x000010, "Member 'FShopTransactionCurrencyCustomData::transactionName' has a wrong offset!");
static_assert(offsetof(FShopTransactionCurrencyCustomData, transactionType) == 0x000020, "Member 'FShopTransactionCurrencyCustomData::transactionType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionItemCustomData
// 0x0030 (0x0030 - 0x0000)
struct FShopTransactionItemCustomData final
{
public:
	struct FShopTransactionItemProducts           productsReceived;                                  // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 transactionName;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 transactionType;                                   // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionItemCustomData) == 0x000008, "Wrong alignment on FShopTransactionItemCustomData");
static_assert(sizeof(FShopTransactionItemCustomData) == 0x000030, "Wrong size on FShopTransactionItemCustomData");
static_assert(offsetof(FShopTransactionItemCustomData, productsReceived) == 0x000000, "Member 'FShopTransactionItemCustomData::productsReceived' has a wrong offset!");
static_assert(offsetof(FShopTransactionItemCustomData, transactionName) == 0x000010, "Member 'FShopTransactionItemCustomData::transactionName' has a wrong offset!");
static_assert(offsetof(FShopTransactionItemCustomData, transactionType) == 0x000020, "Member 'FShopTransactionItemCustomData::transactionType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopWalletUpdate
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FShopWalletUpdate final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShopWalletUpdate) == 0x000008, "Wrong alignment on FShopWalletUpdate");
static_assert(sizeof(FShopWalletUpdate) == 0x000018, "Wrong size on FShopWalletUpdate");

// ScriptStruct DeadByDaylight.SkillCheckDefinition
// 0x0028 (0x0028 - 0x0000)
struct FSkillCheckDefinition final
{
public:
	float                                         SuccessZoneStart;                                  // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuccessZoneEnd;                                    // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusZoneLength;                                   // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusZoneStart;                                    // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressRate;                                      // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingTickerPosition;                            // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDeactivatedAfterResponse;                        // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarningSoundDelay;                                 // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAudioMuted;                                      // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsJittering;                                       // 0x0021(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSuccessZoneMirrorred;                            // 0x0022(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInsane;                                          // 0x0023(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocallyPredicted;                                // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillCheckDefinition) == 0x000004, "Wrong alignment on FSkillCheckDefinition");
static_assert(sizeof(FSkillCheckDefinition) == 0x000028, "Wrong size on FSkillCheckDefinition");
static_assert(offsetof(FSkillCheckDefinition, SuccessZoneStart) == 0x000000, "Member 'FSkillCheckDefinition::SuccessZoneStart' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, SuccessZoneEnd) == 0x000004, "Member 'FSkillCheckDefinition::SuccessZoneEnd' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, BonusZoneLength) == 0x000008, "Member 'FSkillCheckDefinition::BonusZoneLength' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, BonusZoneStart) == 0x00000C, "Member 'FSkillCheckDefinition::BonusZoneStart' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, ProgressRate) == 0x000010, "Member 'FSkillCheckDefinition::ProgressRate' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, StartingTickerPosition) == 0x000014, "Member 'FSkillCheckDefinition::StartingTickerPosition' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsDeactivatedAfterResponse) == 0x000018, "Member 'FSkillCheckDefinition::IsDeactivatedAfterResponse' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, WarningSoundDelay) == 0x00001C, "Member 'FSkillCheckDefinition::WarningSoundDelay' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsAudioMuted) == 0x000020, "Member 'FSkillCheckDefinition::IsAudioMuted' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsJittering) == 0x000021, "Member 'FSkillCheckDefinition::IsJittering' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsSuccessZoneMirrorred) == 0x000022, "Member 'FSkillCheckDefinition::IsSuccessZoneMirrorred' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsInsane) == 0x000023, "Member 'FSkillCheckDefinition::IsInsane' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsLocallyPredicted) == 0x000024, "Member 'FSkillCheckDefinition::IsLocallyPredicted' has a wrong offset!");

// ScriptStruct DeadByDaylight.SkillCheckResponse
// 0x0020 (0x0020 - 0x0000)
struct FSkillCheckResponse final
{
public:
	float                                         ChargeChange;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTriggeredByInput;                                // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSuccessful;                                      // 0x0005(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBonus;                                           // 0x0006(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInsane;                                          // 0x0007(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTriggeringLoudNoise;                             // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FailedCountedAsGood;                               // 0x0009(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x000A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableInteractionDefinition*       Interaction;                                       // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        VerificationKey;                                   // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillCheckResponse) == 0x000008, "Wrong alignment on FSkillCheckResponse");
static_assert(sizeof(FSkillCheckResponse) == 0x000020, "Wrong size on FSkillCheckResponse");
static_assert(offsetof(FSkillCheckResponse, ChargeChange) == 0x000000, "Member 'FSkillCheckResponse::ChargeChange' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, IsTriggeredByInput) == 0x000004, "Member 'FSkillCheckResponse::IsTriggeredByInput' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, IsSuccessful) == 0x000005, "Member 'FSkillCheckResponse::IsSuccessful' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, IsBonus) == 0x000006, "Member 'FSkillCheckResponse::IsBonus' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, IsInsane) == 0x000007, "Member 'FSkillCheckResponse::IsInsane' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, IsTriggeringLoudNoise) == 0x000008, "Member 'FSkillCheckResponse::IsTriggeringLoudNoise' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, FailedCountedAsGood) == 0x000009, "Member 'FSkillCheckResponse::FailedCountedAsGood' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, Type) == 0x00000A, "Member 'FSkillCheckResponse::Type' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, Interaction) == 0x000010, "Member 'FSkillCheckResponse::Interaction' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, VerificationKey) == 0x000018, "Member 'FSkillCheckResponse::VerificationKey' has a wrong offset!");

// ScriptStruct DeadByDaylight.GiftSpecialActionData
// 0x0038 (0x0040 - 0x0008)
struct FGiftSpecialActionData final : public FDBDTableRowBase
{
public:
	EGiftSpecialAction                            ActionType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMediaSource>            VideoSource;                                       // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGiftSpecialActionData) == 0x000008, "Wrong alignment on FGiftSpecialActionData");
static_assert(sizeof(FGiftSpecialActionData) == 0x000040, "Wrong size on FGiftSpecialActionData");
static_assert(offsetof(FGiftSpecialActionData, ActionType) == 0x000008, "Member 'FGiftSpecialActionData::ActionType' has a wrong offset!");
static_assert(offsetof(FGiftSpecialActionData, VideoSource) == 0x000010, "Member 'FGiftSpecialActionData::VideoSource' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialBehaviourPopulation
// 0x0090 (0x0098 - 0x0008)
struct FSpecialBehaviourPopulation final : public FDBDTableRowBase
{
public:
	class FName                                   _name;                                             // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameplayElementType>                  _spawnerTypes;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<ETileSpawnPointType>                   _spawnPointTypes;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _actor;                                            // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   IterativeWeightAdjustmentStrategyClass;            // 0x0068(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSpecialBehaviourPopulation) == 0x000008, "Wrong alignment on FSpecialBehaviourPopulation");
static_assert(sizeof(FSpecialBehaviourPopulation) == 0x000098, "Wrong size on FSpecialBehaviourPopulation");
static_assert(offsetof(FSpecialBehaviourPopulation, _name) == 0x000008, "Member 'FSpecialBehaviourPopulation::_name' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourPopulation, _spawnerTypes) == 0x000018, "Member 'FSpecialBehaviourPopulation::_spawnerTypes' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourPopulation, _spawnPointTypes) == 0x000028, "Member 'FSpecialBehaviourPopulation::_spawnPointTypes' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourPopulation, _actor) == 0x000038, "Member 'FSpecialBehaviourPopulation::_actor' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourPopulation, IterativeWeightAdjustmentStrategyClass) == 0x000068, "Member 'FSpecialBehaviourPopulation::IterativeWeightAdjustmentStrategyClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventEntryPopupData
// 0x0058 (0x0058 - 0x0000)
struct FSpecialEventEntryPopupData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ImageBannerText;                                   // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventEntryPopupData) == 0x000008, "Wrong alignment on FSpecialEventEntryPopupData");
static_assert(sizeof(FSpecialEventEntryPopupData) == 0x000058, "Wrong size on FSpecialEventEntryPopupData");
static_assert(offsetof(FSpecialEventEntryPopupData, Title) == 0x000000, "Member 'FSpecialEventEntryPopupData::Title' has a wrong offset!");
static_assert(offsetof(FSpecialEventEntryPopupData, Description) == 0x000018, "Member 'FSpecialEventEntryPopupData::Description' has a wrong offset!");
static_assert(offsetof(FSpecialEventEntryPopupData, ImagePath) == 0x000030, "Member 'FSpecialEventEntryPopupData::ImagePath' has a wrong offset!");
static_assert(offsetof(FSpecialEventEntryPopupData, ImageBannerText) == 0x000040, "Member 'FSpecialEventEntryPopupData::ImageBannerText' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventBloodwebData
// 0x0001 (0x0001 - 0x0000)
struct FSpecialEventBloodwebData final
{
public:
	ESpecialEventBloodwebChestCondition           EventChestCondition;                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventBloodwebData) == 0x000001, "Wrong alignment on FSpecialEventBloodwebData");
static_assert(sizeof(FSpecialEventBloodwebData) == 0x000001, "Wrong size on FSpecialEventBloodwebData");
static_assert(offsetof(FSpecialEventBloodwebData, EventChestCondition) == 0x000000, "Member 'FSpecialEventBloodwebData::EventChestCondition' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventOfferingSequenceData
// 0x0060 (0x0060 - 0x0000)
struct FSpecialEventOfferingSequenceData final
{
public:
	TSoftClassPtr<class UClass>                   CardClass;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ManagerClass;                                      // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventOfferingSequenceData) == 0x000008, "Wrong alignment on FSpecialEventOfferingSequenceData");
static_assert(sizeof(FSpecialEventOfferingSequenceData) == 0x000060, "Wrong size on FSpecialEventOfferingSequenceData");
static_assert(offsetof(FSpecialEventOfferingSequenceData, CardClass) == 0x000000, "Member 'FSpecialEventOfferingSequenceData::CardClass' has a wrong offset!");
static_assert(offsetof(FSpecialEventOfferingSequenceData, ManagerClass) == 0x000030, "Member 'FSpecialEventOfferingSequenceData::ManagerClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventData
// 0x0208 (0x0210 - 0x0008)
struct FSpecialEventData final : public FDBDTableRowBase
{
public:
	class FName                                   EventId;                                           // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EventName;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 EventBannerLabel;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventThemeLabel;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTrackedOnline;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSpecialEventLoadingScreen;                      // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecialEventObjectiveData>     Objectives;                                        // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FColor                                 ObjectOutlineColour;                               // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LobbyName;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShopName;                                          // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AdditionalLobbyNames;                              // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AudioStateSpecialEvent;                            // 0x00A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   GameplayPlayerComponent;                           // 0x00B0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GameplayStateComponent;                            // 0x00E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialEventGameMode                         GameMode;                                          // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseEventEntryScreen;                               // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventEntryPopupData            EventEntryData;                                    // 0x0118(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ESpecialEventDependency                       EventDependency;                                   // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMarketDiscount;                                 // 0x0171(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpecialEventBloodwebData              Bloodweb;                                          // 0x0172(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_173[0x5];                                      // 0x0173(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventOfferingSequenceData      OfferingSequence;                                  // 0x0178(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSpecialEventSplashScreenData          SplashScreen;                                      // 0x01D8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventData) == 0x000008, "Wrong alignment on FSpecialEventData");
static_assert(sizeof(FSpecialEventData) == 0x000210, "Wrong size on FSpecialEventData");
static_assert(offsetof(FSpecialEventData, EventId) == 0x000008, "Member 'FSpecialEventData::EventId' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, CurrencyType) == 0x000014, "Member 'FSpecialEventData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EventName) == 0x000018, "Member 'FSpecialEventData::EventName' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EventBannerLabel) == 0x000030, "Member 'FSpecialEventData::EventBannerLabel' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EventThemeLabel) == 0x000040, "Member 'FSpecialEventData::EventThemeLabel' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, IsTrackedOnline) == 0x000050, "Member 'FSpecialEventData::IsTrackedOnline' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, UseSpecialEventLoadingScreen) == 0x000051, "Member 'FSpecialEventData::UseSpecialEventLoadingScreen' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, Objectives) == 0x000058, "Member 'FSpecialEventData::Objectives' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, ObjectOutlineColour) == 0x000068, "Member 'FSpecialEventData::ObjectOutlineColour' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, LobbyName) == 0x000070, "Member 'FSpecialEventData::LobbyName' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, ShopName) == 0x000080, "Member 'FSpecialEventData::ShopName' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, AdditionalLobbyNames) == 0x000090, "Member 'FSpecialEventData::AdditionalLobbyNames' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, AudioStateSpecialEvent) == 0x0000A0, "Member 'FSpecialEventData::AudioStateSpecialEvent' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, GameplayPlayerComponent) == 0x0000B0, "Member 'FSpecialEventData::GameplayPlayerComponent' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, GameplayStateComponent) == 0x0000E0, "Member 'FSpecialEventData::GameplayStateComponent' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, GameMode) == 0x000110, "Member 'FSpecialEventData::GameMode' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, UseEventEntryScreen) == 0x000111, "Member 'FSpecialEventData::UseEventEntryScreen' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EventEntryData) == 0x000118, "Member 'FSpecialEventData::EventEntryData' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EventDependency) == 0x000170, "Member 'FSpecialEventData::EventDependency' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, UseMarketDiscount) == 0x000171, "Member 'FSpecialEventData::UseMarketDiscount' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, Bloodweb) == 0x000172, "Member 'FSpecialEventData::Bloodweb' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, OfferingSequence) == 0x000178, "Member 'FSpecialEventData::OfferingSequence' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, SplashScreen) == 0x0001D8, "Member 'FSpecialEventData::SplashScreen' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventLoadingTextData
// 0x0050 (0x0058 - 0x0008)
struct FSpecialEventLoadingTextData final : public FDBDTableRowBase
{
public:
	class FName                                   EventId;                                           // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventLoadingTextData) == 0x000008, "Wrong alignment on FSpecialEventLoadingTextData");
static_assert(sizeof(FSpecialEventLoadingTextData) == 0x000058, "Wrong size on FSpecialEventLoadingTextData");
static_assert(offsetof(FSpecialEventLoadingTextData, EventId) == 0x000008, "Member 'FSpecialEventLoadingTextData::EventId' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, Title) == 0x000018, "Member 'FSpecialEventLoadingTextData::Title' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, Description) == 0x000030, "Member 'FSpecialEventLoadingTextData::Description' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, IconPath) == 0x000048, "Member 'FSpecialEventLoadingTextData::IconPath' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventsContentData
// 0x00E0 (0x00E0 - 0x0000)
struct FSpecialEventsContentData final
{
public:
	class FString                                 EventId;                                           // 0x0000(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 StartTime;                                         // 0x0010(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MainEndTime;                                       // 0x0020(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PostEndTime;                                       // 0x0030(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0xA0];                                      // 0x0040(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialEventsContentData) == 0x000008, "Wrong alignment on FSpecialEventsContentData");
static_assert(sizeof(FSpecialEventsContentData) == 0x0000E0, "Wrong size on FSpecialEventsContentData");
static_assert(offsetof(FSpecialEventsContentData, EventId) == 0x000000, "Member 'FSpecialEventsContentData::EventId' has a wrong offset!");
static_assert(offsetof(FSpecialEventsContentData, StartTime) == 0x000010, "Member 'FSpecialEventsContentData::StartTime' has a wrong offset!");
static_assert(offsetof(FSpecialEventsContentData, MainEndTime) == 0x000020, "Member 'FSpecialEventsContentData::MainEndTime' has a wrong offset!");
static_assert(offsetof(FSpecialEventsContentData, PostEndTime) == 0x000030, "Member 'FSpecialEventsContentData::PostEndTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.SPecialEventMiscRewards
// 0x0020 (0x0020 - 0x0000)
struct FSPecialEventMiscRewards final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardResponseItem>            Rewards;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSPecialEventMiscRewards) == 0x000008, "Wrong alignment on FSPecialEventMiscRewards");
static_assert(sizeof(FSPecialEventMiscRewards) == 0x000020, "Wrong size on FSPecialEventMiscRewards");
static_assert(offsetof(FSPecialEventMiscRewards, Id) == 0x000000, "Member 'FSPecialEventMiscRewards::Id' has a wrong offset!");
static_assert(offsetof(FSPecialEventMiscRewards, Rewards) == 0x000010, "Member 'FSPecialEventMiscRewards::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventsData
// 0x0070 (0x0070 - 0x0000)
struct FSpecialEventsData final
{
public:
	class FString                                 EventId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSPecialEventMiscRewards>       MiscRewards;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          MiscRewards_IsSet;                                 // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            OwnerRewards;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          OwnerRewards_IsSet;                                // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScoreEventRewards>             ScoreEventRewards;                                 // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ScoreEventRewards_IsSet;                           // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEventPeriod>                   EventPeriods;                                      // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EventPeriods_IsSet;                                // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialEventsData) == 0x000008, "Wrong alignment on FSpecialEventsData");
static_assert(sizeof(FSpecialEventsData) == 0x000070, "Wrong size on FSpecialEventsData");
static_assert(offsetof(FSpecialEventsData, EventId) == 0x000000, "Member 'FSpecialEventsData::EventId' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, MiscRewards) == 0x000010, "Member 'FSpecialEventsData::MiscRewards' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, MiscRewards_IsSet) == 0x000020, "Member 'FSpecialEventsData::MiscRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, OwnerRewards) == 0x000028, "Member 'FSpecialEventsData::OwnerRewards' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, OwnerRewards_IsSet) == 0x000038, "Member 'FSpecialEventsData::OwnerRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, ScoreEventRewards) == 0x000040, "Member 'FSpecialEventsData::ScoreEventRewards' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, ScoreEventRewards_IsSet) == 0x000050, "Member 'FSpecialEventsData::ScoreEventRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, EventPeriods) == 0x000058, "Member 'FSpecialEventsData::EventPeriods' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, EventPeriods_IsSet) == 0x000068, "Member 'FSpecialEventsData::EventPeriods_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventContent
// 0x0028 (0x0028 - 0x0000)
struct FSpecialEventContent final
{
public:
	TArray<struct FSpecialEventsContentData>      SpecialEvents;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSpecialEventsData>             SpecialEventsData;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SpecialEventsData_IsSet;                           // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialEventContent) == 0x000008, "Wrong alignment on FSpecialEventContent");
static_assert(sizeof(FSpecialEventContent) == 0x000028, "Wrong size on FSpecialEventContent");
static_assert(offsetof(FSpecialEventContent, SpecialEvents) == 0x000000, "Member 'FSpecialEventContent::SpecialEvents' has a wrong offset!");
static_assert(offsetof(FSpecialEventContent, SpecialEventsData) == 0x000010, "Member 'FSpecialEventContent::SpecialEventsData' has a wrong offset!");
static_assert(offsetof(FSpecialEventContent, SpecialEventsData_IsSet) == 0x000020, "Member 'FSpecialEventContent::SpecialEventsData_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.StatusEffectInitializationData
// 0x0028 (0x0028 - 0x0000)
struct FStatusEffectInitializationData final
{
public:
	class ADBDPlayer*                             OriginatingPlayer;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasOriginatingPlayer;                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayModifierContainer*             OriginatingEffect;                                 // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasOriginatingEffect;                              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomParam;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitializationLifeTime;                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AuthorityDataSet;                                  // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectInitializationData) == 0x000008, "Wrong alignment on FStatusEffectInitializationData");
static_assert(sizeof(FStatusEffectInitializationData) == 0x000028, "Wrong size on FStatusEffectInitializationData");
static_assert(offsetof(FStatusEffectInitializationData, OriginatingPlayer) == 0x000000, "Member 'FStatusEffectInitializationData::OriginatingPlayer' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, HasOriginatingPlayer) == 0x000008, "Member 'FStatusEffectInitializationData::HasOriginatingPlayer' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, OriginatingEffect) == 0x000010, "Member 'FStatusEffectInitializationData::OriginatingEffect' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, HasOriginatingEffect) == 0x000018, "Member 'FStatusEffectInitializationData::HasOriginatingEffect' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, StatusEffectType) == 0x000019, "Member 'FStatusEffectInitializationData::StatusEffectType' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, CustomParam) == 0x00001C, "Member 'FStatusEffectInitializationData::CustomParam' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, InitializationLifeTime) == 0x000020, "Member 'FStatusEffectInitializationData::InitializationLifeTime' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, AuthorityDataSet) == 0x000024, "Member 'FStatusEffectInitializationData::AuthorityDataSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.StatusEffectProperties
// 0x0048 (0x0230 - 0x01E8)
struct FStatusEffectProperties final : public FItemData
{
public:
	TArray<class FName>                           Tags;                                              // 0x01E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   StatusEffectBlueprint;                             // 0x01F8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExternalEffectSource                         ExternalEffectSource;                              // 0x0229(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A[0x6];                                      // 0x022A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectProperties) == 0x000008, "Wrong alignment on FStatusEffectProperties");
static_assert(sizeof(FStatusEffectProperties) == 0x000230, "Wrong size on FStatusEffectProperties");
static_assert(offsetof(FStatusEffectProperties, Tags) == 0x0001E8, "Member 'FStatusEffectProperties::Tags' has a wrong offset!");
static_assert(offsetof(FStatusEffectProperties, StatusEffectBlueprint) == 0x0001F8, "Member 'FStatusEffectProperties::StatusEffectBlueprint' has a wrong offset!");
static_assert(offsetof(FStatusEffectProperties, StatusEffectType) == 0x000228, "Member 'FStatusEffectProperties::StatusEffectType' has a wrong offset!");
static_assert(offsetof(FStatusEffectProperties, ExternalEffectSource) == 0x000229, "Member 'FStatusEffectProperties::ExternalEffectSource' has a wrong offset!");

// ScriptStruct DeadByDaylight.StatusEffectSlotData
// 0x0048 (0x0048 - 0x0000)
struct FStatusEffectSlotData final
{
public:
	class FString                                 Id;                                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFilePath;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusEffectSlotData) == 0x000008, "Wrong alignment on FStatusEffectSlotData");
static_assert(sizeof(FStatusEffectSlotData) == 0x000048, "Wrong size on FStatusEffectSlotData");
static_assert(offsetof(FStatusEffectSlotData, Id) == 0x000000, "Member 'FStatusEffectSlotData::Id' has a wrong offset!");
static_assert(offsetof(FStatusEffectSlotData, IconFilePath) == 0x000010, "Member 'FStatusEffectSlotData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FStatusEffectSlotData, DisplayName) == 0x000020, "Member 'FStatusEffectSlotData::DisplayName' has a wrong offset!");
static_assert(offsetof(FStatusEffectSlotData, Description) == 0x000030, "Member 'FStatusEffectSlotData::Description' has a wrong offset!");
static_assert(offsetof(FStatusEffectSlotData, StatusEffectType) == 0x000040, "Member 'FStatusEffectSlotData::StatusEffectType' has a wrong offset!");
static_assert(offsetof(FStatusEffectSlotData, Level) == 0x000044, "Member 'FStatusEffectSlotData::Level' has a wrong offset!");

// ScriptStruct DeadByDaylight.StatusViewProperties
// 0x00C0 (0x00C8 - 0x0008)
struct FStatusViewProperties final : public FDBDTableRowBase
{
public:
	class FName                                   _statusViewID;                                     // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _description;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _displayName;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   _statusViewBlueprint;                              // 0x0048(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStatusEffectType                             _statusType;                                       // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _iconFilePath;                                     // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _iconAsset;                                        // 0x0090(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _playIntroAnimation;                               // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusViewProperties) == 0x000008, "Wrong alignment on FStatusViewProperties");
static_assert(sizeof(FStatusViewProperties) == 0x0000C8, "Wrong size on FStatusViewProperties");
static_assert(offsetof(FStatusViewProperties, _statusViewID) == 0x000008, "Member 'FStatusViewProperties::_statusViewID' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _description) == 0x000018, "Member 'FStatusViewProperties::_description' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _displayName) == 0x000030, "Member 'FStatusViewProperties::_displayName' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _statusViewBlueprint) == 0x000048, "Member 'FStatusViewProperties::_statusViewBlueprint' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _statusType) == 0x000078, "Member 'FStatusViewProperties::_statusType' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _iconFilePath) == 0x000080, "Member 'FStatusViewProperties::_iconFilePath' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _iconAsset) == 0x000090, "Member 'FStatusViewProperties::_iconAsset' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _playIntroAnimation) == 0x0000C0, "Member 'FStatusViewProperties::_playIntroAnimation' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoredInteraction
// 0x0060 (0x0060 - 0x0000)
struct FStoredInteraction final
{
public:
	TWeakObjectPtr<class UInteractionDefinition>  _interaction;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _inputType;                                        // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInteractionPlayerProperties           _playerProperties;                                 // 0x000C(0x0050)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoredInteraction) == 0x000004, "Wrong alignment on FStoredInteraction");
static_assert(sizeof(FStoredInteraction) == 0x000060, "Wrong size on FStoredInteraction");
static_assert(offsetof(FStoredInteraction, _interaction) == 0x000000, "Member 'FStoredInteraction::_interaction' has a wrong offset!");
static_assert(offsetof(FStoredInteraction, _inputType) == 0x000008, "Member 'FStoredInteraction::_inputType' has a wrong offset!");
static_assert(offsetof(FStoredInteraction, _playerProperties) == 0x00000C, "Member 'FStoredInteraction::_playerProperties' has a wrong offset!");

// ScriptStruct DeadByDaylight.StorefrontCustomizationPayloadData
// 0x000B (0x000C - 0x0001)
struct alignas(0x04) FStorefrontCustomizationPayloadData final : public FPromoPackItemPayloadData
{
public:
	uint8                                         Pad_1[0xB];                                        // 0x0001(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStorefrontCustomizationPayloadData) == 0x000004, "Wrong alignment on FStorefrontCustomizationPayloadData");
static_assert(sizeof(FStorefrontCustomizationPayloadData) == 0x00000C, "Wrong size on FStorefrontCustomizationPayloadData");

// ScriptStruct DeadByDaylight.StorefrontStateData
// 0x0001 (0x0001 - 0x0000)
struct FStorefrontStateData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStorefrontStateData) == 0x000001, "Wrong alignment on FStorefrontStateData");
static_assert(sizeof(FStorefrontStateData) == 0x000001, "Wrong size on FStorefrontStateData");

// ScriptStruct DeadByDaylight.StreamerModePlayerData
// 0x0008 (0x0008 - 0x0000)
struct FStreamerModePlayerData final
{
public:
	bool                                          IsAnonymousMode;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnonymousSuffix;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStreamerModePlayerData) == 0x000004, "Wrong alignment on FStreamerModePlayerData");
static_assert(sizeof(FStreamerModePlayerData) == 0x000008, "Wrong size on FStreamerModePlayerData");
static_assert(offsetof(FStreamerModePlayerData, IsAnonymousMode) == 0x000000, "Member 'FStreamerModePlayerData::IsAnonymousMode' has a wrong offset!");
static_assert(offsetof(FStreamerModePlayerData, AnonymousSuffix) == 0x000004, "Member 'FStreamerModePlayerData::AnonymousSuffix' has a wrong offset!");

// ScriptStruct DeadByDaylight.SubscriptionUIData
// 0x00E0 (0x00E8 - 0x0008)
struct FSubscriptionUIData final : public FDBDTableRowBase
{
public:
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, class FText>                PlatformDetails;                                   // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TitleTexture;                                      // 0x0088(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PortraitBorderTexture;                             // 0x00B8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubscriptionUIData) == 0x000008, "Wrong alignment on FSubscriptionUIData");
static_assert(sizeof(FSubscriptionUIData) == 0x0000E8, "Wrong size on FSubscriptionUIData");
static_assert(offsetof(FSubscriptionUIData, DisplayName) == 0x000008, "Member 'FSubscriptionUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FSubscriptionUIData, Description) == 0x000020, "Member 'FSubscriptionUIData::Description' has a wrong offset!");
static_assert(offsetof(FSubscriptionUIData, PlatformDetails) == 0x000038, "Member 'FSubscriptionUIData::PlatformDetails' has a wrong offset!");
static_assert(offsetof(FSubscriptionUIData, TitleTexture) == 0x000088, "Member 'FSubscriptionUIData::TitleTexture' has a wrong offset!");
static_assert(offsetof(FSubscriptionUIData, PortraitBorderTexture) == 0x0000B8, "Member 'FSubscriptionUIData::PortraitBorderTexture' has a wrong offset!");

// ScriptStruct DeadByDaylight.SubscriptionRewardTypeData
// 0x0030 (0x0030 - 0x0000)
struct FSubscriptionRewardTypeData final
{
public:
	TSoftClassPtr<class UClass>                   RewardItemWidget;                                  // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubscriptionRewardTypeData) == 0x000008, "Wrong alignment on FSubscriptionRewardTypeData");
static_assert(sizeof(FSubscriptionRewardTypeData) == 0x000030, "Wrong size on FSubscriptionRewardTypeData");
static_assert(offsetof(FSubscriptionRewardTypeData, RewardItemWidget) == 0x000000, "Member 'FSubscriptionRewardTypeData::RewardItemWidget' has a wrong offset!");

// ScriptStruct DeadByDaylight.SubtitlesDescription
// 0x0048 (0x0050 - 0x0008)
struct FSubtitlesDescription final : public FDBDTableRowBase
{
public:
	class FText                                   SubtitlesText;                                     // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           AudioEvent;                                        // 0x0020(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubtitlesDescription) == 0x000008, "Wrong alignment on FSubtitlesDescription");
static_assert(sizeof(FSubtitlesDescription) == 0x000050, "Wrong size on FSubtitlesDescription");
static_assert(offsetof(FSubtitlesDescription, SubtitlesText) == 0x000008, "Member 'FSubtitlesDescription::SubtitlesText' has a wrong offset!");
static_assert(offsetof(FSubtitlesDescription, AudioEvent) == 0x000020, "Member 'FSubtitlesDescription::AudioEvent' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorActivity
// 0x0028 (0x0028 - 0x0000)
struct FSurvivorActivity final
{
public:
	bool                                          ShouldDisplayProgress;                             // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   TagsAssociatedWithAction;                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivityType;                                      // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSurvivorActivity) == 0x000008, "Wrong alignment on FSurvivorActivity");
static_assert(sizeof(FSurvivorActivity) == 0x000028, "Wrong size on FSurvivorActivity");
static_assert(offsetof(FSurvivorActivity, ShouldDisplayProgress) == 0x000000, "Member 'FSurvivorActivity::ShouldDisplayProgress' has a wrong offset!");
static_assert(offsetof(FSurvivorActivity, TagsAssociatedWithAction) == 0x000008, "Member 'FSurvivorActivity::TagsAssociatedWithAction' has a wrong offset!");
static_assert(offsetof(FSurvivorActivity, ActivityType) == 0x000018, "Member 'FSurvivorActivity::ActivityType' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorActivityUIRowData
// 0x0040 (0x0048 - 0x0008)
struct FSurvivorActivityUIRowData final : public FDBDTunableRowBase
{
public:
	struct FGameplayTag                           ActivityType;                                      // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              IconAsset;                                         // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurvivorActivityUIRowData) == 0x000008, "Wrong alignment on FSurvivorActivityUIRowData");
static_assert(sizeof(FSurvivorActivityUIRowData) == 0x000048, "Wrong size on FSurvivorActivityUIRowData");
static_assert(offsetof(FSurvivorActivityUIRowData, ActivityType) == 0x000008, "Member 'FSurvivorActivityUIRowData::ActivityType' has a wrong offset!");
static_assert(offsetof(FSurvivorActivityUIRowData, IconAsset) == 0x000018, "Member 'FSurvivorActivityUIRowData::IconAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerHitCosmeticParams
// 0x0014 (0x0014 - 0x0000)
struct FPlayerHitCosmeticParams final
{
public:
	TWeakObjectPtr<class APawn>                   Attacker;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ACamperPlayer>           Target;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackType                                   AttackType;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CausedKO;                                          // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWeaponHit;                                       // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerHitCosmeticParams) == 0x000004, "Wrong alignment on FPlayerHitCosmeticParams");
static_assert(sizeof(FPlayerHitCosmeticParams) == 0x000014, "Wrong size on FPlayerHitCosmeticParams");
static_assert(offsetof(FPlayerHitCosmeticParams, Attacker) == 0x000000, "Member 'FPlayerHitCosmeticParams::Attacker' has a wrong offset!");
static_assert(offsetof(FPlayerHitCosmeticParams, Target) == 0x000008, "Member 'FPlayerHitCosmeticParams::Target' has a wrong offset!");
static_assert(offsetof(FPlayerHitCosmeticParams, AttackType) == 0x000010, "Member 'FPlayerHitCosmeticParams::AttackType' has a wrong offset!");
static_assert(offsetof(FPlayerHitCosmeticParams, CausedKO) == 0x000011, "Member 'FPlayerHitCosmeticParams::CausedKO' has a wrong offset!");
static_assert(offsetof(FPlayerHitCosmeticParams, IsWeaponHit) == 0x000012, "Member 'FPlayerHitCosmeticParams::IsWeaponHit' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorSleepiness
// 0x0008 (0x0008 - 0x0000)
struct FSurvivorSleepiness final
{
public:
	float                                         _sleepiness;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sleepThreshold;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSurvivorSleepiness) == 0x000004, "Wrong alignment on FSurvivorSleepiness");
static_assert(sizeof(FSurvivorSleepiness) == 0x000008, "Wrong size on FSurvivorSleepiness");
static_assert(offsetof(FSurvivorSleepiness, _sleepiness) == 0x000000, "Member 'FSurvivorSleepiness::_sleepiness' has a wrong offset!");
static_assert(offsetof(FSurvivorSleepiness, _sleepThreshold) == 0x000004, "Member 'FSurvivorSleepiness::_sleepThreshold' has a wrong offset!");

// ScriptStruct DeadByDaylight.TallyItemChangedData
// 0x0380 (0x0380 - 0x0000)
struct FTallyItemChangedData final
{
public:
	struct FInventorySlotData                     Item;                                              // 0x0000(0x0128)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FInventorySlotData                     Addon1;                                            // 0x0128(0x0128)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FInventorySlotData                     Addon2;                                            // 0x0250(0x0128)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          IsSet;                                             // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnergyTypeEnum                               EnergyType;                                        // 0x0379(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37A[0x2];                                      // 0x037A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnergyLevel;                                       // 0x037C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTallyItemChangedData) == 0x000008, "Wrong alignment on FTallyItemChangedData");
static_assert(sizeof(FTallyItemChangedData) == 0x000380, "Wrong size on FTallyItemChangedData");
static_assert(offsetof(FTallyItemChangedData, Item) == 0x000000, "Member 'FTallyItemChangedData::Item' has a wrong offset!");
static_assert(offsetof(FTallyItemChangedData, Addon1) == 0x000128, "Member 'FTallyItemChangedData::Addon1' has a wrong offset!");
static_assert(offsetof(FTallyItemChangedData, Addon2) == 0x000250, "Member 'FTallyItemChangedData::Addon2' has a wrong offset!");
static_assert(offsetof(FTallyItemChangedData, IsSet) == 0x000378, "Member 'FTallyItemChangedData::IsSet' has a wrong offset!");
static_assert(offsetof(FTallyItemChangedData, EnergyType) == 0x000379, "Member 'FTallyItemChangedData::EnergyType' has a wrong offset!");
static_assert(offsetof(FTallyItemChangedData, EnergyLevel) == 0x00037C, "Member 'FTallyItemChangedData::EnergyLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.TallyPlayerResultData
// 0x02F0 (0x02F0 - 0x0000)
struct FTallyPlayerResultData final
{
public:
	class FName                                   CharacterIconPath;                                 // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerId;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformAccountId;                                 // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MirrorsId;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerScore;                                       // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerRank;                                        // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameState                                    PlayerStatus;                                      // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventorySlotData                     OfferingData;                                      // 0x0070(0x0128)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<struct FInventorySlotData>             PerksData;                                         // 0x0198(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FInventorySlotData                     ItemData;                                          // 0x01A8(0x0128)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<struct FInventorySlotData>             AddonsData;                                        // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FPrestigeData                          PrestigeData;                                      // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsReported;                                        // 0x02E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasher;                                         // 0x02E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMyScore;                                         // 0x02EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOffNetwork;                                      // 0x02EB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowPortraitBorder;                                // 0x02EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsABot;                                            // 0x02ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE[0x2];                                      // 0x02EE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTallyPlayerResultData) == 0x000008, "Wrong alignment on FTallyPlayerResultData");
static_assert(sizeof(FTallyPlayerResultData) == 0x0002F0, "Wrong size on FTallyPlayerResultData");
static_assert(offsetof(FTallyPlayerResultData, CharacterIconPath) == 0x000000, "Member 'FTallyPlayerResultData::CharacterIconPath' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, PlayerId) == 0x000010, "Member 'FTallyPlayerResultData::PlayerId' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, PlatformAccountId) == 0x000020, "Member 'FTallyPlayerResultData::PlatformAccountId' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, MirrorsId) == 0x000030, "Member 'FTallyPlayerResultData::MirrorsId' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, PlayerName) == 0x000040, "Member 'FTallyPlayerResultData::PlayerName' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, CharacterName) == 0x000050, "Member 'FTallyPlayerResultData::CharacterName' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, PlayerScore) == 0x000060, "Member 'FTallyPlayerResultData::PlayerScore' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, PlayerRank) == 0x000064, "Member 'FTallyPlayerResultData::PlayerRank' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, PlayerStatus) == 0x000068, "Member 'FTallyPlayerResultData::PlayerStatus' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, OfferingData) == 0x000070, "Member 'FTallyPlayerResultData::OfferingData' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, PerksData) == 0x000198, "Member 'FTallyPlayerResultData::PerksData' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, ItemData) == 0x0001A8, "Member 'FTallyPlayerResultData::ItemData' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, AddonsData) == 0x0002D0, "Member 'FTallyPlayerResultData::AddonsData' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, PrestigeData) == 0x0002E0, "Member 'FTallyPlayerResultData::PrestigeData' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, IsReported) == 0x0002E8, "Member 'FTallyPlayerResultData::IsReported' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, IsSlasher) == 0x0002E9, "Member 'FTallyPlayerResultData::IsSlasher' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, IsMyScore) == 0x0002EA, "Member 'FTallyPlayerResultData::IsMyScore' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, IsOffNetwork) == 0x0002EB, "Member 'FTallyPlayerResultData::IsOffNetwork' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, ShowPortraitBorder) == 0x0002EC, "Member 'FTallyPlayerResultData::ShowPortraitBorder' has a wrong offset!");
static_assert(offsetof(FTallyPlayerResultData, IsABot) == 0x0002ED, "Member 'FTallyPlayerResultData::IsABot' has a wrong offset!");

// ScriptStruct DeadByDaylight.TeachableTooltipData
// 0x0040 (0x00D8 - 0x0098)
struct FTeachableTooltipData final : public FBaseTooltipData
{
public:
	EItemRarity                                   ItemRarity;                                        // 0x0098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x0099(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharacterName;                                     // 0x00A0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AvailabilityMessage;                               // 0x00B0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EffectMessage;                                     // 0x00C0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseInCharacterSelectionScreen;                     // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeachableStatus                              TeachableStatus;                                   // 0x00D1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeachableTooltipData) == 0x000008, "Wrong alignment on FTeachableTooltipData");
static_assert(sizeof(FTeachableTooltipData) == 0x0000D8, "Wrong size on FTeachableTooltipData");
static_assert(offsetof(FTeachableTooltipData, ItemRarity) == 0x000098, "Member 'FTeachableTooltipData::ItemRarity' has a wrong offset!");
static_assert(offsetof(FTeachableTooltipData, ItemType) == 0x000099, "Member 'FTeachableTooltipData::ItemType' has a wrong offset!");
static_assert(offsetof(FTeachableTooltipData, CharacterName) == 0x0000A0, "Member 'FTeachableTooltipData::CharacterName' has a wrong offset!");
static_assert(offsetof(FTeachableTooltipData, AvailabilityMessage) == 0x0000B0, "Member 'FTeachableTooltipData::AvailabilityMessage' has a wrong offset!");
static_assert(offsetof(FTeachableTooltipData, EffectMessage) == 0x0000C0, "Member 'FTeachableTooltipData::EffectMessage' has a wrong offset!");
static_assert(offsetof(FTeachableTooltipData, UseInCharacterSelectionScreen) == 0x0000D0, "Member 'FTeachableTooltipData::UseInCharacterSelectionScreen' has a wrong offset!");
static_assert(offsetof(FTeachableTooltipData, TeachableStatus) == 0x0000D1, "Member 'FTeachableTooltipData::TeachableStatus' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArrayOfATile
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfATile final
{
public:
	TArray<class ATile*>                          ArrayOfTiles;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfATile) == 0x000008, "Wrong alignment on FArrayOfATile");
static_assert(sizeof(FArrayOfATile) == 0x000010, "Wrong size on FArrayOfATile");
static_assert(offsetof(FArrayOfATile, ArrayOfTiles) == 0x000000, "Member 'FArrayOfATile::ArrayOfTiles' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArrayOfInt32
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfInt32 final
{
public:
	TArray<int32>                                 Value;                                             // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfInt32) == 0x000008, "Wrong alignment on FArrayOfInt32");
static_assert(sizeof(FArrayOfInt32) == 0x000010, "Wrong size on FArrayOfInt32");
static_assert(offsetof(FArrayOfInt32, Value) == 0x000000, "Member 'FArrayOfInt32::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.SelectableTileSpawnPoint
// 0x0030 (0x0030 - 0x0000)
struct FSelectableTileSpawnPoint final
{
public:
	struct FComponentReference                    ComponentReference;                                // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectableTileSpawnPoint) == 0x000008, "Wrong alignment on FSelectableTileSpawnPoint");
static_assert(sizeof(FSelectableTileSpawnPoint) == 0x000030, "Wrong size on FSelectableTileSpawnPoint");
static_assert(offsetof(FSelectableTileSpawnPoint, ComponentReference) == 0x000000, "Member 'FSelectableTileSpawnPoint::ComponentReference' has a wrong offset!");

// ScriptStruct DeadByDaylight.TransactionEventData
// 0x0088 (0x0088 - 0x0000)
struct FTransactionEventData final
{
public:
	class FString                                 TransactionType;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TransactionSource;                                 // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SourceId;                                          // 0x0020(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceTier;                                        // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrencyType;                                      // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyAmount;                                    // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyBalance;                                   // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelAchieved;                                     // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prestige;                                          // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemIDAcquired;                                    // 0x0058(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SelectedCharacter;                                 // 0x0070(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TransactionTriggeredLevelUp;                       // 0x0080(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransactionEventData) == 0x000008, "Wrong alignment on FTransactionEventData");
static_assert(sizeof(FTransactionEventData) == 0x000088, "Wrong size on FTransactionEventData");
static_assert(offsetof(FTransactionEventData, TransactionType) == 0x000000, "Member 'FTransactionEventData::TransactionType' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, TransactionSource) == 0x000010, "Member 'FTransactionEventData::TransactionSource' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, SourceId) == 0x000020, "Member 'FTransactionEventData::SourceId' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, SourceTier) == 0x000030, "Member 'FTransactionEventData::SourceTier' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, CurrencyType) == 0x000038, "Member 'FTransactionEventData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, CurrencyAmount) == 0x000048, "Member 'FTransactionEventData::CurrencyAmount' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, CurrencyBalance) == 0x00004C, "Member 'FTransactionEventData::CurrencyBalance' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, LevelAchieved) == 0x000050, "Member 'FTransactionEventData::LevelAchieved' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, Prestige) == 0x000054, "Member 'FTransactionEventData::Prestige' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, ItemIDAcquired) == 0x000058, "Member 'FTransactionEventData::ItemIDAcquired' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, Rank) == 0x000068, "Member 'FTransactionEventData::Rank' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, SelectedCharacter) == 0x000070, "Member 'FTransactionEventData::SelectedCharacter' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, TransactionTriggeredLevelUp) == 0x000080, "Member 'FTransactionEventData::TransactionTriggeredLevelUp' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerPlatformTunable
// 0x0018 (0x0020 - 0x0008)
struct FPerPlatformTunable final : public FDBDTableRowBase
{
public:
	struct FPerPlatformFloat                      Value;                                             // 0x0008(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerPlatformTunable) == 0x000008, "Wrong alignment on FPerPlatformTunable");
static_assert(sizeof(FPerPlatformTunable) == 0x000020, "Wrong size on FPerPlatformTunable");
static_assert(offsetof(FPerPlatformTunable, Value) == 0x000008, "Member 'FPerPlatformTunable::Value' has a wrong offset!");
static_assert(offsetof(FPerPlatformTunable, Description) == 0x000010, "Member 'FPerPlatformTunable::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.TutorialObjective
// 0x0020 (0x0028 - 0x0008)
struct FTutorialObjective final : public FDBDTableRowBase
{
public:
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsCompletionAnalyticEnabled;                       // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionPromptType                        InteractionPromptType;                             // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialObjectivePlayerActionMapping         PlayerAction;                                      // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionPromptType                        SecondaryInteractionPromptType;                    // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialObjectivePlayerActionMapping         SecondaryPlayerAction;                             // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialObjective) == 0x000008, "Wrong alignment on FTutorialObjective");
static_assert(sizeof(FTutorialObjective) == 0x000028, "Wrong size on FTutorialObjective");
static_assert(offsetof(FTutorialObjective, Description) == 0x000008, "Member 'FTutorialObjective::Description' has a wrong offset!");
static_assert(offsetof(FTutorialObjective, IsCompletionAnalyticEnabled) == 0x000020, "Member 'FTutorialObjective::IsCompletionAnalyticEnabled' has a wrong offset!");
static_assert(offsetof(FTutorialObjective, InteractionPromptType) == 0x000021, "Member 'FTutorialObjective::InteractionPromptType' has a wrong offset!");
static_assert(offsetof(FTutorialObjective, PlayerAction) == 0x000022, "Member 'FTutorialObjective::PlayerAction' has a wrong offset!");
static_assert(offsetof(FTutorialObjective, SecondaryInteractionPromptType) == 0x000023, "Member 'FTutorialObjective::SecondaryInteractionPromptType' has a wrong offset!");
static_assert(offsetof(FTutorialObjective, SecondaryPlayerAction) == 0x000024, "Member 'FTutorialObjective::SecondaryPlayerAction' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotPreviewActionConfig
// 0x0098 (0x0098 - 0x0000)
struct FScreenshotPreviewActionConfig final
{
public:
	bool                                          SkyboxEnabled;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECharacterToolItemType, struct FIntPoint> FrameSizes;                                       // 0x0008(0x0050)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
	uint16                                        RenderResolution;                                  // 0x0058(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTextureRenderTarget2D>  RenderTarget;                                      // 0x0060(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UScreenshotPreviewWidget>   EditorWidgetClass;                                 // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotPreviewActionConfig) == 0x000008, "Wrong alignment on FScreenshotPreviewActionConfig");
static_assert(sizeof(FScreenshotPreviewActionConfig) == 0x000098, "Wrong size on FScreenshotPreviewActionConfig");
static_assert(offsetof(FScreenshotPreviewActionConfig, SkyboxEnabled) == 0x000000, "Member 'FScreenshotPreviewActionConfig::SkyboxEnabled' has a wrong offset!");
static_assert(offsetof(FScreenshotPreviewActionConfig, FrameSizes) == 0x000008, "Member 'FScreenshotPreviewActionConfig::FrameSizes' has a wrong offset!");
static_assert(offsetof(FScreenshotPreviewActionConfig, RenderResolution) == 0x000058, "Member 'FScreenshotPreviewActionConfig::RenderResolution' has a wrong offset!");
static_assert(offsetof(FScreenshotPreviewActionConfig, RenderTarget) == 0x000060, "Member 'FScreenshotPreviewActionConfig::RenderTarget' has a wrong offset!");
static_assert(offsetof(FScreenshotPreviewActionConfig, EditorWidgetClass) == 0x000090, "Member 'FScreenshotPreviewActionConfig::EditorWidgetClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotPreviewAction
// 0x00B8 (0x00B8 - 0x0000)
struct FScreenshotPreviewAction final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNamedButton                           RefreshBtn;                                        // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FScreenshotPreviewActionConfig         Configuration;                                     // 0x0020(0x0098)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotPreviewAction) == 0x000008, "Wrong alignment on FScreenshotPreviewAction");
static_assert(sizeof(FScreenshotPreviewAction) == 0x0000B8, "Wrong size on FScreenshotPreviewAction");
static_assert(offsetof(FScreenshotPreviewAction, Enabled) == 0x000000, "Member 'FScreenshotPreviewAction::Enabled' has a wrong offset!");
static_assert(offsetof(FScreenshotPreviewAction, RefreshBtn) == 0x000008, "Member 'FScreenshotPreviewAction::RefreshBtn' has a wrong offset!");
static_assert(offsetof(FScreenshotPreviewAction, Configuration) == 0x000020, "Member 'FScreenshotPreviewAction::Configuration' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotExportAction
// 0x0018 (0x0018 - 0x0000)
struct FScreenshotExportAction final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExportOnce;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeDLCFolder;                                  // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Directories;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotExportAction) == 0x000008, "Wrong alignment on FScreenshotExportAction");
static_assert(sizeof(FScreenshotExportAction) == 0x000018, "Wrong size on FScreenshotExportAction");
static_assert(offsetof(FScreenshotExportAction, Enabled) == 0x000000, "Member 'FScreenshotExportAction::Enabled' has a wrong offset!");
static_assert(offsetof(FScreenshotExportAction, ExportOnce) == 0x000001, "Member 'FScreenshotExportAction::ExportOnce' has a wrong offset!");
static_assert(offsetof(FScreenshotExportAction, IncludeDLCFolder) == 0x000002, "Member 'FScreenshotExportAction::IncludeDLCFolder' has a wrong offset!");
static_assert(offsetof(FScreenshotExportAction, Directories) == 0x000008, "Member 'FScreenshotExportAction::Directories' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotToolPathInfo
// 0x0018 (0x0018 - 0x0000)
struct FScreenshotToolPathInfo final
{
public:
	bool                                          IncludeDLCFolder;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Path;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FScreenshotToolPathInfo) == 0x000008, "Wrong alignment on FScreenshotToolPathInfo");
static_assert(sizeof(FScreenshotToolPathInfo) == 0x000018, "Wrong size on FScreenshotToolPathInfo");
static_assert(offsetof(FScreenshotToolPathInfo, IncludeDLCFolder) == 0x000000, "Member 'FScreenshotToolPathInfo::IncludeDLCFolder' has a wrong offset!");
static_assert(offsetof(FScreenshotToolPathInfo, Path) == 0x000008, "Member 'FScreenshotToolPathInfo::Path' has a wrong offset!");

// ScriptStruct DeadByDaylight.RichTextFreeTicketImageInfo
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FRichTextFreeTicketImageInfo final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x0090(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichTextFreeTicketImageInfo) == 0x000008, "Wrong alignment on FRichTextFreeTicketImageInfo");
static_assert(sizeof(FRichTextFreeTicketImageInfo) == 0x0000A0, "Wrong size on FRichTextFreeTicketImageInfo");
static_assert(offsetof(FRichTextFreeTicketImageInfo, Padding) == 0x000090, "Member 'FRichTextFreeTicketImageInfo::Padding' has a wrong offset!");

// ScriptStruct DeadByDaylight.WidgetFriendData
// 0x0010 (0x0010 - 0x0000)
struct FWidgetFriendData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGBaseFriendListElement*              correspondingWidget;                               // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetFriendData) == 0x000008, "Wrong alignment on FWidgetFriendData");
static_assert(sizeof(FWidgetFriendData) == 0x000010, "Wrong size on FWidgetFriendData");
static_assert(offsetof(FWidgetFriendData, correspondingWidget) == 0x000008, "Member 'FWidgetFriendData::correspondingWidget' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaSettingMenuData
// 0x0028 (0x0030 - 0x0008)
struct FAtlantaSettingMenuData final : public FDBDTableRowBase
{
public:
	EOverlayTabs                                  OverlayTab;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOverlayMode                                  OverlayMode;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	EAtlantaSettingMenuType                       MenuType;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaSettingMenuData) == 0x000008, "Wrong alignment on FAtlantaSettingMenuData");
static_assert(sizeof(FAtlantaSettingMenuData) == 0x000030, "Wrong size on FAtlantaSettingMenuData");
static_assert(offsetof(FAtlantaSettingMenuData, OverlayTab) == 0x000008, "Member 'FAtlantaSettingMenuData::OverlayTab' has a wrong offset!");
static_assert(offsetof(FAtlantaSettingMenuData, OverlayMode) == 0x000009, "Member 'FAtlantaSettingMenuData::OverlayMode' has a wrong offset!");
static_assert(offsetof(FAtlantaSettingMenuData, DisplayName) == 0x000010, "Member 'FAtlantaSettingMenuData::DisplayName' has a wrong offset!");
static_assert(offsetof(FAtlantaSettingMenuData, MenuType) == 0x000028, "Member 'FAtlantaSettingMenuData::MenuType' has a wrong offset!");

// ScriptStruct DeadByDaylight.HtmlTagConvertRow
// 0x0020 (0x0028 - 0x0008)
struct FHtmlTagConvertRow final : public FTableRowBase
{
public:
	class FString                                 HtmlTag;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RichTextTag;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHtmlTagConvertRow) == 0x000008, "Wrong alignment on FHtmlTagConvertRow");
static_assert(sizeof(FHtmlTagConvertRow) == 0x000028, "Wrong size on FHtmlTagConvertRow");
static_assert(offsetof(FHtmlTagConvertRow, HtmlTag) == 0x000008, "Member 'FHtmlTagConvertRow::HtmlTag' has a wrong offset!");
static_assert(offsetof(FHtmlTagConvertRow, RichTextTag) == 0x000018, "Member 'FHtmlTagConvertRow::RichTextTag' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractButtonInfo
// 0x02F8 (0x0300 - 0x0008)
struct FInteractButtonInfo final : public FTableRowBase
{
public:
	class FName                                   InteractButtonID;                                  // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractionID;                                     // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         InteractionInputType;                              // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Icon;                                              // 0x0028(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EButtonType                                   CancelButtonType;                                  // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonType                                   SecondaryActionButtonType;                         // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            AttackIcon;                                        // 0x00C0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            AbilityIcon;                                       // 0x0150(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ThumbJoystickUnpressedIcon;                        // 0x01E0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ThumbJoystickPressedIcon;                          // 0x0270(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractButtonInfo) == 0x000008, "Wrong alignment on FInteractButtonInfo");
static_assert(sizeof(FInteractButtonInfo) == 0x000300, "Wrong size on FInteractButtonInfo");
static_assert(offsetof(FInteractButtonInfo, InteractButtonID) == 0x000008, "Member 'FInteractButtonInfo::InteractButtonID' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, InteractionID) == 0x000014, "Member 'FInteractButtonInfo::InteractionID' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, PlayerRole) == 0x000020, "Member 'FInteractButtonInfo::PlayerRole' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, InteractionInputType) == 0x000021, "Member 'FInteractButtonInfo::InteractionInputType' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, Icon) == 0x000028, "Member 'FInteractButtonInfo::Icon' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, CancelButtonType) == 0x0000B8, "Member 'FInteractButtonInfo::CancelButtonType' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, SecondaryActionButtonType) == 0x0000B9, "Member 'FInteractButtonInfo::SecondaryActionButtonType' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, AttackIcon) == 0x0000C0, "Member 'FInteractButtonInfo::AttackIcon' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, AbilityIcon) == 0x000150, "Member 'FInteractButtonInfo::AbilityIcon' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, ThumbJoystickUnpressedIcon) == 0x0001E0, "Member 'FInteractButtonInfo::ThumbJoystickUnpressedIcon' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, ThumbJoystickPressedIcon) == 0x000270, "Member 'FInteractButtonInfo::ThumbJoystickPressedIcon' has a wrong offset!");

// ScriptStruct DeadByDaylight.InboxMessageElapsedTime
// 0x0008 (0x0008 - 0x0000)
struct FInboxMessageElapsedTime final
{
public:
	int32                                         ElapsedTime;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInboxMessageTimeUnit                         TimeUnit;                                          // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInboxMessageElapsedTime) == 0x000004, "Wrong alignment on FInboxMessageElapsedTime");
static_assert(sizeof(FInboxMessageElapsedTime) == 0x000008, "Wrong size on FInboxMessageElapsedTime");
static_assert(offsetof(FInboxMessageElapsedTime, ElapsedTime) == 0x000000, "Member 'FInboxMessageElapsedTime::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FInboxMessageElapsedTime, TimeUnit) == 0x000004, "Member 'FInboxMessageElapsedTime::TimeUnit' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizedHudPlayerWrapperIdMapContainer
// 0x0010 (0x0010 - 0x0000)
struct FCustomizedHudPlayerWrapperIdMapContainer final
{
public:
	TArray<struct FGameplayTag>                   Ids;                                               // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizedHudPlayerWrapperIdMapContainer) == 0x000008, "Wrong alignment on FCustomizedHudPlayerWrapperIdMapContainer");
static_assert(sizeof(FCustomizedHudPlayerWrapperIdMapContainer) == 0x000010, "Wrong size on FCustomizedHudPlayerWrapperIdMapContainer");
static_assert(offsetof(FCustomizedHudPlayerWrapperIdMapContainer, Ids) == 0x000000, "Member 'FCustomizedHudPlayerWrapperIdMapContainer::Ids' has a wrong offset!");

// ScriptStruct DeadByDaylight.RichTextRewardRow
// 0x0448 (0x0450 - 0x0008)
struct FRichTextRewardRow final : public FTableRowBase
{
public:
	struct FTextBlockStyle                        TextStyle;                                         // 0x0008(0x0288)(Edit, NativeAccessSpecifierPublic)
	struct FMargin                                TextMargin;                                        // 0x0290(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Brush;                                             // 0x02A0(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            TintsBrush;                                        // 0x0330(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BackgroundBrush;                                   // 0x03C0(0x0090)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichTextRewardRow) == 0x000008, "Wrong alignment on FRichTextRewardRow");
static_assert(sizeof(FRichTextRewardRow) == 0x000450, "Wrong size on FRichTextRewardRow");
static_assert(offsetof(FRichTextRewardRow, TextStyle) == 0x000008, "Member 'FRichTextRewardRow::TextStyle' has a wrong offset!");
static_assert(offsetof(FRichTextRewardRow, TextMargin) == 0x000290, "Member 'FRichTextRewardRow::TextMargin' has a wrong offset!");
static_assert(offsetof(FRichTextRewardRow, Brush) == 0x0002A0, "Member 'FRichTextRewardRow::Brush' has a wrong offset!");
static_assert(offsetof(FRichTextRewardRow, TintsBrush) == 0x000330, "Member 'FRichTextRewardRow::TintsBrush' has a wrong offset!");
static_assert(offsetof(FRichTextRewardRow, BackgroundBrush) == 0x0003C0, "Member 'FRichTextRewardRow::BackgroundBrush' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerInfoData
// 0x0058 (0x0058 - 0x0000)
struct FPlayerInfoData final
{
public:
	class FString                                 CharacterName;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterIconPath;                                 // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterLevel;                                    // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeLevel;                                     // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanPrestige;                                       // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DevotionLevel;                                     // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerRank;                                        // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivePips;                                        // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPipsToNextRank;                                 // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ready;                                             // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasher;                                         // 0x0055(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowPortraitBorder;                                // 0x0056(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasActiveSubscription;                             // 0x0057(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInfoData) == 0x000008, "Wrong alignment on FPlayerInfoData");
static_assert(sizeof(FPlayerInfoData) == 0x000058, "Wrong size on FPlayerInfoData");
static_assert(offsetof(FPlayerInfoData, CharacterName) == 0x000000, "Member 'FPlayerInfoData::CharacterName' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, CharacterIconPath) == 0x000010, "Member 'FPlayerInfoData::CharacterIconPath' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, CharacterLevel) == 0x000020, "Member 'FPlayerInfoData::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, PrestigeLevel) == 0x000024, "Member 'FPlayerInfoData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, CanPrestige) == 0x000028, "Member 'FPlayerInfoData::CanPrestige' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, PlayerName) == 0x000030, "Member 'FPlayerInfoData::PlayerName' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, PlayerLevel) == 0x000040, "Member 'FPlayerInfoData::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, DevotionLevel) == 0x000044, "Member 'FPlayerInfoData::DevotionLevel' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, PlayerRank) == 0x000048, "Member 'FPlayerInfoData::PlayerRank' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, ActivePips) == 0x00004C, "Member 'FPlayerInfoData::ActivePips' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, NumPipsToNextRank) == 0x000050, "Member 'FPlayerInfoData::NumPipsToNextRank' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, Ready) == 0x000054, "Member 'FPlayerInfoData::Ready' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, IsSlasher) == 0x000055, "Member 'FPlayerInfoData::IsSlasher' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, ShowPortraitBorder) == 0x000056, "Member 'FPlayerInfoData::ShowPortraitBorder' has a wrong offset!");
static_assert(offsetof(FPlayerInfoData, HasActiveSubscription) == 0x000057, "Member 'FPlayerInfoData::HasActiveSubscription' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScoreCategoryUIExtraData
// 0x0028 (0x0028 - 0x0000)
struct FScoreCategoryUIExtraData final
{
public:
	class FText                                   ScoreCategoryName;                                 // 0x0000(0x0018)(Edit, Transient, NativeAccessSpecifierPublic)
	class UTexture2D*                             ScoreCategoryAsset;                                // 0x0018(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreValue;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScoreCategoryUIExtraData) == 0x000008, "Wrong alignment on FScoreCategoryUIExtraData");
static_assert(sizeof(FScoreCategoryUIExtraData) == 0x000028, "Wrong size on FScoreCategoryUIExtraData");
static_assert(offsetof(FScoreCategoryUIExtraData, ScoreCategoryName) == 0x000000, "Member 'FScoreCategoryUIExtraData::ScoreCategoryName' has a wrong offset!");
static_assert(offsetof(FScoreCategoryUIExtraData, ScoreCategoryAsset) == 0x000018, "Member 'FScoreCategoryUIExtraData::ScoreCategoryAsset' has a wrong offset!");
static_assert(offsetof(FScoreCategoryUIExtraData, ScoreValue) == 0x000020, "Member 'FScoreCategoryUIExtraData::ScoreValue' has a wrong offset!");

// ScriptStruct DeadByDaylight.VariationData
// 0x0028 (0x0030 - 0x0008)
struct FVariationData final : public FDBDTableRowBase
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVariationData) == 0x000008, "Wrong alignment on FVariationData");
static_assert(sizeof(FVariationData) == 0x000030, "Wrong size on FVariationData");
static_assert(offsetof(FVariationData, Tag) == 0x000008, "Member 'FVariationData::Tag' has a wrong offset!");
static_assert(offsetof(FVariationData, Name) == 0x000018, "Member 'FVariationData::Name' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesVignettes
// 0x0060 (0x0068 - 0x0008)
struct FArchivesVignettes final : public FDBDTableRowBase
{
public:
	class FString                                 VignetteId;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FArchivesVignetteEntry>         Entries;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UMediaSource>>    CinematicPaths;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivesVignettes) == 0x000008, "Wrong alignment on FArchivesVignettes");
static_assert(sizeof(FArchivesVignettes) == 0x000068, "Wrong size on FArchivesVignettes");
static_assert(offsetof(FArchivesVignettes, VignetteId) == 0x000008, "Member 'FArchivesVignettes::VignetteId' has a wrong offset!");
static_assert(offsetof(FArchivesVignettes, Title) == 0x000018, "Member 'FArchivesVignettes::Title' has a wrong offset!");
static_assert(offsetof(FArchivesVignettes, Subtitle) == 0x000030, "Member 'FArchivesVignettes::Subtitle' has a wrong offset!");
static_assert(offsetof(FArchivesVignettes, Entries) == 0x000048, "Member 'FArchivesVignettes::Entries' has a wrong offset!");
static_assert(offsetof(FArchivesVignettes, CinematicPaths) == 0x000058, "Member 'FArchivesVignettes::CinematicPaths' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesJournal
// 0x0028 (0x0040 - 0x0018)
struct FArchivesJournal final : public FDBDTableRowBaseWithId
{
public:
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FArchivesVignettes>             Vignettes;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivesJournal) == 0x000008, "Wrong alignment on FArchivesJournal");
static_assert(sizeof(FArchivesJournal) == 0x000040, "Wrong size on FArchivesJournal");
static_assert(offsetof(FArchivesJournal, Title) == 0x000018, "Member 'FArchivesJournal::Title' has a wrong offset!");
static_assert(offsetof(FArchivesJournal, Vignettes) == 0x000030, "Member 'FArchivesJournal::Vignettes' has a wrong offset!");

// ScriptStruct DeadByDaylight.WalesCypherEventData
// 0x0030 (0x0030 - 0x0000)
struct FWalesCypherEventData final
{
public:
	class FString                                 EnteredSequence;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExpectedSequence;                                  // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeoutThreshold;                                  // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Timeout;                                           // 0x0025(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CharmGranted;                                      // 0x0026(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ValidCharacterSelcted;                             // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWalesCypherEventData) == 0x000008, "Wrong alignment on FWalesCypherEventData");
static_assert(sizeof(FWalesCypherEventData) == 0x000030, "Wrong size on FWalesCypherEventData");
static_assert(offsetof(FWalesCypherEventData, EnteredSequence) == 0x000000, "Member 'FWalesCypherEventData::EnteredSequence' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, ExpectedSequence) == 0x000010, "Member 'FWalesCypherEventData::ExpectedSequence' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, TimeoutThreshold) == 0x000020, "Member 'FWalesCypherEventData::TimeoutThreshold' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, Success) == 0x000024, "Member 'FWalesCypherEventData::Success' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, Timeout) == 0x000025, "Member 'FWalesCypherEventData::Timeout' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, CharmGranted) == 0x000026, "Member 'FWalesCypherEventData::CharmGranted' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, ValidCharacterSelcted) == 0x000028, "Member 'FWalesCypherEventData::ValidCharacterSelcted' has a wrong offset!");

// ScriptStruct DeadByDaylight.WalletUpdateTracker
// 0x0050 (0x0050 - 0x0000)
struct FWalletUpdateTracker final
{
public:
	TMap<class FString, int32>                    _walletChangeMap;                                  // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FWalletUpdateTracker) == 0x000008, "Wrong alignment on FWalletUpdateTracker");
static_assert(sizeof(FWalletUpdateTracker) == 0x000050, "Wrong size on FWalletUpdateTracker");
static_assert(offsetof(FWalletUpdateTracker, _walletChangeMap) == 0x000000, "Member 'FWalletUpdateTracker::_walletChangeMap' has a wrong offset!");

// ScriptStruct DeadByDaylight.NativeBlockIndicatorData
// 0x0018 (0x0018 - 0x0000)
struct FNativeBlockIndicatorData final
{
public:
	bool                                          IsBlockActive;                                     // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBlockUpdating;                                   // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentBlockFade;                                  // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FadeCurve;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        BlockIndicator;                                    // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNativeBlockIndicatorData) == 0x000008, "Wrong alignment on FNativeBlockIndicatorData");
static_assert(sizeof(FNativeBlockIndicatorData) == 0x000018, "Wrong size on FNativeBlockIndicatorData");
static_assert(offsetof(FNativeBlockIndicatorData, IsBlockActive) == 0x000000, "Member 'FNativeBlockIndicatorData::IsBlockActive' has a wrong offset!");
static_assert(offsetof(FNativeBlockIndicatorData, IsBlockUpdating) == 0x000001, "Member 'FNativeBlockIndicatorData::IsBlockUpdating' has a wrong offset!");
static_assert(offsetof(FNativeBlockIndicatorData, CurrentBlockFade) == 0x000004, "Member 'FNativeBlockIndicatorData::CurrentBlockFade' has a wrong offset!");
static_assert(offsetof(FNativeBlockIndicatorData, FadeCurve) == 0x000008, "Member 'FNativeBlockIndicatorData::FadeCurve' has a wrong offset!");
static_assert(offsetof(FNativeBlockIndicatorData, BlockIndicator) == 0x000010, "Member 'FNativeBlockIndicatorData::BlockIndicator' has a wrong offset!");

// ScriptStruct DeadByDaylight.XpBonusData
// 0x0018 (0x0018 - 0x0000)
struct FXpBonusData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpValue;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXpBonusData) == 0x000008, "Wrong alignment on FXpBonusData");
static_assert(sizeof(FXpBonusData) == 0x000018, "Wrong size on FXpBonusData");
static_assert(offsetof(FXpBonusData, Name) == 0x000000, "Member 'FXpBonusData::Name' has a wrong offset!");
static_assert(offsetof(FXpBonusData, XpValue) == 0x000010, "Member 'FXpBonusData::XpValue' has a wrong offset!");

}

