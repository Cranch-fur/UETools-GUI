#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AnimationUtilities

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AnimationUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class AnimationUtilities.AnimInstanceExt
// 0x0000 (0x0030 - 0x0030)
class UAnimInstanceExt final : public UBlueprintFunctionLibrary
{
public:
	static class AActor* GetOwningActor(const class UAnimInstance* animInstance);
	static class ACharacter* GetOwningCharacter(const class UAnimInstance* animInstance);
	static class USkeletalMeshComponent* GetOwningCharacterSkeletalMeshComponent(const class UAnimInstance* animInstance);
	static class USkeletalMeshComponent* GetRootSkeletalMeshComponent(const class UAnimInstance* animInstance);
	static class UAnimInstance* GetSubAnimInstance(const class UAnimInstance* root, class UClass* type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceExt">();
	}
	static class UAnimInstanceExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstanceExt>();
	}
};
static_assert(alignof(UAnimInstanceExt) == 0x000008, "Wrong alignment on UAnimInstanceExt");
static_assert(sizeof(UAnimInstanceExt) == 0x000030, "Wrong size on UAnimInstanceExt");

// Class AnimationUtilities.SleepingAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) USleepingAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageStart(class UAnimMontage* montage);
	void SetNeverIdle(bool neverIdle);
	void Wakeup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SleepingAnimInstance">();
	}
	static class USleepingAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USleepingAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(USleepingAnimInstance) == 0x000010, "Wrong alignment on USleepingAnimInstance");
static_assert(sizeof(USleepingAnimInstance) == 0x0002D0, "Wrong size on USleepingAnimInstance");

// Class AnimationUtilities.AnimCollection
// 0x0108 (0x0140 - 0x0038)
class UAnimCollection final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, class UAnimSequence*> _taggedAnimSequences;                            // 0x0038(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UBlendSpaceBase*> _taggedAnimBlendspaces;                        // 0x0088(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FAnimSequenceSelector> _taggedAnimSelectors;                    // 0x00D8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAnimCollection*                        _parent;                                           // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimCollection*>                _children;                                         // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCollection">();
	}
	static class UAnimCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCollection>();
	}
};
static_assert(alignof(UAnimCollection) == 0x000008, "Wrong alignment on UAnimCollection");
static_assert(sizeof(UAnimCollection) == 0x000140, "Wrong size on UAnimCollection");
static_assert(offsetof(UAnimCollection, _taggedAnimSequences) == 0x000038, "Member 'UAnimCollection::_taggedAnimSequences' has a wrong offset!");
static_assert(offsetof(UAnimCollection, _taggedAnimBlendspaces) == 0x000088, "Member 'UAnimCollection::_taggedAnimBlendspaces' has a wrong offset!");
static_assert(offsetof(UAnimCollection, _taggedAnimSelectors) == 0x0000D8, "Member 'UAnimCollection::_taggedAnimSelectors' has a wrong offset!");
static_assert(offsetof(UAnimCollection, _parent) == 0x000128, "Member 'UAnimCollection::_parent' has a wrong offset!");
static_assert(offsetof(UAnimCollection, _children) == 0x000130, "Member 'UAnimCollection::_children' has a wrong offset!");

// Class AnimationUtilities.AnimEffectBlackBoard
// 0x0050 (0x0080 - 0x0030)
class UAnimEffectBlackBoard final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimEffectBlackBoard">();
	}
	static class UAnimEffectBlackBoard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimEffectBlackBoard>();
	}
};
static_assert(alignof(UAnimEffectBlackBoard) == 0x000008, "Wrong alignment on UAnimEffectBlackBoard");
static_assert(sizeof(UAnimEffectBlackBoard) == 0x000080, "Wrong size on UAnimEffectBlackBoard");

// Class AnimationUtilities.AnimEffectHandler
// 0x0000 (0x0030 - 0x0030)
class UAnimEffectHandler final : public UObject
{
public:
	bool HandleAnimNotify(class AActor* player, const class FName& notifyName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimEffectHandler">();
	}
	static class UAnimEffectHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimEffectHandler>();
	}
};
static_assert(alignof(UAnimEffectHandler) == 0x000008, "Wrong alignment on UAnimEffectHandler");
static_assert(sizeof(UAnimEffectHandler) == 0x000030, "Wrong size on UAnimEffectHandler");

// Class AnimationUtilities.AnimLayerUpdateInterface
// 0x0000 (0x0000 - 0x0000)
class IAnimLayerUpdateInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimLayerUpdateInterface">();
	}
	static class IAnimLayerUpdateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimLayerUpdateInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAnimLayerUpdateInterface) == 0x000001, "Wrong alignment on IAnimLayerUpdateInterface");
static_assert(sizeof(IAnimLayerUpdateInterface) == 0x000001, "Wrong size on IAnimLayerUpdateInterface");

// Class AnimationUtilities.DetectionFanComponent
// 0x0060 (0x0280 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) UDetectionFanComponent : public USceneComponent
{
public:
	struct FFloatRange                            _angleRange;                                       // 0x0218(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _originWorldOffset;                                // 0x0228(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _numberOfSpots;                                    // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _defaultRingRadius;                                // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             _collisionChannel;                                 // 0x023C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 _meshComponent;                                    // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x30];                                     // 0x0248(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetectionFanComponent">();
	}
	static class UDetectionFanComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetectionFanComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDetectionFanComponent) == 0x000010, "Wrong alignment on UDetectionFanComponent");
static_assert(sizeof(UDetectionFanComponent) == 0x000280, "Wrong size on UDetectionFanComponent");
static_assert(offsetof(UDetectionFanComponent, _angleRange) == 0x000218, "Member 'UDetectionFanComponent::_angleRange' has a wrong offset!");
static_assert(offsetof(UDetectionFanComponent, _originWorldOffset) == 0x000228, "Member 'UDetectionFanComponent::_originWorldOffset' has a wrong offset!");
static_assert(offsetof(UDetectionFanComponent, _numberOfSpots) == 0x000234, "Member 'UDetectionFanComponent::_numberOfSpots' has a wrong offset!");
static_assert(offsetof(UDetectionFanComponent, _defaultRingRadius) == 0x000238, "Member 'UDetectionFanComponent::_defaultRingRadius' has a wrong offset!");
static_assert(offsetof(UDetectionFanComponent, _collisionChannel) == 0x00023C, "Member 'UDetectionFanComponent::_collisionChannel' has a wrong offset!");
static_assert(offsetof(UDetectionFanComponent, _meshComponent) == 0x000240, "Member 'UDetectionFanComponent::_meshComponent' has a wrong offset!");

// Class AnimationUtilities.ArmDetectionFanComponent
// 0x0090 (0x0310 - 0x0280)
class UArmDetectionFanComponent final : public UDetectionFanComponent
{
public:
	class FName                                   _shoulderBone;                                     // 0x0278(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _elbowBone;                                        // 0x0284(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _handBone;                                         // 0x0290(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _indexBone;                                        // 0x029C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _hipBone;                                          // 0x02A8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x5C];                                     // 0x02B4(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmDetectionFanComponent">();
	}
	static class UArmDetectionFanComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmDetectionFanComponent>();
	}
};
static_assert(alignof(UArmDetectionFanComponent) == 0x000010, "Wrong alignment on UArmDetectionFanComponent");
static_assert(sizeof(UArmDetectionFanComponent) == 0x000310, "Wrong size on UArmDetectionFanComponent");
static_assert(offsetof(UArmDetectionFanComponent, _shoulderBone) == 0x000278, "Member 'UArmDetectionFanComponent::_shoulderBone' has a wrong offset!");
static_assert(offsetof(UArmDetectionFanComponent, _elbowBone) == 0x000284, "Member 'UArmDetectionFanComponent::_elbowBone' has a wrong offset!");
static_assert(offsetof(UArmDetectionFanComponent, _handBone) == 0x000290, "Member 'UArmDetectionFanComponent::_handBone' has a wrong offset!");
static_assert(offsetof(UArmDetectionFanComponent, _indexBone) == 0x00029C, "Member 'UArmDetectionFanComponent::_indexBone' has a wrong offset!");
static_assert(offsetof(UArmDetectionFanComponent, _hipBone) == 0x0002A8, "Member 'UArmDetectionFanComponent::_hipBone' has a wrong offset!");

// Class AnimationUtilities.BaseGroundDetectorComponent
// 0x0118 (0x01D0 - 0x00B8)
class UBaseGroundDetectorComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xB0];                                      // 0x00B8(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _startTransformName;                               // 0x0168(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             _walkableCollisionChannel;                         // 0x0174(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _traceComplex;                                     // 0x0175(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_176[0x2];                                      // 0x0176(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _extraTraceDistance;                               // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkinnedMeshComponent*                  _skinnedMeshComponent;                             // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _startSlopeTransformName;                          // 0x0190(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19C[0x34];                                     // 0x019C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FVector GetGroundPosition(const struct FVector& targetPos, const struct FVector& extraOffset);
	void InitSkinnedMeshComponent(class USkinnedMeshComponent* mesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGroundDetectorComponent">();
	}
	static class UBaseGroundDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseGroundDetectorComponent>();
	}
};
static_assert(alignof(UBaseGroundDetectorComponent) == 0x000008, "Wrong alignment on UBaseGroundDetectorComponent");
static_assert(sizeof(UBaseGroundDetectorComponent) == 0x0001D0, "Wrong size on UBaseGroundDetectorComponent");
static_assert(offsetof(UBaseGroundDetectorComponent, _startTransformName) == 0x000168, "Member 'UBaseGroundDetectorComponent::_startTransformName' has a wrong offset!");
static_assert(offsetof(UBaseGroundDetectorComponent, _walkableCollisionChannel) == 0x000174, "Member 'UBaseGroundDetectorComponent::_walkableCollisionChannel' has a wrong offset!");
static_assert(offsetof(UBaseGroundDetectorComponent, _traceComplex) == 0x000175, "Member 'UBaseGroundDetectorComponent::_traceComplex' has a wrong offset!");
static_assert(offsetof(UBaseGroundDetectorComponent, _extraTraceDistance) == 0x000178, "Member 'UBaseGroundDetectorComponent::_extraTraceDistance' has a wrong offset!");
static_assert(offsetof(UBaseGroundDetectorComponent, _skinnedMeshComponent) == 0x000180, "Member 'UBaseGroundDetectorComponent::_skinnedMeshComponent' has a wrong offset!");
static_assert(offsetof(UBaseGroundDetectorComponent, _startSlopeTransformName) == 0x000190, "Member 'UBaseGroundDetectorComponent::_startSlopeTransformName' has a wrong offset!");

// Class AnimationUtilities.BoneSocketLocalVelocityEvaluator
// 0x0028 (0x00E0 - 0x00B8)
class UBoneSocketLocalVelocityEvaluator final : public UActorComponent
{
public:
	class USkeletalMeshComponent*                 _meshComponent;                                    // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _trackedBoneSocketNames;                           // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetLocalVelocity(const class FName boneSocketName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoneSocketLocalVelocityEvaluator">();
	}
	static class UBoneSocketLocalVelocityEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoneSocketLocalVelocityEvaluator>();
	}
};
static_assert(alignof(UBoneSocketLocalVelocityEvaluator) == 0x000008, "Wrong alignment on UBoneSocketLocalVelocityEvaluator");
static_assert(sizeof(UBoneSocketLocalVelocityEvaluator) == 0x0000E0, "Wrong size on UBoneSocketLocalVelocityEvaluator");
static_assert(offsetof(UBoneSocketLocalVelocityEvaluator, _meshComponent) == 0x0000B8, "Member 'UBoneSocketLocalVelocityEvaluator::_meshComponent' has a wrong offset!");
static_assert(offsetof(UBoneSocketLocalVelocityEvaluator, _trackedBoneSocketNames) == 0x0000C0, "Member 'UBoneSocketLocalVelocityEvaluator::_trackedBoneSocketNames' has a wrong offset!");

// Class AnimationUtilities.FootGroundDetectorComponent
// 0x0030 (0x0200 - 0x01D0)
class UFootGroundDetectorComponent final : public UBaseGroundDetectorComponent
{
public:
	class FName                                   _hipTransformName;                                 // 0x01D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _slopeStartOffset;                                 // 0x01DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _footLength;                                       // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _traceRadius;                                      // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxWalkableSlopeAngle;                            // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            _movementComp;                                     // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootGroundDetectorComponent">();
	}
	static class UFootGroundDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootGroundDetectorComponent>();
	}
};
static_assert(alignof(UFootGroundDetectorComponent) == 0x000008, "Wrong alignment on UFootGroundDetectorComponent");
static_assert(sizeof(UFootGroundDetectorComponent) == 0x000200, "Wrong size on UFootGroundDetectorComponent");
static_assert(offsetof(UFootGroundDetectorComponent, _hipTransformName) == 0x0001D0, "Member 'UFootGroundDetectorComponent::_hipTransformName' has a wrong offset!");
static_assert(offsetof(UFootGroundDetectorComponent, _slopeStartOffset) == 0x0001DC, "Member 'UFootGroundDetectorComponent::_slopeStartOffset' has a wrong offset!");
static_assert(offsetof(UFootGroundDetectorComponent, _footLength) == 0x0001E8, "Member 'UFootGroundDetectorComponent::_footLength' has a wrong offset!");
static_assert(offsetof(UFootGroundDetectorComponent, _traceRadius) == 0x0001EC, "Member 'UFootGroundDetectorComponent::_traceRadius' has a wrong offset!");
static_assert(offsetof(UFootGroundDetectorComponent, _maxWalkableSlopeAngle) == 0x0001F0, "Member 'UFootGroundDetectorComponent::_maxWalkableSlopeAngle' has a wrong offset!");
static_assert(offsetof(UFootGroundDetectorComponent, _movementComp) == 0x0001F8, "Member 'UFootGroundDetectorComponent::_movementComp' has a wrong offset!");

// Class AnimationUtilities.FromBoneGroundDetectorComponent
// 0x0010 (0x01E0 - 0x01D0)
class UFromBoneGroundDetectorComponent final : public UBaseGroundDetectorComponent
{
public:
	struct FVector                                _startOffset;                                      // 0x01D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FromBoneGroundDetectorComponent">();
	}
	static class UFromBoneGroundDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFromBoneGroundDetectorComponent>();
	}
};
static_assert(alignof(UFromBoneGroundDetectorComponent) == 0x000008, "Wrong alignment on UFromBoneGroundDetectorComponent");
static_assert(sizeof(UFromBoneGroundDetectorComponent) == 0x0001E0, "Wrong size on UFromBoneGroundDetectorComponent");
static_assert(offsetof(UFromBoneGroundDetectorComponent, _startOffset) == 0x0001D0, "Member 'UFromBoneGroundDetectorComponent::_startOffset' has a wrong offset!");

// Class AnimationUtilities.AnimationDependency
// 0x0000 (0x0000 - 0x0000)
class IAnimationDependency final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationDependency">();
	}
	static class IAnimationDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimationDependency>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAnimationDependency) == 0x000001, "Wrong alignment on IAnimationDependency");
static_assert(sizeof(IAnimationDependency) == 0x000001, "Wrong size on IAnimationDependency");

// Class AnimationUtilities.AnimInstanceLeader
// 0x0000 (0x0000 - 0x0000)
class IAnimInstanceLeader final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstanceLeader">();
	}
	static class IAnimInstanceLeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimInstanceLeader>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAnimInstanceLeader) == 0x000001, "Wrong alignment on IAnimInstanceLeader");
static_assert(sizeof(IAnimInstanceLeader) == 0x000001, "Wrong size on IAnimInstanceLeader");

// Class AnimationUtilities.MoveComponentToComponent
// 0x0048 (0x0100 - 0x00B8)
class UMoveComponentToComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Start(class USceneComponent* componentToMove, const class USceneComponent* target, const float duration);
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveComponentToComponent">();
	}
	static class UMoveComponentToComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveComponentToComponent>();
	}
};
static_assert(alignof(UMoveComponentToComponent) == 0x000008, "Wrong alignment on UMoveComponentToComponent");
static_assert(sizeof(UMoveComponentToComponent) == 0x000100, "Wrong size on UMoveComponentToComponent");

// Class AnimationUtilities.ResetControlPitchAnimNotify
// 0x0000 (0x0040 - 0x0040)
class UResetControlPitchAnimNotify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResetControlPitchAnimNotify">();
	}
	static class UResetControlPitchAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResetControlPitchAnimNotify>();
	}
};
static_assert(alignof(UResetControlPitchAnimNotify) == 0x000008, "Wrong alignment on UResetControlPitchAnimNotify");
static_assert(sizeof(UResetControlPitchAnimNotify) == 0x000040, "Wrong size on UResetControlPitchAnimNotify");

// Class AnimationUtilities.SlaveAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class USlaveAnimInstance final : public UAnimInstance
{
public:
	TWeakObjectPtr<class USkeletalMeshComponent>  _masterMesh;                                       // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMasterMesh(class USkeletalMeshComponent* masterMesh);

	class USkeletalMeshComponent* GetMasterMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveAnimInstance">();
	}
	static class USlaveAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlaveAnimInstance>();
	}
};
static_assert(alignof(USlaveAnimInstance) == 0x000010, "Wrong alignment on USlaveAnimInstance");
static_assert(sizeof(USlaveAnimInstance) == 0x0002D0, "Wrong size on USlaveAnimInstance");
static_assert(offsetof(USlaveAnimInstance, _masterMesh) == 0x0002C0, "Member 'USlaveAnimInstance::_masterMesh' has a wrong offset!");

// Class AnimationUtilities.SleepingSkinnedMeshRegisterer
// 0x0000 (0x00B8 - 0x00B8)
class USleepingSkinnedMeshRegisterer final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SleepingSkinnedMeshRegisterer">();
	}
	static class USleepingSkinnedMeshRegisterer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USleepingSkinnedMeshRegisterer>();
	}
};
static_assert(alignof(USleepingSkinnedMeshRegisterer) == 0x000008, "Wrong alignment on USleepingSkinnedMeshRegisterer");
static_assert(sizeof(USleepingSkinnedMeshRegisterer) == 0x0000B8, "Wrong size on USleepingSkinnedMeshRegisterer");

}

